---- C:\Users\汪强升\Desktop\3\ABM007_FM3(1)\ABM007_FM3\ABM007_FM3\source\main.c ----------------------------------------------------------------------
1:                // #include <cms.h>	//芯片头文件，会根据工程选项自动寻找对应型号头文件
2:                #include "cfg_user.h"
3:                #include "cfg_case.h"
4:                #include "math.h"
5:                #include "string.h"
6:                
7:                volatile unsigned int TMR1 @0x000E;
8:                #define TIMER1_TIME 0xE0C0
9:                
10:               /**********************************************************************/
11:               /*全局变量声明*/
12:               /**********************************************************************/
13:               
14:               /*变量*/
15:               v_uint8 RX_Buf;
16:               v_uint8 templ = 0;
17:               v_uint8 SEQmain = 0;
18:               v_uint8 MainTime_1min = 0;	/* 定时1min计数 */
19:               v_uint16 MainTime_1s = 0;	/* 定时1s计数 */
20:               v_uint16 AD_Result = 0;
21:               
22:               extern  void INT_LED_SHOW(void);
23:               
24:               /***********************************************************************
25:               函数功能：延时子函数，13个指令周期1循环
26:               ***********************************************************************/
27:               void Delay(unsigned int dtemp)
28:               {
29:               	while (dtemp--)
  027E    3001    LDIA	0x1
  027F    02F2    SUBR	0x72
  0280    3000    LDIA	0x0
  0281    1C03    SNZB	0x3,0
  0282    03F3    DECR	0x73
  0283    02F3    SUBR	0x73
  0284    0F72    SZINCA	0x72
  0285    2A7E    JP	0x27E
  0286    0A73    INCA	0x73
  0287    1903    SZB	0x3,2
  0288    0008    RET
  0289    2A7E    JP	0x27E
30:               		;
31:               }
32:               /***********************************************************************
33:               子函数功能：延时templ  ms，有中断则不准
34:               ***********************************************************************/
35:               void Delay_nms(unsigned int inittempl)
36:               {
37:               	unsigned int i;
38:               	unsigned char gtemp;
39:               	/******************************************************************/
40:               	gtemp = 0;
  025C    1283    CLRB	0x3,5
  025D    01D9    CLR	0x59
41:               	if (GIE == 1)
  025E    1F8B    SNZB	0xB,7
  025F    2A63    JP	0x263
42:               	{
43:               		gtemp = 1;
  0260    01D9    CLR	0x59
  0261    0AD9    INCR	0x59
44:               		GIE = 0;
  0262    138B    CLRB	0xB,7
45:               	}
46:               	for (i = 0; i < inittempl; i++)
  0263    01D7    CLR	0x57
  0264    01D8    CLR	0x58
  0265    0875    LD	A,0x75
  0266    0258    SUBA	0x58
  0267    1D03    SNZB	0x3,2
  0268    2A6B    JP	0x26B
  0269    0874    LD	A,0x74
  026A    0257    SUBA	0x57
  026B    1803    SZB	0x3,0
  026C    2A7A    JP	0x27A
47:               	{
48:               		Delay(154);
  026D    309A    LDIA	0x9A
  026E    00F2    LD	0x72,A
  026F    01F3    CLR	0x73
  0270    227E    CALL	0x27E
  0271    120A    CLRB	0xA,4
  0272    118A    CLRB	0xA,3
  0273    0064    CLRWDT
  0274    1283    CLRB	0x3,5
  0275    1303    CLRB	0x3,6
  0276    0AD7    INCR	0x57
  0277    1903    SZB	0x3,2
  0278    0AD8    INCR	0x58
  0279    2A65    JP	0x265
49:               		asm("clrwdt");
50:               	}
51:               	if (gtemp == 1)
  027A    0B59    SZDECA	0x59
  027B    0008    RET
52:               		GIE = 1;
  027C    178B    SETB	0xB,7
  027D    0008    RET
53:               }
54:               
55:               /************************************************************
56:               函数名称：Init_GPIO()
57:               函数功能：初始化IO端口
58:               入口参数：
59:               出口参数：
60:               备注：
61:               ************************************************************/
62:               void Init_GPIO(void)
63:               {
64:               
65:               	/*引脚数据*/
66:               	PORTA = 0B00000000;
  033D    1283    CLRB	0x3,5
  033E    1303    CLRB	0x3,6
  033F    0185    CLR	0x5
67:               	PORTB = 0B00000000;
  0340    0186    CLR	0x6
68:               	PORTC = 0B00000000;
  0341    0187    CLR	0x7
69:               
70:               	/* 全部配置成输入状态，1: 输入，0: 输出 */
71:               	TRISA = 0B01000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  0342    3040    LDIA	0x40
  0343    1683    SETB	0x3,5
  0344    0085    LD	0x5,A
72:               	TRISB = 0B00000111; /* RB1-龙头感应，RB0测试点 */
  0345    3007    LDIA	0x7
  0346    0086    LD	0x6,A
73:               	TRISC = 0B00000000;
  0347    0187    CLR	0x7
74:               
75:               	/*内部上拉关闭, 1: 开启, 0: 关闭 */
76:               	WPUA = 0B00000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  0348    1703    SETB	0x3,6
  0349    018E    CLR	0xE
77:               	WPUB = 0B00000010; /* RB1-龙头感应<置1则不插为有人状态，RB1低有效>，RB0-测试点，硬件下拉 */
  034A    3002    LDIA	0x2
  034B    1303    CLRB	0x3,6
  034C    0095    LD	0x15,A
78:               	WPUC = 0B00000000;
  034D    1703    SETB	0x3,6
  034E    018F    CLR	0xF
  034F    0008    RET
79:               
80:               	/* 内部下拉 */
81:               	// WPDB =  0B00000000; /* RB1-龙头感应<1不插为无人状态，RB1高有效> */
82:               
83:               	/*模拟通道选择*/
84:               //	ANSEL0 = 0B00000000; // AN7 - AN0
85:               //	ANSEL1 = 0B00000000; // AN15 - AN8
86:               //	ANSEL2 = 0B00000000; //------AN17 AN16
87:               }
88:               
89:               /************************************************************
90:               函数名称：Init_IC()
91:               函数功能：上电初始化系统寄存器
92:               入口参数：
93:               出口参数：
94:               备注：
95:               ************************************************************/
96:               void Init_IC(void)
  0350    0064    CLRWDT
97:               {
98:               	asm("clrwdt");
99:               
100:              	// 7			6			5			4			3			2			1			0
101:              	// GIE		PEIE		TOIE		INTE		RBIE		TOIF		INTF		RBIF
102:              	// 全局允许	外设允许	T0允许		INT允许		PB允许		T0标志		INT标志		PB标志
103:              	INTCON = 0x00; // 中断控制寄存器
  0351    018B    CLR	0xB
104:              
105:              	// 7			6			5			4			3			2			1			0
106:              	//--		ADIF		RCIF		TXIF		--			CCP1IF		TMR2IF		TMR1IF
107:              	// NC		AD转换完成	UART接收满	UART发送满		NC		CCP1中断	T2与PR2匹配		T1
108:              	PIR1 = 0; // 外设中断请求寄存器
  0352    1283    CLRB	0x3,5
  0353    1303    CLRB	0x3,6
  0354    018C    CLR	0xC
109:              
110:              	// 7			6			5			4			3			2			1			0
111:              	//--		TKIF		RACIF		EEIF		--			--			--			CCP2IF
112:              	// NC		触摸检测结束 PA变化		 EEP写完成	  NC		  NC		  NC		  CCP2中断
113:              	PIR2 = 0; // 外设中断请求寄存器
  0355    018D    CLR	0xD
114:              
115:              	// 7			6			5			4			3			2			1			0
116:              	//--		--			--			--			--			--			--			SWDTEN
117:              	// NC		NC			NC			NC			NC			NC			NC			使能
118:              	WDTCON = 0x01; // 看门狗
  0356    3001    LDIA	0x1
  0357    1703    SETB	0x3,6
  0358    0085    LD	0x5,A
119:              
120:              	// 7				6			5			4			3			2			1		0
121:              	// RBPU			INTEDG			T0CS		T0SE		PSA			PS2			PS1		PS0
122:              	// PB上拉使能	中断边沿选择  	T0时钟源	  T0边沿选择	预分配		预分配参数
123:              	OPTION_REG = 0b00001110; // 开启PORTB上来使能，看门狗复位时间=18*分频系数 (规格书 2.6/2.8.1)
  0359    300E    LDIA	0xE
  035A    1683    SETB	0x3,5
  035B    1303    CLRB	0x3,6
  035C    0081    LD	0x1,A
124:              
125:              	// 7			6			5			4			3			2			1			0
126:              	//--		IRCF2		IRCF1		IRCF0		--			--			--			--
127:              	// NC		内振分频							NC			NC			NC			NC
128:              	OSCCON = 0x71; // 振荡器控制
  035D    3071    LDIA	0x71
  035E    008F    LD	0xF,A
129:              
130:              	// 7			6			5			4			3			2			1				0
131:              	//--		ADIE		RCIE		TXIE		--			CCP1IE		TMR2IE			TMR1IE
132:              	// NC		AD转换允许	UART接收允许 UART发送允许 NC		  CCP1允许	  T2与PR2匹配允许	T1溢出允许
133:              	PIE1 = 0; // 外设中断允许
  035F    018C    CLR	0xC
134:              
135:              	//
136:              	//--	TKIE				RACIE			EEIE			--		--		--		CCP2IE
137:              	// NC	触摸检测结束允许	PA变化允许			EEP写允许		NC		NC		NC		CCP2中断允许
138:              	PIE2 = 0; // 外设中断允许
  0360    018D    CLR	0xD
  0361    0008    RET
139:              }
140:              
141:              /************************************************************
142:              函数名称：Init_TIMER1()
143:              函数功能：定时器1初始化函数
144:              入口参数：
145:              出口参数：
146:              备注：	  定时时间计算方法
147:              		  定时时间T = {1/[(Fosc)*预分频比)]}*(65535-[TMR1H:TMR1L])
148:              		  本程序计算示例：
149:              		  T = {1/[(8)*(1/1)]}*(65536 - 63936)
150:              			= 125 us
151:              ************************************************************/
152:              void Init_TIMER1(void)
153:              {
154:              	// TMR1L = 0xC0; //赋初值
155:              	// TMR1H = 0xF9;
156:              	TMR1 = TIMER1_TIME;
  036D    30E0    LDIA	0xE0
  036E    008F    LD	0xF,A
  036F    30C0    LDIA	0xC0
  0370    008E    LD	0xE,A
157:              	TMR1IF = 0;	  // 清中断标志位
  0371    100C    CLRB	0xC,0
158:              	TMR1IE = 1;	  // 允许Timer1中断
  0372    1683    SETB	0x3,5
  0373    140C    SETB	0xC,0
159:              	T1CON = 0x01; // 开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  0374    3001    LDIA	0x1
  0375    1283    CLRB	0x3,5
  0376    0090    LD	0x10,A
  0377    0008    RET
160:              }
161:              
162:              /************************************************************
163:              函数名称：Init_TIMER2()
164:              函数功能：定时器2初始化函数
165:              入口参数：
166:              出口参数：
167:              备注：	  定时时间计算方法
168:              		  时钟输入为系统指令时钟（即为Fosc/4）
169:              		  定时时间T = {1/[(Fosc/4)*预分频比*后分频比]}*(PR2+1)
170:              		  本程序计算示例：
171:              		  T = {1/[(8/4)*(1/4)*1]}*50 = 100 us
172:              
173:              ************************************************************/
174:              void Init_TIMER2(void)
175:              {
176:              	PR2 = 24;	// 8M下将TMR2设置为50us中断?
  0362    3018    LDIA	0x18
  0363    1683    SETB	0x3,5
  0364    0092    LD	0x12,A
177:              	TMR2IF = 0; // 清中断标志位
  0365    1283    CLRB	0x3,5
  0366    108C    CLRB	0xC,1
178:              	TMR2IE = 1; // 允许Timer2中断
  0367    1683    SETB	0x3,5
  0368    148C    SETB	0xC,1
179:              	T2CON = 5;	// 开启Timer2，预分频值为4，后分频比为1:1
  0369    3005    LDIA	0x5
  036A    1283    CLRB	0x3,5
  036B    0092    LD	0x12,A
  036C    0008    RET
180:              }
181:              
182:              /* 遥控器接收数据时钟，50μs */
183:              // void Init_TIMER2_Remo(void)
184:              //{
185:              //	PR2 = 24;		//16M下将TMR2设置为50μs中断
186:              //	TMR2IF = 0; 	//清中断标志位
187:              //	TMR2IE = 1; 	//允许Timer2中断
188:              //	T2CON = 5;		//开启Timer2，预分频值为4，后分频比为1:1
189:              // }
190:              
191:              /***********************************************
192:              函数名称：Set_CCP_PWM
193:              函数功能：CCP PWM模式初始化
194:              入口参数：无
195:              出口参数：无
196:              备注：
197:              	   周期 = (PWMxCYC+1)*4/Fosc*PWMxCNT预分频值
198:              	  占空比 = (CCPRxL:CCPCON<5:4>)/(4*(PWMxCYC + 1))
199:              	  由于CCPx 引脚与端口数据锁存器复用，必须清零相应的TRIS 位才能使能CCPx 引脚的输出驱动器。
200:              ************************************************/
201:              void Set_CCP_PWM()
202:              {
203:              //	PWMCON = 0B00000001; // PWM1设置为16分频，使能PWM1
204:              
205:              	// // PWM1 周期设置为500us，占空比50%
206:              	// CCP1CON = 0B00001100; // PWM模式,10位占空比数据低2位为0；
207:              	// PWM1CYC = 124;		  // PWM1周期为：(249+1)* （4/8） * 4 =500uS
208:              	// CCPR1L = 62;		  // 低2位为0,(CCPRxL:CCPCON<5:4>)=CCPR1L*4
209:              	// CYC1EN = 1;			  /* PWM1的周期计数器使能位,1使能，0禁止 */
210:              	// PWMTL = 0x8f;					//PWM0~3共周期，周期低位
211:              	PWMT4L = 0x7C;					//PWM4独立周期，周期低位,0x7C,(124+1)* （4/8） * 4 =250μs
212:              	PWMTH = 0B00011101;				//周期高两位及PWM4占空比高两位	
213:              	/* PWMTH: bit5~bit4- PWM4占空比高2位，bit3~bit2-PWM周期高2位，bit1~bit0-PWM0~PWM3周期高2位 */
214:              	
215:              	//PWM0~3周期为：(0B110001111+1)*(1/16)*2 =50uS
216:              	//PWM4周期为：(0B1110001111+1)*(1/16)*2 =114uS
217:              	/* PWM4 0B00001100 */
218:              	
219:              	// PWMD01H = 0x00;					//高位改变后不能立即生效，需要给占空比的低位寄存器后才能加载
220:              	// //PWM0 占空比设置为20%
221:              	// PWMD0L = 0x4f;					//(79+1)/(399+1) = 20%
222:              	// //PWM1 占空比设置为40%
223:              	// PWMD1L = 0x9f;					//(159+1)/(399+1) = 40%
224:              
225:              	// PWMD23H = 0x10;
226:              	// //PWM2 占空比设置为60%
227:              	// PWMD2L = 0xef;					//(239+1)/(399+1) = 60%
228:              	// //PWM3 占空比设置为80%
229:              	// PWMD3L = 0x3f;					//(319+1)/(399+1) = 80%
230:              
231:              	//PWM4 占空比设置为25%
232:              	PWMD4L = 0xC7;					//(227+1)/(911+1) = 25% ()
233:              	/* 50% 0x01C7, (455+1)/(911+1) */
234:              	
235:              	// PWM01DT = 0x3F;					//死区时间，低6位有效位=(0B00111111+1)*(1/16)*1 =4uS
236:              	// PWM23DT = 0;
237:              	
238:              	PWMCON2 = 0B00000000;			//正常输出
239:              	PWMCON1 = 0B00000000;			//PWM01位置选择为RB5/RB4;禁止死区；可使能PWM0/1互补，PWM2/3互补
240:              	PWMCON0 = 0B00110000;			//PWM分频Fosc/2，使能PWM4
241:              }
242:              
243:              /***********************************************
244:              函数名称：Memory_Write
245:              函数功能：写数据
246:              入口参数：Addr - 写入地址
247:              		  Value - 写入数值
248:              出口参数：返回值 0 - 写操作错误 1 - 写完毕
249:              备注：
250:              写程序EE过程中需要暂时关闭中断，以保证写EE时序中的写55H和写AAH能够连续进行，否则将有可能写错，并且写EE的可靠工作电压范围为3V以上。
251:              ************************************************/
252:              unsigned char Memory_Write(unsigned char Addr, unsigned char Value)
253:              {
254:              
255:              	volatile unsigned char i = 0;
256:              	// 将要写入的地址放入EEADDR寄存器
257:              	EEADR = Addr;
258:              	EEDAT = Value; // 将要写入的数据给EEPROM的数据寄存器
259:              	EECON1 = 0;
260:              	EEPGD = 0;		 // 访问数据存储器
261:              	EECON1 | = 0x10; // 烧写时间10ms（0x30）,时间非固定精准,用户可自定义(最长烧写等待时间2.5ms, 0x10)
262:              	asm("clrwdt");
263:              
264:              	WREN = 1; // 允许写周期
265:              	GIE = 0;  // 关闭中断
266:              	GIE = 0;
267:              	GIE = 0;
268:              	while (GIE)
269:              	{
270:              		GIE = 0; // 确保中断已关闭
271:              		if (0 == --i)
272:              		{
273:              			// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
274:              			GIE = 1; // 总中断GIE置1
275:              			return 0;
276:              		}
277:              	}
278:              	asm("clrwdt");
279:              
280:              	EECON2 = 0x55; // 给EECON2写入0x55
281:              	EECON2 = 0xaa; // 给EECON2写入0xaa
282:              	WR = 1;		   // 启动写周期
283:              	asm("nop");
284:              	asm("nop");
285:              	asm("clrwdt");
286:              	WREN = 0; // 禁止写入
287:              	// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
288:              	GIE = 1; // 总中断GIE置1
289:              
290:              	if (WRERR)
291:              		return 0; // 写操作错误
292:              	else
293:              		return 1; // 写完毕
294:              }
295:              
296:              void Flash_Write(unsigned char Addr, unsigned char Value)
297:              {
298:              	uint8_t bufAddress;
299:              	uint8_t bufValue;
300:              	bufAddress = Addr;
301:              	bufValue = Value;
302:              	templ = 10; //错误计数，用户可自定义
303:              	do
304:              	{
305:              		asm("clrwdt");
306:              		asm("clrwdt");
307:              	} while ((0 == Memory_Write(bufAddress, bufValue)) && (templ--)); //调用写函数：地址0x00处写入数据0x5a
308:              }
309:              
310:              /***********************************************
311:              函数名称：Memory_Read
312:              函数功能：读数据
313:              入口参数：Addr - 读取地址
314:              出口参数：返回读取地址相应数值
315:              备注：
316:              ************************************************/
317:              unsigned char Memory_Read(unsigned char Addr)
318:              {
319:              
320:              	EEADR = Addr;
321:              	EEPGD = 0; // 访问数据存储器
322:              
323:              	RD = 1; // 允许读操作
324:              	asm("nop");
325:              	asm("nop");
326:              
327:              	return (EEDAT);
328:              }
329:              
330:              /************************************************************
331:              函数名称：AD_Testing()
332:              函数功能：AD采样函数
333:              入口参数：ad_fd - 分频 00Fosc/8; 01Fosc/16; 10Fosc/32; 11Frc;
334:              		  ad_ch - AD通道选择1~15，15通道为内部基准1.2V固定输入值
335:              		  ad_lr - 左/右对齐，输入0或1，0为左对齐，1为右对齐
336:              
337:              出口参数：AdResult - AD结果
338:              备    注：BUFmotor_ad = AD_Testing(0, 10, 0); //8分频，AN10通道，右对齐	规格书11.2.4，8M主频最快8分频
339:              ************************************************************/
340:              unsigned int AD_Testing(unsigned char ad_fd, unsigned char ad_ch, unsigned char ad_lr)
341:              {
342:              	// static volatile unsigned char adtimes;
343:              	// static volatile unsigned int admin, admax, adsum;
344:              	volatile unsigned int data;
345:              	volatile unsigned char i = 0;
346:              
347:              	if (!ad_lr)
348:              		ADCON1 = 0; // 左对齐,出12位
349:              	else
350:              		ADCON1 = 0x80; // 右对齐,出10位
351:              
352:              	if (ad_ch & 0x10) // 设置CHS4，此位在ADCON1寄存器中
353:              		ADCON1 |= 0x40;
354:              
355:              	ADCON0 = 0;
356:              	ad_ch &= 0x0f;
357:              	ADCON0 |= (unsigned char)(ad_fd << 6); // 不同的VDD或参考电压需要配置合理的分频
358:              	ADCON0 |= (unsigned char)(ad_ch << 2); // 设置通道
359:              	ADCON0 |= 0x01;						   // 使能ADC
360:              
361:              	asm("nop");
362:              	asm("nop");
363:              	GODONE = 1; // 开始转换
364:              
365:              	while (GODONE)
366:              	{
367:              		asm("nop");
368:              		asm("nop");
369:              		if ((--i) == 0) // ad等待限时，防止出现死循环，但要考虑转换时间不能长于此时间
370:              			return 0;
371:              	}
372:              
373:              	if (!ad_lr) // 左对齐
374:              	{
375:              		data = (unsigned int)(ADRESH << 4);
376:              		data |= (unsigned int)(ADRESL >> 4);
377:              	}
378:              	else // 右对齐
379:              	{
380:              		data = (unsigned int)(ADRESH << 8);
381:              		data |= (unsigned int)ADRESL;
382:              	}
383:              
384:              	return data;
385:              }
386:              
387:              /***********************************************
388:              函数名称：Set_Usart_Async
389:              函数功能：Usart状态设置（异步）
390:              入口参数：无
391:              出口参数：无
392:              备注：
393:              1、串口通讯，设置波特率寄存器时，应控制在19200及以下，实际应用时应考虑到芯片内振的电压及温度特性。
394:              2、SYNC = 0;目标波特率 = Fosc/(16*(SPBRG+1))
395:              ************************************************/
396:              void Set_Usart_Async()
397:              {
398:              	BRGHEN1 = 1;
399:              	BRG16EN1 = 0; //设置BRG是一个8位定时器
400:              
401:              	SPBRGH1 = 0;
402:              	SPBRG1 = 51; //设置波特率为9600 bps (8M/(16*52))
403:              
404:              //	SPBRG = 25; /* 19200bps, 8M/(16*26) */
405:              
406:              	SYNC1 = 0; // 0为异步模式，1为同步模式
407:              	SCKP1 = 0; // 直接将数据字符发送到TX/CK引脚
408:              
409:              	SPEN1 = 1;  // 允许串口操作
410:              	RC1IE = 1;  // 接收中断  //暂时关闭
411:              	TX1IE = 0;  // 发送中断
412:              	RX9EN1 = 0; // 0为8位接收，1为9位接收
413:              	TX9EN1 = 0; // 0为8位发送，1为9位发送
414:              	CREN1 = 1;  // 0为禁止接收，1为使能接收 //暂时关闭
415:              	TXEN1 = 1;  // 0为禁止发送，1为使能发送
416:              }
417:              
418:              /************************************************************
419:              函数名称：Uart_Send_NByte()
420:              函数功能：串口多字节发送函数
421:              入口参数：n 待发送字节数量
422:              		  nSendByte 待发送数组
423:              出口参数：
424:              备    注：
425:              ************************************************************/
426:              // void Uart_Send_NByte(uint8_t n, uint8_t *nSendByte)
427:              // {
428:              // 	uint8_t i;
429:              // 	for(i = 0; i < n; i++)
430:              // 	{
431:              // 		TX_Buf[i] = nSendByte[i];
432:              // 	}
433:              // 	tx_index = n;
434:              // 	TXIE = 1;
435:              // }
436:              
437:              /************************************************************
438:              函数名称：Init_PA_Isr()
439:              函数功能：PA中断初始化函数
440:              入口参数：
441:              出口参数：
442:              备    注：
443:              ************************************************************/
444:              // void Init_PA_Isr()
445:              // {
446:              // 	IOCA = 0B01100110; // 允许RA1的IO口电平变化中断
447:              // 	RACIE = 1;		   // 使能PORTA电平变化中断
448:              // 	PORTA;			   // 读取PORTA并锁存
449:              // }
450:              
451:              /************************************************************
452:              函数名称：Init_PB_Isr()
453:              函数功能：PB中断初始化函数
454:              入口参数：
455:              出口参数：
456:              备    注：
457:              ************************************************************/
458:              // void Init_PB_Isr()
459:              // {
460:              // 	IOCB = 0B00000001; // 允许RB0的IO口电平变化中断
461:              // 	RBIE = 1;		   // 使能PORTB电平变化中断
462:              // 	// INTCON = 0x88;			//允许所有未被屏蔽的中断、禁止外设中断，使能PORTB电平变化中断
463:              // 	PORTB;			   // 读取PORTB并锁存
464:              // }
465:              
466:              /************************************************************
467:              函数名称：mainr()
468:              函数功能：主循环
469:              入口参数：
470:              出口参数：
471:              备    注：
472:              ************************************************************/
473:              void main(void)
  028A    0000    NOP
  028B    0064    CLRWDT
474:              {
475:              	/******************************************************************/
476:              	asm("nop");
477:              	asm("clrwdt");
478:              	INTCON = 0;		 //禁止中断
  028C    018B    CLR	0xB
479:              
480:              	Init_GPIO();	// 初始化GPIO
  028D    120A    CLRB	0xA,4
  028E    118A    CLRB	0xA,3
  028F    233D    CALL	0x33D
481:              	Init_IC();		// 相关寄存器初始化
  0292    120A    CLRB	0xA,4
  0293    118A    CLRB	0xA,3
  0294    2350    CALL	0x350
482:              	Delay_nms(200); // 上电延时200ms 非精准延时
  0297    30C8    LDIA	0xC8
  0298    00F4    LD	0x74,A
  0299    01F5    CLR	0x75
  029A    120A    CLRB	0xA,4
  029B    118A    CLRB	0xA,3
  029C    225C    CALL	0x25C
483:              	Init_TIMER1();	// 定时器1初始化
  029F    120A    CLRB	0xA,4
  02A0    118A    CLRB	0xA,3
  02A1    236D    CALL	0x36D
484:              	Init_TIMER2();	// 定时器2初始化
  02A4    120A    CLRB	0xA,4
  02A5    118A    CLRB	0xA,3
  02A6    2362    CALL	0x362
485:              //	Init_PA_Isr();		 //PA中断初始化函数
486:              //	Init_PB_Isr();		 //PB中断初始化函数
487:              // #if FCT
488:              // 	/* FCT串口不初始化，TX、RX作为普通端口使用 */
489:              // #else
490:              // 	Set_Usart_Async(); // 串口初始化
491:              // #endif
492:              
493:              	//	Set_CCP_PWM();		 //PWM初始化
494:              
495:              	INTCON = 0XC0;	   // 允许所有未被屏蔽的中断、外设中断
  02A9    30C0    LDIA	0xC0
  02AA    008B    LD	0xB,A
496:              
497:              	// RemoFlash_Read();  /* 读取存储的数值 */
498:              	while (1)
499:              	{
500:              		/*主循环10ms*/
501:              		if (F1ms == SET)
  02AB    1CCE    SNZB	0x4E,1
  02AC    2AAB    JP	0x2AB
  02AD    0064    CLRWDT
502:              		{
503:              			CLRWDT(); /*清看门狗*/
504:              			F1ms = CLR;
  02AE    1283    CLRB	0x3,5
  02AF    1303    CLRB	0x3,6
  02B0    10CE    CLRB	0x4E,1
505:              			switch (SEQmain)
  02B1    2AD0    JP	0x2D0
506:              			{
507:              				case 0:
508:              					FCTloop();
  02B2    120A    CLRB	0xA,4
  02B3    118A    CLRB	0xA,3
  02B4    220A    CALL	0x20A
509:              					break;
  02B7    2AF0    JP	0x2F0
510:              				case 1:
511:              					if(FfctTest == CLR)
  02B8    1879    SZB	0x79,0
  02B9    2AF0    JP	0x2F0
512:              					{
513:              						GsensorLoop();
  02BA    120A    CLRB	0xA,4
  02BB    118A    CLRB	0xA,3
  02BC    201F    CALL	0x1F
  02BF    2AF0    JP	0x2F0
514:              					}
515:              					break;
516:              				case 2:
517:              
518:              					break;
519:              				case 3:
520:              
521:              					break;
522:              				case 4:
523:              					if(FfctTest == CLR)
  02C0    1879    SZB	0x79,0
  02C1    2AF0    JP	0x2F0
524:              					{
525:              						GflushLoop();
  02C2    120A    CLRB	0xA,4
  02C3    118A    CLRB	0xA,3
  02C4    2115    CALL	0x115
  02C7    2AF0    JP	0x2F0
526:              					}
527:              					break;
528:              				case 5:
529:              
530:              					break;
531:              				case 6:
532:              
533:              					break;
534:              				case 7:
535:              
536:              					break;
537:              				case 8:
538:              					if(FfctTest == CLR)
  02C8    1879    SZB	0x79,0
  02C9    2AF0    JP	0x2F0
539:              					{
540:              						GledLoop();
  02CA    120A    CLRB	0xA,4
  02CB    118A    CLRB	0xA,3
  02CC    231D    CALL	0x31D
  02CF    2AF0    JP	0x2F0
  02D0    0848    LD	A,0x48
  02D1    3A00    XORIA	0x0
  02D2    1903    SZB	0x3,2
  02D3    2AB2    JP	0x2B2
  02D4    3A01    XORIA	0x1
  02D5    1903    SZB	0x3,2
  02D6    2AB8    JP	0x2B8
  02D7    3A03    XORIA	0x3
  02D8    1903    SZB	0x3,2
  02D9    2AF0    JP	0x2F0
  02DA    3A01    XORIA	0x1
  02DB    1903    SZB	0x3,2
  02DC    2AF0    JP	0x2F0
  02DD    3A07    XORIA	0x7
  02DE    1903    SZB	0x3,2
  02DF    2AC0    JP	0x2C0
  02E0    3A01    XORIA	0x1
  02E1    1903    SZB	0x3,2
  02E2    2AF0    JP	0x2F0
  02E3    3A03    XORIA	0x3
  02E4    1903    SZB	0x3,2
  02E5    2AF0    JP	0x2F0
  02E6    3A01    XORIA	0x1
  02E7    1903    SZB	0x3,2
  02E8    2AF0    JP	0x2F0
  02E9    3A0F    XORIA	0xF
  02EA    1903    SZB	0x3,2
  02EB    2AC8    JP	0x2C8
  02EC    3A01    XORIA	0x1
  02ED    1903    SZB	0x3,2
  02EE    2AF0    JP	0x2F0
  02EF    2AF0    JP	0x2F0
541:              					}
542:              				break;
543:              				case 9:
544:              
545:              					break;
546:              				default:
547:              					// SEQmain = 0;
548:              					break;
549:              			}
550:              			if (++SEQmain >= 10)
  02F0    300A    LDIA	0xA
  02F1    1283    CLRB	0x3,5
  02F2    1303    CLRB	0x3,6
  02F3    0AC8    INCR	0x48
  02F4    0248    SUBA	0x48
  02F5    1C03    SNZB	0x3,0
  02F6    2AAB    JP	0x2AB
551:              			{
552:              				SEQmain = 0;
  02F7    01C8    CLR	0x48
  02F8    2AAB    JP	0x2AB
553:              			}
554:              		}
555:              	}
556:              }
557:              
558:              // /***********************************************************************
559:              // 函数功能：中断入口函数
560:              // RISC内核无中断优先级，不可嵌套
561:              // ***********************************************************************/
562:              void interrupt Int_ALL(void)
563:              {
564:              	// 1ms定时器中断服务函数
565:              	if (TMR1IF)
  02F9    1283    CLRB	0x3,5
  02FA    1303    CLRB	0x3,6
  02FB    1C0C    SNZB	0xC,0
  02FC    2B11    JP	0x311
566:              	{
567:              		// ---------------------------------------
568:              		// TMR1L += 0xC0;
569:              		// TMR1H += 0xF9; //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
570:              		// 在进入中断等过程中其实Time是一直在计数的
571:              		// ---------------------------------------
572:              		TMR1 = TIMER1_TIME;
  02FD    30E0    LDIA	0xE0
  02FE    008F    LD	0xF,A
  02FF    30C0    LDIA	0xC0
  0300    008E    LD	0xE,A
573:              		TMR1IF = 0; // 清中断标志位
  0301    100C    CLRB	0xC,0
574:              
575:              		/* 主循环1ms标志位 */
576:              		F1ms = 1;
  0302    14CE    SETB	0x4E,1
577:              
578:              		/* 1s标志位 */
579:              		if (++MainTime_1s >= 1000)
  0303    0AB6    INCR	0x36
  0304    1903    SZB	0x3,2
  0305    0AB7    INCR	0x37
  0306    3003    LDIA	0x3
  0307    0237    SUBA	0x37
  0308    30E8    LDIA	0xE8
  0309    1903    SZB	0x3,2
  030A    0236    SUBA	0x36
  030B    1C03    SNZB	0x3,0
  030C    2B11    JP	0x311
580:              		{
581:              			MainTime_1s = 0;
  030D    01B6    CLR	0x36
  030E    01B7    CLR	0x37
582:              			Fsys1s.byte = 0xFF; /* 1s' flag */
  030F    30FF    LDIA	0xFF
  0310    00CD    LD	0x4D,A
583:              // #if (VER_2510M || VER_2510U)
584:              // 			if (++MainTime_1min >= 60) /* 1min标识位 */
585:              // 			{
586:              // 				MainTime_1min = 0;
587:              // 				Fsys1m.byte = 0xFF; /* 1min' flag */
588:              // 			}
589:              // #endif
590:              		}
591:              	}
592:              
593:              	// 50us定时器中断服务函数
594:              	if (TMR2IF)
  0311    1C8C    SNZB	0xC,1
  0312    2B15    JP	0x315
595:              	{
596:              		TMR2IF = 0; /*	8位，自重载，无需二次配置	*/
  0313    108C    CLRB	0xC,1
597:              		INT_LED_SHOW(); /* 氛围灯中断函数 */
  0314    231C    CALL	0x31C
  0315    0871    LD	A,0x71
  0316    008A    LD	0xA,A
  0317    0E70    SWAPA	0x70
  0318    0083    LD	0x3,A
  0319    0EFE    SWAPR	0x7E
  031A    0E7E    SWAPA	0x7E
  031B    0009    RETI
598:              	}
599:              
600:              // #if FCT
601:              // 	/* FCT停止uart通讯中断服务 */
602:              // #else
603:              // 	// 串口接收中断服务函数
604:              // 	if (RC1IF)
605:              // 	{
606:              // 		//-------------------------------------------
607:              // 		// 接收控制，如果接收标志位为1，说明有数据接收完毕
608:              // 		// RCIF在寄存器被读出后自动清零
609:              // 		if (FERR1)
610:              // 		{
611:              // 			RCREG1; // 帧错误
612:              // 			return;
613:              // 		}
614:              
615:              // 		RX_Buf = RCREG1; // 将接收缓冲区内容读出
616:              
617:              // 		Uart_ReceiveLogic(); /* UART*/
618:              
619:              // 		if (OERR1) // 如果有溢出错误
620:              // 		{
621:              // 			CREN1 = 0; // 清零CREN1位可将OERR位清零
622:              // 			CREN1 = 1; // 再次将CREN1置一，以允许继续接收
623:              // 		}
624:              // 	}
625:              
626:              // 	// 串口发送中断服务函数
627:              // 	if (TX1IF && TX1IE)
628:              // 	{
629:              // 		// 发送控制
630:              // 		if (TRMT1)
631:              // 		{
632:              // 			Uart_SendLogic();
633:              // 			// TXREG = TX_Buf[tx_cnt];
634:              // 			// tx_cnt++;
635:              // 			// if(tx_cnt >= tx_index)
636:              // 			// {
637:              // 			// 	tx_cnt = 0;
638:              // 			// 	TXIE = 0;
639:              // 			// }
640:              // 		}
641:              // 	}
642:              // #endif
643:              	// PA中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
644:              	// if(RACIF)
645:              	// {
646:              	// 	PORTA;		 //读取PORTA状态
647:              	// 	RACIF = 0; //清中断标志
648:              	// }
649:              
650:              	// PB中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
651:              	// if(RBIF)
652:              	// {
653:              	// 	PORTB;		//读取PORTB状态
654:              	// 	RBIF = 0; //清中断标志
655:              	// }
656:              }
---- C:\Users\汪强升\Desktop\3\ABM007_FM3(1)\ABM007_FM3\ABM007_FM3\source\sensor.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fbodysensor;
5:                
6:                v_uint8 u8stsBodySensor = 0;
7:                v_uint8 SEQbody = 0;
8:                v_uint16 CNTbody_h = 0;         /* 感应高电平计时 */
9:                v_uint16 CNTbody_l = 0;         /* 感应低电平计时 */
10:               v_uint16 BufCntAdd = 0;         /* 感应计时 */
11:               v_uint16 CNTbodyInTime = 0;     /* 感应到人计时 */
12:               v_uint16 CNTbodyExitTime = 0;   /* 感应到人离开计时 */
13:               
14:               void SensorKey(void);
15:               void SensorTime(void);
16:               void SensorJudge(void);
17:               void SensorControl(void);
18:               
19:               void GsensorLoop(void)
20:               {
21:                   SensorKey();
  001F    2029    CALL	0x29
  0020    120A    CLRB	0xA,4
  0021    118A    CLRB	0xA,3
22:                   SensorTime();
  0022    202A    CALL	0x2A
  0023    120A    CLRB	0xA,4
  0024    118A    CLRB	0xA,3
23:                   SensorJudge();
  0025    207D    CALL	0x7D
  0026    120A    CLRB	0xA,4
  0027    118A    CLRB	0xA,3
24:                   SensorControl();
  0028    2862    JP	0x62
25:               }
26:               
27:               void SensorKey(void)
  0029    0008    RET
28:               {
29:               
30:               }
31:               
32:               /* 人体感应计时函数 */
33:               void SensorTime(void)
34:               {
35:                   if(Fbody == SET)
  002A    1C7A    SNZB	0x7A,0
  002B    284E    JP	0x4E
36:                   {
37:                       FbodyEx5s = CLR;
  002C    12FA    CLRB	0x7A,5
38:                       CNTbodyExitTime = 0;
  002D    01AA    CLR	0x2A
  002E    01AB    CLR	0x2B
39:                       if(FlightLeave == CLR)  /* 检测到人有效时间 */
  002F    194B    SZB	0x4B,2
  0030    2849    JP	0x49
40:                       {
41:                           if(++CNTbodyInTime >= BODY_ENTER_KEEP_60S)	/* 60s */
  0031    0AAC    INCR	0x2C
  0032    1903    SZB	0x3,2
  0033    0AAD    INCR	0x2D
  0034    3017    LDIA	0x17
  0035    022D    SUBA	0x2D
  0036    3070    LDIA	0x70
  0037    1903    SZB	0x3,2
  0038    022C    SUBA	0x2C
  0039    1C03    SNZB	0x3,0
  003A    2841    JP	0x41
42:                           {
43:                               CNTbodyInTime = BODY_ENTER_KEEP_60S;
  003B    3070    LDIA	0x70
  003C    00AC    LD	0x2C,A
  003D    3017    LDIA	0x17
  003E    00AD    LD	0x2D,A
44:                               FbodyIn60s = SET;
  003F    15FA    SETB	0x7A,3
45:                           }
  0040    0008    RET
46:                           else if(CNTbodyInTime >= BODY_ENTER_KEEP_5S)		/* 5s */
  0041    3001    LDIA	0x1
  0042    022D    SUBA	0x2D
  0043    30F4    LDIA	0xF4
  0044    1903    SZB	0x3,2
  0045    022C    SUBA	0x2C
  0046    1803    SZB	0x3,0
47:                           {
48:                               FbodyIn5s = SET;
  0047    167A    SETB	0x7A,4
  0048    0008    RET
49:                           }
50:                       }
51:                       else
52:                       {
53:                           if(FbodyIn5s == CLR)    /* 未待满5s，时间清零 */
  0049    1A7A    SZB	0x7A,4
  004A    0008    RET
54:                           {
55:                               CNTbodyInTime = 0;
  004B    01AC    CLR	0x2C
  004C    01AD    CLR	0x2D
56:                           }
57:                       }
58:                   }
  004D    0008    RET
59:                   else
60:                   {
61:                       CNTbodyInTime = 0;
  004E    01AC    CLR	0x2C
  004F    01AD    CLR	0x2D
62:                       FbodyIn5s = CLR;
  0050    127A    CLRB	0x7A,4
63:                       FbodyIn60s = CLR;
  0051    11FA    CLRB	0x7A,3
64:                       if(++CNTbodyExitTime >= BODY_EXIT_KEEP_5S)
  0052    0AAA    INCR	0x2A
  0053    1903    SZB	0x3,2
  0054    0AAB    INCR	0x2B
  0055    3001    LDIA	0x1
  0056    022B    SUBA	0x2B
  0057    30F4    LDIA	0xF4
  0058    1903    SZB	0x3,2
  0059    022A    SUBA	0x2A
  005A    1C03    SNZB	0x3,0
  005B    0008    RET
65:                       {
66:                           CNTbodyExitTime = BODY_EXIT_KEEP_5S;
  005C    30F4    LDIA	0xF4
  005D    00AA    LD	0x2A,A
  005E    3001    LDIA	0x1
  005F    00AB    LD	0x2B,A
67:                           FbodyEx5s = SET;        /* 人离开5秒 */
  0060    16FA    SETB	0x7A,5
  0061    0008    RET
68:                       }
69:                   }
70:               }
71:               
72:               /* 人体感应判定函数 */
73:               void SensorJudge(void)
74:               {
75:                   switch (SEQbody)
  007D    28FA    JP	0xFA
76:                   {
77:                       case 0:
78:                           Fbody = CLR;
  007E    107A    CLRB	0x7A,0
79:                           FlightLeave = CLR;
  007F    114B    CLRB	0x4B,2
80:                           SEQbody = 1;
  008F    3001    LDIA	0x1
  0090    00C4    LD	0x44,A
81:                           break;
  0091    0008    RET
82:               
83:                       /* 人离开确认 */
84:                       case 1:
85:                           Fbody = CLR;
  0092    107A    CLRB	0x7A,0
86:                           FlightLeave = CLR;
  0093    114B    CLRB	0x4B,2
87:                           if(PIsensor == LOW)
  0094    1886    SZB	0x6,1
  0095    28A7    JP	0xA7
88:                           {
89:                               if(++CNTbody_h >= SENSOR_TRG)
  0096    0AB2    INCR	0x32
  0097    1903    SZB	0x3,2
  0098    0AB3    INCR	0x33
  0099    3000    LDIA	0x0
  009A    0233    SUBA	0x33
  009B    3003    LDIA	0x3
  009C    1903    SZB	0x3,2
  009D    0232    SUBA	0x32
  009E    1C03    SNZB	0x3,0
  009F    0008    RET
90:                               {
91:                                   CNTbody_h = 0;
  00A0    01B2    CLR	0x32
  00A1    01B3    CLR	0x33
92:               					CNTbody_l = 0;
  00A2    01B0    CLR	0x30
  00A3    01B1    CLR	0x31
93:               					SEQbody = 2;
  00A4    3002    LDIA	0x2
  00A5    00C4    LD	0x44,A
94:               					break;
  00A6    0008    RET
95:                               }
96:                           }
97:                           else
98:                           {
99:                               CNTbody_h = 0;
  00A7    01B2    CLR	0x32
  00A8    01B3    CLR	0x33
  00A9    0008    RET
100:                          }
101:                          break;
102:              
103:                      /* 感应到人判定开始 */
104:                      case 2:
105:                          Fbody = CLR;
  00AA    107A    CLRB	0x7A,0
106:                          FlightLeave = CLR;
  00AB    114B    CLRB	0x4B,2
107:                          if(PIsensor == LOW)
  00AC    1886    SZB	0x6,1
  00AD    2881    JP	0x81
108:                          {
109:                              ++CNTbody_h;
  00AE    0AB2    INCR	0x32
  00AF    1903    SZB	0x3,2
  00B0    0AB3    INCR	0x33
110:                          }
  0080    288F    JP	0x8F
111:                          else
112:                          {
113:                              if(++CNTbody_l >= SENSOR_ERROR)
  0081    0AB0    INCR	0x30
  0082    1903    SZB	0x3,2
  0083    0AB1    INCR	0x31
  0084    3000    LDIA	0x0
  0085    0231    SUBA	0x31
  0086    3006    LDIA	0x6
  0087    1903    SZB	0x3,2
  0088    0230    SUBA	0x30
  0089    1C03    SNZB	0x3,0
  008A    28B1    JP	0xB1
114:                              {
115:                                  CNTbody_h = 0;
  008B    01B2    CLR	0x32
  008C    01B3    CLR	0x33
116:                                  CNTbody_l = 0;
  008D    01B0    CLR	0x30
  008E    01B1    CLR	0x31
117:                                  SEQbody = 1;
118:                                  break;
119:                              }
120:                          }
121:                          BufCntAdd = CNTbody_h +CNTbody_l;
  00B1    210C    CALL	0x10C
  00B2    120A    CLRB	0xA,4
  00B3    118A    CLRB	0xA,3
122:                          if(BufCntAdd >= SENSOR_BODY_ENTER_X_0S)
  00B4    3000    LDIA	0x0
  00B5    022F    SUBA	0x2F
  00B6    301E    LDIA	0x1E
  00B7    1903    SZB	0x3,2
  00B8    022E    SUBA	0x2E
  00B9    1C03    SNZB	0x3,0
  00BA    0008    RET
123:                          {
124:                              SEQbody = 3;
  00BB    3003    LDIA	0x3
  00BC    00C4    LD	0x44,A
125:                              break;
  00BD    0008    RET
126:                          }
127:                          break;
128:                      /* 感应到人确认 */
129:                      case 3:
130:                          Fbody = SET;
  00BE    147A    SETB	0x7A,0
131:                          FlightLeave = CLR;
  00BF    114B    CLRB	0x4B,2
132:                          if(PIsensor == HIGH)
  00C0    1C86    SNZB	0x6,1
  00C1    28D3    JP	0xD3
133:                          {
134:                              if(++CNTbody_l >= SENSOR_TRG)
  00C2    0AB0    INCR	0x30
  00C3    1903    SZB	0x3,2
  00C4    0AB1    INCR	0x31
  00C5    3000    LDIA	0x0
  00C6    0231    SUBA	0x31
  00C7    3003    LDIA	0x3
  00C8    1903    SZB	0x3,2
  00C9    0230    SUBA	0x30
  00CA    1C03    SNZB	0x3,0
  00CB    0008    RET
135:                              {
136:                                  CNTbody_h = 0;
  00CC    01B2    CLR	0x32
  00CD    01B3    CLR	0x33
137:                                  CNTbody_l = 0;
  00CE    01B0    CLR	0x30
  00CF    01B1    CLR	0x31
138:                                  SEQbody = 4;
  00D0    3004    LDIA	0x4
  00D1    00C4    LD	0x44,A
139:                                  break;
  00D2    0008    RET
140:                              }
141:                          }
142:                          else
143:                          {
144:                              CNTbody_l = 0;
  00D3    01B0    CLR	0x30
  00D4    01B1    CLR	0x31
  00D5    0008    RET
145:                          }
146:                          break;
147:                      /* 人离开判定开始 */
148:                      case 4:
149:                          Fbody = SET;
  00D6    147A    SETB	0x7A,0
150:                          FlightLeave = SET;
  00D7    154B    SETB	0x4B,2
151:                          if(PIsensor == LOW)
  00D8    1886    SZB	0x6,1
  00D9    28E9    JP	0xE9
152:                          {
153:                              if(++CNTbody_h >= SENSOR_ERROR)
  00DA    0AB2    INCR	0x32
  00DB    1903    SZB	0x3,2
  00DC    0AB3    INCR	0x33
  00DD    3000    LDIA	0x0
  00DE    0233    SUBA	0x33
  00DF    3006    LDIA	0x6
  00E0    1903    SZB	0x3,2
  00E1    0232    SUBA	0x32
  00E2    1C03    SNZB	0x3,0
  00E3    28EC    JP	0xEC
154:                              {
155:                                  CNTbody_h = 0;
  00E4    01B2    CLR	0x32
  00E5    01B3    CLR	0x33
156:                                  CNTbody_l = 0;
  00E6    01B0    CLR	0x30
  00E7    01B1    CLR	0x31
  00E8    28BB    JP	0xBB
157:                                  SEQbody = 3;
158:                                  break;
159:                              }
160:                          }
161:                          else
162:                          {
163:                              ++CNTbody_l;
  00E9    0AB0    INCR	0x30
  00EA    1903    SZB	0x3,2
  00EB    0AB1    INCR	0x31
164:                          }
165:                          BufCntAdd = CNTbody_h +CNTbody_l;
  00EC    210C    CALL	0x10C
  00ED    120A    CLRB	0xA,4
  00EE    118A    CLRB	0xA,3
166:                          if(BufCntAdd >= SENSOR_BODY_EXIT_X_0S)      /* 暂改为5s */
  00EF    3001    LDIA	0x1
  00F0    022F    SUBA	0x2F
  00F1    30F4    LDIA	0xF4
  00F2    1903    SZB	0x3,2
  00F3    022E    SUBA	0x2E
  00F4    1C03    SNZB	0x3,0
  00F5    0008    RET
  00F6    288F    JP	0x8F
167:                          {
168:                              SEQbody = 1;
169:                              break;
170:                          }
171:                          break;
172:                      default:
173:                          SEQbody = 0;
  00F7    01C4    CLR	0x44
174:                          FlightLeave = CLR;
  00F8    114B    CLRB	0x4B,2
175:                          break;
  00F9    0008    RET
  00FA    0844    LD	A,0x44
  00FB    3A00    XORIA	0x0
  00FC    1903    SZB	0x3,2
  00FD    287E    JP	0x7E
  00FE    3A01    XORIA	0x1
  00FF    1903    SZB	0x3,2
  0100    2892    JP	0x92
  0101    3A03    XORIA	0x3
  0102    1903    SZB	0x3,2
  0103    28AA    JP	0xAA
  0104    3A01    XORIA	0x1
  0105    1903    SZB	0x3,2
  0106    28BE    JP	0xBE
  0107    3A07    XORIA	0x7
  0108    1903    SZB	0x3,2
  0109    28D6    JP	0xD6
  010A    28F7    JP	0xF7
  010B    0008    RET
176:                  }
177:              }
178:              
179:              void SensorControl(void)
180:              {
181:                  FbodyEnter = CLR;
  0062    10FA    CLRB	0x7A,1
182:                  FbodyExit = CLR;
  0063    117A    CLRB	0x7A,2
183:                  if(Fbufbody != Fbody)
  0064    1C7A    SNZB	0x7A,0
  0065    2868    JP	0x68
  0066    3001    LDIA	0x1
  0067    2869    JP	0x69
  0068    3000    LDIA	0x0
  0069    00F2    LD	0x72,A
  006A    1F7A    SNZB	0x7A,6
  006B    286E    JP	0x6E
  006C    3001    LDIA	0x1
  006D    286F    JP	0x6F
  006E    3000    LDIA	0x0
  006F    0672    XORA	0x72
  0070    1903    SZB	0x3,2
  0071    0008    RET
184:                  {
185:                      if(Fbody == SET)
  0072    1C7A    SNZB	0x7A,0
  0073    2876    JP	0x76
186:                      {
187:                          FbodyEnter = SET;   /* 感应到人瞬间 */
  0074    14FA    SETB	0x7A,1
188:                      }
  0075    2877    JP	0x77
189:                      else
190:                      {
191:                          FbodyExit = SET;    /* 人离开瞬间 */
  0076    157A    SETB	0x7A,2
192:                      }
193:                      Fbufbody = Fbody;
  0077    1C7A    SNZB	0x7A,0
  0078    287B    JP	0x7B
  0079    177A    SETB	0x7A,6
  007A    0008    RET
  007B    137A    CLRB	0x7A,6
  007C    0008    RET
194:                  }
195:              }
196:              
---- C:\Users\汪强升\Desktop\3\ABM007_FM3(1)\ABM007_FM3\ABM007_FM3\source\light.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE FledBits01;
5:                
6:                v_uint16 CNTbreath_Led;
7:                v_uint16 CNTbreath_Led1;
8:                v_uint16 CNTbreath_Led2;
9:                v_uint16 CNTbreath_Led3;
10:               
11:               void LED_Key(void);
12:               void LED_Judge(void);
13:               void LED_Con(void);
14:               void LED_Time(void);
15:               
16:               void GledLoop(void)
17:               {
18:               	LED_Time();
  031D    2328    CALL	0x328
  031E    120A    CLRB	0xA,4
  031F    118A    CLRB	0xA,3
19:               	LED_Key();
  0320    2327    CALL	0x327
  0321    120A    CLRB	0xA,4
  0322    118A    CLRB	0xA,3
20:               	LED_Judge();
  0323    2335    CALL	0x335
  0324    120A    CLRB	0xA,4
  0325    118A    CLRB	0xA,3
21:               	LED_Con();
  0326    2B2B    JP	0x32B
22:               }
23:               
24:               void LED_Key(void)
  0327    0008    RET
25:               {
26:               	// switch(SiCon_SETkey)
27:               	// {	
28:               	// 	case KEY_LIGHT:
29:               	// 		Flight = ~Flight;
30:               	// 		if(Flight == SET)
31:               	// 		{
32:               	// 			GbuzOutSet(2);
33:               	// 		}
34:               	// 		else
35:               	// 		{
36:               	// 			GbuzOutSet(1);
37:               	// 		}
38:               	// 		break;
39:               	// 	default:
40:               			
41:               	// 		break;
42:               	// }
43:               }
44:               
45:               void LED_Time(void)
46:               {
47:               	if(F1min_lgt == SET)
  0328    184C    SZB	0x4C,0
48:               	{
49:               		F1min_lgt = CLR;
  0329    104C    CLRB	0x4C,0
  032A    0008    RET
50:               	}
51:               }
52:               
53:               void LED_Judge(void)
54:               {
55:               	if(Fbody == SET)	/* 感应到人开启 */
  0335    1C7A    SNZB	0x7A,0
  0336    2B3B    JP	0x33B
56:               	{
57:               		Flight = SET;
  0337    144B    SETB	0x4B,0
58:               		if(FbodyIn5s == CLR)	/* 检测到人5秒之内 */
  0338    1E7A    SNZB	0x7A,4
59:               		{
60:               			if(FlightLeave == SET)	/* 离开状态，熄灭指示灯 */
  0339    1D4B    SNZB	0x4B,2
  033A    0008    RET
61:               			{
62:               				Flight = CLR;
  033B    104B    CLRB	0x4B,0
  033C    0008    RET
63:               			}
64:               		}
65:               	}
66:               	else
67:               	{
68:               		// if(Fbuflight == SET)
69:               		// {
70:               		// 	Flight = SET;	/* 离开5s内 */
71:               		// 	if(FbodyEx5s == SET)
72:               		// 	{
73:               		// 		Flight = CLR;
74:               		// 		Fbuflight = CLR;
75:               		// 	}
76:               		// }
77:               		// else
78:               		// {
79:               			Flight = CLR;
80:               		// }
81:               	}
82:               }
83:               
84:               void LED_Con(void)
85:               {
86:               	POlight	= Flight;
  032B    1C4B    SNZB	0x4B,0
  032C    2B31    JP	0x331
  032D    1283    CLRB	0x3,5
  032E    1303    CLRB	0x3,6
  032F    1685    SETB	0x5,5
  0330    0008    RET
  0331    1283    CLRB	0x3,5
  0332    1303    CLRB	0x3,6
  0333    1285    CLRB	0x5,5
  0334    0008    RET
87:               	/* 呼吸灯频率 */
88:               	// if (Flight == SET)
89:               	// {
90:               	// 	if (FbreathDir == CLR)
91:               	// 	{
92:               	// 		if (CNTbreath_Led2 >= 80)	/* 亮度降低 */
93:               	// 		{
94:               	// 			CNTbreath_Led2 = 80;
95:               	// 			if (++CNTbreath_Led3 > 10)	/* 100ms，min */
96:               	// 			{
97:               	// 				FbreathDir = SET;
98:               	// 				CNTbreath_Led3 = 0;
99:               	// 			}
100:              	// 		}
101:              	// 		else if (CNTbreath_Led2 > 45)	/* 35*4*10=1050ms */
102:              	// 		{
103:              	// 			if (++CNTbreath_Led1 >= 3)
104:              	// 			{
105:              	// 				CNTbreath_Led1 = 0;
106:              	// 				CNTbreath_Led2++;
107:              	// 			}
108:              	// 		}
109:              	// 		else if (CNTbreath_Led2 > 30)	/* 15*8*10 = 1200ms */
110:              	// 		{
111:              	// 			if (++CNTbreath_Led1 >= 8)
112:              	// 			{
113:              	// 				CNTbreath_Led1 = 0;
114:              	// 				CNTbreath_Led2++;
115:              	// 			}
116:              	// 		}
117:              	// 		else if (CNTbreath_Led2 > 10)	/* 1000ms */
118:              	// 		{
119:              	// 			if (++CNTbreath_Led1 >= 5)
120:              	// 			{
121:              	// 				CNTbreath_Led1 = 0;
122:              	// 				CNTbreath_Led2++;
123:              	// 			}
124:              	// 		}
125:              	// 		else
126:              	// 		{
127:              	// 			if (++CNTbreath_Led1 >= 11)	/* (11-5)*10=600ms，max */
128:              	// 			{
129:              	// 				CNTbreath_Led1 = 0;
130:              	// 				CNTbreath_Led2++;
131:              	// 			}
132:              	// 		}
133:              	// 	}
134:              	// 	else
135:              	// 	{
136:              	// 		if (CNTbreath_Led2 < 5)	/* max */
137:              	// 		{
138:              	// 			CNTbreath_Led2 = 5;
139:              	// 			FbreathDir = CLR;
140:              	// 		}
141:              	// 		else if (CNTbreath_Led2 < 10)
142:              	// 		{
143:              	// 			if (++CNTbreath_Led1 >= 6)	/* 600ms */
144:              	// 			{
145:              	// 				CNTbreath_Led1 = 0;
146:              	// 				CNTbreath_Led2--;
147:              	// 			}
148:              	// 		}
149:              	// 		else if (CNTbreath_Led2 < 30)
150:              	// 		{
151:              	// 			if (++CNTbreath_Led1 >= 6)	/* 1200ms */
152:              	// 			{
153:              	// 				CNTbreath_Led1 = 0;
154:              	// 				CNTbreath_Led2--;
155:              	// 			}
156:              	// 		}
157:              	// 		else if (CNTbreath_Led2 < 40)
158:              	// 		{
159:              	// 			if (++CNTbreath_Led1 >= 8)	/* 800ms */
160:              	// 			{
161:              	// 				CNTbreath_Led1 = 0;
162:              	// 				CNTbreath_Led2--;
163:              	// 			}
164:              	// 		}
165:              	// 		else if (CNTbreath_Led2 < 60)
166:              	// 		{
167:              	// 			if (++CNTbreath_Led1 >= 4)	/* 800ms */
168:              	// 			{
169:              	// 				CNTbreath_Led1 = 0;
170:              	// 				CNTbreath_Led2--;
171:              	// 			}
172:              	// 		}
173:              	// 		else
174:              	// 		{
175:              	// 			if (++CNTbreath_Led1 >= 3)	/* 600ms，min */
176:              	// 			{
177:              	// 				CNTbreath_Led1 = 0;
178:              	// 				CNTbreath_Led2--;
179:              	// 			}
180:              	// 		}
181:              	// 	}
182:              	// }
183:              	// else
184:              	// {
185:              	// 	CNTbreath_Led1 = 0;
186:              	// 	CNTbreath_Led2 = 0;
187:              	// 	CNTbreath_Led3 = 0;
188:              	// 	FbreathDir = CLR;
189:              	// 	POlight = OFF;
190:              	// }
191:              }
192:              
193:              void INT_LED_SHOW(void)
  031C    0008    RET
194:              {
195:              	// if((Flight == SET) && (FfctTest == CLR))
196:              	// {
197:              	// 	if (++CNTbreath_Led == 80)
198:              	// 	{
199:              	// 		CNTbreath_Led = 0;
200:              	// 		POlight = OFF;
201:              	// 	}
202:              	// 	if (CNTbreath_Led >= CNTbreath_Led2)
203:              	// 	{
204:              	// 		POlight = ON;
205:              	// 	}
206:              	// 	else
207:              	// 	{
208:              	// 		POlight = OFF;
209:              	// 	}
210:              	// }
211:              }
---- C:\Users\汪强升\Desktop\3\ABM007_FM3(1)\ABM007_FM3\ABM007_FM3\source\flush.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fflush1;
5:                
6:                
7:                
8:                v_uint8 SEQflsuh = 0;
9:                v_uint16 CNTflush = 0;  /* 冲水计时 */
10:               
11:               void FlushTime(void);
12:               void FlushJudge(void);
13:               void FlushCon(void);
14:               
15:               void GflushLoop(void)
16:               {
17:                   FlushTime();
  0115    211C    CALL	0x11C
  0116    120A    CLRB	0xA,4
  0117    118A    CLRB	0xA,3
18:                   FlushJudge();
  0118    21DD    CALL	0x1DD
  0119    120A    CLRB	0xA,4
  011A    118A    CLRB	0xA,3
19:                   FlushCon();
  011B    291D    JP	0x11D
20:               }
21:               
22:               void FlushTime(void)
  011C    0008    RET
23:               {
24:               
25:               }
26:               void FlushJudge(void)
27:               {
28:                   /* 请求判定 */
29:               #if DUBLE_FLUSH_MODE
30:                   if(FbodyIn60s == SET)   /* 感应到60秒以上，大冲请求置位 */
31:                   {
32:                       YKfls_Big = SET;
33:                       YKfls_Sml = CLR;
34:                   }
35:                   else if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
36:                   {
37:                       YKfls_Sml = SET;
38:                       YKfls_Big = CLR;
39:                   }
40:                   else
41:                   {
42:                       YKfls_Sml = CLR;
43:                       YKfls_Big = CLR;
44:                   }
45:               #else
46:                   if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
  01DD    1E7A    SNZB	0x7A,4
  01DE    29E2    JP	0x1E2
47:                   {
48:                       // YKfls_Sml = SET;
49:                       // YKfls_Big = CLR;
50:                       YKfls_Sml = CLR;
  01DF    1178    CLRB	0x78,2
51:                       YKfls_Big = SET;
  01E0    1478    SETB	0x78,0
52:                   }
  01E1    29E4    JP	0x1E4
53:                   else
54:                   {
55:                       YKfls_Sml = CLR;
  01E2    1178    CLRB	0x78,2
56:                       YKfls_Big = CLR;
  01E3    1078    CLRB	0x78,0
57:                   }
58:               #endif
59:                   /*********************************************/
60:               	/*	自动冲水判断	*/
61:               	if (FbodyExit == SET)	/* 离开冲水 */
  01E4    197A    SZB	0x7A,2
62:               	{
63:                       Flush_AutoLeaveWait = SET;
  01E5    17F8    SETB	0x78,7
64:               	}
65:               	if (Flush_AutoLeaveWait == SET) /*	离开自动冲水	*/
  01E6    1FF8    SNZB	0x78,7
  01E7    0008    RET
66:               	{
67:               		if (f_STSflush == SET)
  01E8    1F78    SNZB	0x78,6
  01E9    29ED    JP	0x1ED
68:               		{
69:                           YKfls_Sml = CLR;
  01EA    1178    CLRB	0x78,2
70:                           YKfls_Big = CLR;    /* 正在冲水，请求清除 */
  01EB    1078    CLRB	0x78,0
71:               			return;
  01EC    0008    RET
72:               		}
73:               		Flush_AutoLeaveWait = CLR;
  01ED    13F8    CLRB	0x78,7
74:                       if(YKfls_Big == SET)
  01EE    1C78    SNZB	0x78,0
  01EF    29F3    JP	0x1F3
75:                       {
76:                           YKfls_Big = CLR;
  01F0    1078    CLRB	0x78,0
77:                           OKfls_Big = SET;
  01F1    14F8    SETB	0x78,1
78:                           return;
  01F2    0008    RET
79:                       }
80:               		if(YKfls_Sml == SET)
  01F3    1D78    SNZB	0x78,2
  01F4    0008    RET
81:                       {
82:                           YKfls_Sml = CLR;
  01F5    1178    CLRB	0x78,2
83:                           OKfls_Sml = SET;
  01F6    15F8    SETB	0x78,3
  01F7    0008    RET
84:                       }
85:               		return;
86:               	}
87:               	/*	自动冲水判断	*/
88:               	/******************************************/
89:               }
90:               
91:               /* 主阀气泵控制函数 */
92:               void FlushCon(void)
93:               {
94:                   switch (SEQflsuh)
  011D    29B9    JP	0x1B9
95:                   {
96:                       case FLUSH_INIT_0:
97:                           f_STSflush = CLR;
  011E    1378    CLRB	0x78,6
98:                           POairPump = OFF;
  011F    1105    CLRB	0x5,2
99:                           POmainValue = OFF;
  0120    1205    CLRB	0x5,4
100:                          if((OKfls_Big == SET) || (OKfls_Sml == SET))
  0121    18F8    SZB	0x78,1
  0122    2925    JP	0x125
  0123    1DF8    SNZB	0x78,3
  0124    0008    RET
101:                          {
102:                              SEQflsuh = FLUSH_INIT_1;
  0125    3001    LDIA	0x1
  0126    2928    JP	0x128
103:                              CNTflush = 0;
  0129    01F6    CLR	0x76
  012A    01F7    CLR	0x77
  012B    0008    RET
104:                          }
105:                          break;
106:                      case FLUSH_INIT_1:
107:                          f_STSflush = SET;
  012C    1778    SETB	0x78,6
108:                          POairPump = OFF;
  012D    1105    CLRB	0x5,2
109:                          POmainValue = OFF;
  012E    1205    CLRB	0x5,4
110:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  012F    187A    SZB	0x7A,0
  0130    2927    JP	0x127
111:                          {
112:                              SEQflsuh = FLUSH_END_0;
  0127    3009    LDIA	0x9
  0128    00C6    LD	0x46,A
113:                              CNTflush = 0;
114:                              break;
115:                          }
116:                          if(++CNTflush >= 5)
  0131    0AF6    INCR	0x76
  0132    1903    SZB	0x3,2
  0133    0AF7    INCR	0x77
  0134    3000    LDIA	0x0
  0135    0277    SUBA	0x77
  0136    3005    LDIA	0x5
  0137    1903    SZB	0x3,2
  0138    0276    SUBA	0x76
  0139    1C03    SNZB	0x3,0
  013A    0008    RET
117:                          {
118:                              CNTflush = 0;
  013B    01F6    CLR	0x76
  013C    01F7    CLR	0x77
119:                              SEQflsuh = FLUSH_INIT_2;
  013D    3002    LDIA	0x2
  013E    00C6    LD	0x46,A
  013F    0008    RET
120:                          }
121:                          break;
122:                      case FLUSH_INIT_2:
123:                          f_STSflush = SET;
  0140    1778    SETB	0x78,6
124:                          POairPump = OFF;        /* 冲水关闭 */
  0141    1105    CLRB	0x5,2
125:                          POmainValue = OFF;      /* 冲水通道1 */
  0142    1205    CLRB	0x5,4
126:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  0143    187A    SZB	0x7A,0
  0144    2927    JP	0x127
127:                          {
128:                              SEQflsuh = FLUSH_END_0;
129:                              CNTflush = 0;
130:                              break;
131:                          }
132:              
133:                          if(OKfls_Big == SET)
  0145    1CF8    SNZB	0x78,1
  0146    294A    JP	0x14A
134:                          {
135:                              SEQflsuh = FLUSH_BIG_0;
  0147    3003    LDIA	0x3
  0148    00C6    LD	0x46,A
136:                          }
  0149    0008    RET
137:                          else if(OKfls_Sml == SET)
  014A    1DF8    SNZB	0x78,3
  014B    0008    RET
138:                          {
139:                              SEQflsuh = FLUSH_SML_0;
  014C    3006    LDIA	0x6
  014D    00C6    LD	0x46,A
  014E    0008    RET
140:                          }
141:                          break;
142:                      case FLUSH_BIG_0:   /* 大冲阶段 */
143:                          f_STSflush = SET;
144:                          POairPump = OFF;        /* 大冲先开电磁阀换大冲，后开气泵冲水 */
145:                          POmainValue = ON;       /* 切换通道2 */     /* 冲水通道2 */
146:                          if(++CNTflush >= 10)    /* 延迟100ms后打开气泵冲水 */
  014F    2201    CALL	0x201
  0150    120A    CLRB	0xA,4
  0151    118A    CLRB	0xA,3
  0152    1903    SZB	0x3,2
  0153    0276    SUBA	0x76
  0154    1C03    SNZB	0x3,0
  0155    0008    RET
147:                          {
148:                              CNTflush = 0;
  0156    01F6    CLR	0x76
  0157    01F7    CLR	0x77
149:                              SEQflsuh = FLUSH_BIG_1;
  0158    3004    LDIA	0x4
  0159    00C6    LD	0x46,A
  015A    0008    RET
150:                          }
151:                          break;
152:                      case FLUSH_BIG_1:
153:                          f_STSflush = SET;
  015B    1778    SETB	0x78,6
154:                          POairPump = ON;
  015C    1505    SETB	0x5,2
155:                          POmainValue = ON;
  015D    1605    SETB	0x5,4
156:              #if ABM007_FLUSH_2
157:                          if(++CNTflush >= 100)   /* 冲水1s */
  015E    0AF6    INCR	0x76
  015F    1903    SZB	0x3,2
  0160    0AF7    INCR	0x77
  0161    3000    LDIA	0x0
  0162    0277    SUBA	0x77
  0163    3064    LDIA	0x64
  0164    1903    SZB	0x3,2
  0165    0276    SUBA	0x76
  0166    1C03    SNZB	0x3,0
  0167    0008    RET
158:                          {
159:                              CNTflush = 0;
  0168    01F6    CLR	0x76
  0169    01F7    CLR	0x77
160:                              SEQflsuh = FLUSH_BIG_2;
  016A    3005    LDIA	0x5
  016B    00C6    LD	0x46,A
  016C    0008    RET
161:                          }
162:              #else
163:                          if(++CNTflush >= 200)   /* 冲水2s */
164:                          {
165:                              CNTflush = 0;
166:                              SEQflsuh = FLUSH_BIG_2;
167:                          }
168:              #endif
169:                          break;
170:                      case FLUSH_BIG_2:
171:                          f_STSflush = SET;
172:                          POairPump = OFF;        /* 关气泵，停止冲水 */
173:                          POmainValue = SET;      /* 大冲先关气泵停止冲水，后关主阀 */    /* 冲水通道2 */
174:                          if(++CNTflush >= 10)
  016D    2201    CALL	0x201
  016E    120A    CLRB	0xA,4
  016F    118A    CLRB	0xA,3
  0170    1903    SZB	0x3,2
  0171    0276    SUBA	0x76
  0172    1C03    SNZB	0x3,0
  0173    0008    RET
175:                          {
176:                              CNTflush = 0;
  0174    01F6    CLR	0x76
  0175    01F7    CLR	0x77
177:                              SEQflsuh = FLUSH_END_0;
  0176    3009    LDIA	0x9
  0177    00C6    LD	0x46,A
  0178    0008    RET
178:                          }
179:                          break;
180:              
181:                      case FLUSH_SML_0:           /* 小冲阶段 */
182:                          f_STSflush = SET;
183:                          POairPump = OFF;        /* 小冲关闭电磁阀 */
184:                          POmainValue = OFF;      /* 冲水通道1 */
185:                          if(++CNTflush >= 5)
  0179    21F8    CALL	0x1F8
  017A    120A    CLRB	0xA,4
  017B    118A    CLRB	0xA,3
  017C    1903    SZB	0x3,2
  017D    0276    SUBA	0x76
  017E    1C03    SNZB	0x3,0
  017F    0008    RET
186:                          {
187:                              CNTflush = 0;
  0180    01F6    CLR	0x76
  0181    01F7    CLR	0x77
188:                              SEQflsuh = FLUSH_SML_1;
  0182    3007    LDIA	0x7
  0183    00C6    LD	0x46,A
  0184    0008    RET
189:                          }
190:                          break;
191:                      case FLUSH_SML_1:
192:                          f_STSflush = SET;
  0185    1778    SETB	0x78,6
193:                          POairPump = ON;         /* 冲水 */
  0186    1505    SETB	0x5,2
194:                          POmainValue = OFF;      /* 冲水通道1 */
  0187    1205    CLRB	0x5,4
195:                          if(++CNTflush >= 200)
  0188    0AF6    INCR	0x76
  0189    1903    SZB	0x3,2
  018A    0AF7    INCR	0x77
  018B    3000    LDIA	0x0
  018C    0277    SUBA	0x77
  018D    30C8    LDIA	0xC8
  018E    1903    SZB	0x3,2
  018F    0276    SUBA	0x76
  0190    1C03    SNZB	0x3,0
  0191    0008    RET
196:                          {
197:                              CNTflush = 0;
  0192    01F6    CLR	0x76
  0193    01F7    CLR	0x77
198:                              SEQflsuh = FLUSH_SML_2;
  0194    3008    LDIA	0x8
  0195    00C6    LD	0x46,A
  0196    0008    RET
199:                          }
200:                          break;
201:                      case FLUSH_SML_2:
202:                          f_STSflush = SET;
203:                          POairPump = OFF;        /* 关气泵，停止冲水 */
204:                          POmainValue = OFF;      /* 冲水通道1 */
205:                          if(++CNTflush >= 5)
  0197    21F8    CALL	0x1F8
  0198    120A    CLRB	0xA,4
  0199    118A    CLRB	0xA,3
  019A    2970    JP	0x170
206:                          {
207:                              CNTflush = 0;
208:                              SEQflsuh = FLUSH_END_0;
209:                          }
210:                          break;
211:              
212:                      case FLUSH_END_0:
213:                          f_STSflush = SET;
214:                          POairPump = OFF;        /* 停止冲水 */
215:                          POmainValue = OFF;      /* 返回通道1 */
216:                          if(++CNTflush >= 5)
  019B    21F8    CALL	0x1F8
  019C    120A    CLRB	0xA,4
  019D    118A    CLRB	0xA,3
  019E    1903    SZB	0x3,2
  019F    0276    SUBA	0x76
  01A0    1C03    SNZB	0x3,0
  01A1    0008    RET
217:                          {
218:                              CNTflush = 0;
  01A2    01F6    CLR	0x76
  01A3    01F7    CLR	0x77
219:                              SEQflsuh = FLUSH_END_1;
  01A4    300A    LDIA	0xA
  01A5    00C6    LD	0x46,A
  01A6    0008    RET
220:                          }
221:                          break;
222:                      case FLUSH_END_1:
223:                          f_STSflush = CLR;
  01A7    1378    CLRB	0x78,6
224:                          POairPump = OFF;
  01A8    1105    CLRB	0x5,2
225:                          POmainValue = OFF;
  01A9    1205    CLRB	0x5,4
226:                          SEQflsuh = FLUSH_INIT_0;
  01AA    01C6    CLR	0x46
227:                          CNTflush = 0;
  01AB    01F6    CLR	0x76
  01AC    01F7    CLR	0x77
228:                          OKfls_Big = CLR;
  01AD    10F8    CLRB	0x78,1
229:                          OKfls_Sml = CLR;
  01AE    11F8    CLRB	0x78,3
230:                          break;
  01AF    0008    RET
231:                      default:
232:                          f_STSflush = CLR;
  01B0    1378    CLRB	0x78,6
233:                          POairPump = OFF;
  01B1    1105    CLRB	0x5,2
234:                          POmainValue = OFF;
  01B2    1205    CLRB	0x5,4
235:                          OKfls_Big = CLR;
  01B3    10F8    CLRB	0x78,1
236:                          OKfls_Sml = CLR;
  01B4    11F8    CLRB	0x78,3
237:                          SEQflsuh = FLUSH_INIT_0;
  01B5    01C6    CLR	0x46
238:                          CNTflush = 0;
  01B6    01F6    CLR	0x76
  01B7    01F7    CLR	0x77
239:                          break;
  01B8    0008    RET
  01B9    0846    LD	A,0x46
  01BA    3A00    XORIA	0x0
  01BB    1903    SZB	0x3,2
  01BC    291E    JP	0x11E
  01BD    3A01    XORIA	0x1
  01BE    1903    SZB	0x3,2
  01BF    292C    JP	0x12C
  01C0    3A03    XORIA	0x3
  01C1    1903    SZB	0x3,2
  01C2    2940    JP	0x140
  01C3    3A01    XORIA	0x1
  01C4    1903    SZB	0x3,2
  01C5    294F    JP	0x14F
  01C6    3A07    XORIA	0x7
  01C7    1903    SZB	0x3,2
  01C8    295B    JP	0x15B
  01C9    3A01    XORIA	0x1
  01CA    1903    SZB	0x3,2
  01CB    296D    JP	0x16D
  01CC    3A03    XORIA	0x3
  01CD    1903    SZB	0x3,2
  01CE    2979    JP	0x179
  01CF    3A01    XORIA	0x1
  01D0    1903    SZB	0x3,2
  01D1    2985    JP	0x185
  01D2    3A0F    XORIA	0xF
  01D3    1903    SZB	0x3,2
  01D4    2997    JP	0x197
  01D5    3A01    XORIA	0x1
  01D6    1903    SZB	0x3,2
  01D7    299B    JP	0x19B
  01D8    3A03    XORIA	0x3
  01D9    1903    SZB	0x3,2
  01DA    29A7    JP	0x1A7
  01DB    29B0    JP	0x1B0
  01DC    0008    RET
240:                  }
241:              }
242:              
243:              
---- C:\Users\汪强升\Desktop\3\ABM007_FM3(1)\ABM007_FM3\ABM007_FM3\source\fct.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE fctBits001;
5:                
6:                // #define FfctTest fctBits001.bits.bit_0
7:                
8:                volatile unsigned int CNTfctStart;
9:                volatile unsigned char CNTfctSensior;
10:               volatile unsigned char CNTfctFlashLed;
11:               volatile unsigned int CNTfct;
12:               volatile unsigned int CNTkey1;
13:               volatile unsigned int CNTkey2;
14:               volatile unsigned int flag_time;
15:               
16:               unsigned int Flag_G_Key = 0;
17:               
18:               void FCTkey(void);
19:               void FCTjudge(void);
20:               
21:               void FCTloop(void)
22:               {
23:                   FCTkey();
  020A    2244    CALL	0x244
  020B    120A    CLRB	0xA,4
  020C    118A    CLRB	0xA,3
24:                   FCTjudge();
  020D    2A0E    JP	0x20E
25:               }
26:               
27:               /* void FCTkey(void)
28:               {
29:                   if(PItest == HIGH)
30:                   {
31:                       if(++CNTfctStart >= 100)
32:                       {
33:               //            CNTfctStart = 100;
34:                           FfctTest = 1;
35:               			if(PItest == HIGH)
36:               			{
37:               				if(++CNTfctStart >= 500)
38:               				{
39:               					FfctTest = 0;
40:               					CNTfctStart = 0;
41:               					return;
42:               				}
43:               			}
44:               //			CNTfctStart = 0;
45:               			return;
46:                       }
47:                   }
48:               }
49:               */
50:               void FCTkey(void)
51:               {
52:               	if(FfctTest == 1)
  0244    1879    SZB	0x79,0
53:               	{
54:               		if(PItest == HIGH)
  0245    1D06    SNZB	0x6,2
  0246    2A52    JP	0x252
55:               		{
56:               			Delay_nms(1000);
  0247    30E8    LDIA	0xE8
  0248    00F4    LD	0x74,A
  0249    3003    LDIA	0x3
  024A    00F5    LD	0x75,A
  024B    225C    CALL	0x25C
  024C    120A    CLRB	0xA,4
  024D    118A    CLRB	0xA,3
57:               			if(PItest == HIGH)
  024E    1D06    SNZB	0x6,2
  024F    2A52    JP	0x252
58:               			{
59:               				FfctTest = 0;
  0250    1079    CLRB	0x79,0
60:               				return;
  0251    0008    RET
61:               			}
62:               		}
63:               	}
64:                   if(PItest == HIGH)
  0252    1D06    SNZB	0x6,2
  0253    0008    RET
65:                   {
66:               		Delay_nms(1000);
  0254    30E8    LDIA	0xE8
  0255    00F4    LD	0x74,A
  0256    3003    LDIA	0x3
  0257    00F5    LD	0x75,A
  0258    225C    CALL	0x25C
67:               		if(PItest == HIGH)
  0259    1906    SZB	0x6,2
68:               		{
69:               			FfctTest = 1;
  025A    1479    SETB	0x79,0
70:               			return;
  025B    0008    RET
71:               		}
72:               	}
73:               }
74:               
75:               void G_KEY(void)
76:               {
77:               	POlight = LOW;
  0230    1285    CLRB	0x5,5
78:               	POairPump = LOW;
  0231    1105    CLRB	0x5,2
79:               	POmainValue = HIGH;
  0232    1605    SETB	0x5,4
80:               	POdirectValue = LOW;
  0233    1085    CLRB	0x5,1
  0234    0008    RET
81:               }
82:               
83:               void R_KEY(void)
84:               {
85:               	POlight = LOW;
  0235    1285    CLRB	0x5,5
86:               	POairPump = HIGH;
  0236    1505    SETB	0x5,2
87:               	POmainValue = HIGH;
  0237    1605    SETB	0x5,4
88:               	POdirectValue = LOW;
  0238    1085    CLRB	0x5,1
  0239    0008    RET
89:               }
90:               
91:               void key1(void)
92:               {
93:               	POlight = HIGH;
  023A    1685    SETB	0x5,5
94:               	POairPump = LOW;
  023B    1105    CLRB	0x5,2
95:               	POmainValue = HIGH;
  023C    1605    SETB	0x5,4
96:               	POdirectValue = LOW;
  023D    1085    CLRB	0x5,1
  023E    0008    RET
97:               }
98:               
99:               void key2(void)
100:              {
101:              	POlight = LOW;
  023F    1285    CLRB	0x5,5
102:              	POairPump = LOW;
  0240    1105    CLRB	0x5,2
103:              	POmainValue = HIGH;
  0241    1605    SETB	0x5,4
104:              	POdirectValue = HIGH;
  0242    1485    SETB	0x5,1
  0243    0008    RET
105:              }
106:              
107:              void FCTjudge(void)
108:              {
109:                  if(FfctTest == 1)
  020E    1C79    SNZB	0x79,0
  020F    2A27    JP	0x227
110:                  {
111:              		if(++flag_time == 1500)
  0210    0AA0    INCR	0x20
  0211    1903    SZB	0x3,2
  0212    0AA1    INCR	0x21
  0213    30DC    LDIA	0xDC
  0214    0620    XORA	0x20
  0215    3005    LDIA	0x5
  0216    1903    SZB	0x3,2
  0217    0621    XORA	0x21
  0218    1D03    SNZB	0x3,2
  0219    2A1D    JP	0x21D
112:              		{
113:              			FfctTest = 0;
  021A    1079    CLRB	0x79,0
114:              			flag_time = 0;
  021B    01A0    CLR	0x20
  021C    01A1    CLR	0x21
115:              		}
116:              		if(PIsensor == LOW)
  021D    1886    SZB	0x6,1
  021E    2A20    JP	0x220
117:              		{
118:              			R_KEY();
  021F    2A35    JP	0x235
119:              		}
120:              		else
121:              		{
122:              			if(PIKey1 == LOW)
  0220    1B05    SZB	0x5,6
  0221    2A23    JP	0x223
123:              			{
124:              				key1();
  0222    2A3A    JP	0x23A
125:              			}
126:              			else
127:              			{
128:              				if(PIKey2 == LOW)
  0223    1806    SZB	0x6,0
  0224    2A26    JP	0x226
129:              				{
130:              					key2();
  0225    2A3F    JP	0x23F
131:              				}
132:              				else
133:              				{
134:              					G_KEY();
  0226    2A30    JP	0x230
135:              				}
136:              			}
137:              		}
138:              	}
139:                  else if(FfctTest == 0)
  0227    1879    SZB	0x79,0
  0228    0008    RET
140:                  {
141:              		POlight = LOW;
  0229    1285    CLRB	0x5,5
142:              		POairPump = LOW;
  022A    1105    CLRB	0x5,2
143:              		POmainValue = LOW;
  022B    1205    CLRB	0x5,4
144:              		POdirectValue = LOW;
  022C    1085    CLRB	0x5,1
145:              		flag_time = 0;
  022D    01A0    CLR	0x20
  022E    01A1    CLR	0x21
  022F    0008    RET
146:                  }
147:              }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    3020    LDIA	0x20
  0010    01F6    CLR	0x76
  0011    01F7    CLR	0x77
  0012    01F8    CLR	0x78
  0013    01F9    CLR	0x79
  0014    01FA    CLR	0x7A
  0015    1383    CLRB	0x3,7
  0016    0084    LD	0x4,A
  0017    3057    LDIA	0x57
  0018    120A    CLRB	0xA,4
  0019    118A    CLRB	0xA,3
  001A    2378    CALL	0x378
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    2AF9    JP	0x2F9
---- common_function ------------------------------------------------------------------
  001B    0183    CLR	0x3
  001C    120A    CLRB	0xA,4
  001D    118A    CLRB	0xA,3
  001E    2A8A    JP	0x28A
  010C    0830    LD	A,0x30
  010D    0732    ADDA	0x32
  010E    00AE    LD	0x2E,A
  010F    0831    LD	A,0x31
  0110    1803    SZB	0x3,0
  0111    0A31    INCA	0x31
  0112    0733    ADDA	0x33
  0113    00AF    LD	0x2F,A
  0114    0008    RET
  01F8    1778    SETB	0x78,6
  01F9    1105    CLRB	0x5,2
  01FA    1205    CLRB	0x5,4
  01FB    0AF6    INCR	0x76
  01FC    1903    SZB	0x3,2
  01FD    0AF7    INCR	0x77
  01FE    3000    LDIA	0x0
  01FF    0277    SUBA	0x77
  0200    3405    RET	0x5
  0201    1778    SETB	0x78,6
  0202    1105    CLRB	0x5,2
  0203    1605    SETB	0x5,4
  0204    0AF6    INCR	0x76
  0205    1903    SZB	0x3,2
  0206    0AF7    INCR	0x77
  0207    3000    LDIA	0x0
  0208    0277    SUBA	0x77
  0209    340A    RET	0xA
  0378    0064    CLRWDT
  0379    0180    CLR	0x0
  037A    0A84    INCR	0x4
  037B    0604    XORA	0x4
  037C    1903    SZB	0x3,2
  037D    3400    RET	0x0
  037E    0604    XORA	0x4
  037F    2B79    JP	0x379
