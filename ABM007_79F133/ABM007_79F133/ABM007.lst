---- C:\Users\汪强升\Desktop\ABM007_79F133(2)\ABM007_79F133\source\main.c ----------------------------------------------------------------------
1:                // #include <cms.h>	//芯片头文件，会根据工程选项自动寻找对应型号头文件
2:                #include "cfg_user.h"
3:                #include "cfg_case.h"
4:                #include "math.h"
5:                #include "string.h"
6:                
7:                volatile unsigned int TMR1 @0x000E;
8:                #define TIMER1_TIME 0xE0C0
9:                
10:               /**********************************************************************/
11:               /*全局变量声明*/
12:               /**********************************************************************/
13:               
14:               /*变量*/
15:               v_uint8 RX_Buf;
16:               v_uint8 templ = 0;
17:               v_uint8 SEQmain = 0;
18:               v_uint8 MainTime_1min = 0;	/* 定时1min计数 */
19:               v_uint16 MainTime_1s = 0;	/* 定时1s计数 */
20:               v_uint16 AD_Result = 0;
21:               
22:               extern  void INT_LED_SHOW(void);
23:               #if FCT_TEST
24:               	extern void FCTloop(void);
25:               #endif
26:               
27:               /***********************************************************************
28:               函数功能：延时子函数，13个指令周期1循环
29:               ***********************************************************************/
30:               void Delay(unsigned int dtemp)
31:               {
32:               	while (dtemp--)
  0392    3001    LDIA	0x1
  0393    02F2    SUBR	0x72
  0394    3000    LDIA	0x0
  0395    1C03    SNZB	0x3,0
  0396    03F3    DECR	0x73
  0397    02F3    SUBR	0x73
  0398    0F72    SZINCA	0x72
  0399    2B92    JP	0x392
  039A    0A73    INCA	0x73
  039B    1903    SZB	0x3,2
  039C    0008    RET
  039D    2B92    JP	0x392
33:               		;
34:               }
35:               /***********************************************************************
36:               子函数功能：延时templ  ms，有中断则不准
37:               ***********************************************************************/
38:               void Delay_nms(unsigned int inittempl)
39:               {
40:               	unsigned int i;
41:               	unsigned char gtemp;
42:               	/******************************************************************/
43:               	gtemp = 0;
  0370    1283    CLRB	0x3,5
  0371    01C6    CLR	0x46
44:               	if (GIE == 1)
  0372    1F8B    SNZB	0xB,7
  0373    2B77    JP	0x377
45:               	{
46:               		gtemp = 1;
  0374    01C6    CLR	0x46
  0375    0AC6    INCR	0x46
47:               		GIE = 0;
  0376    138B    CLRB	0xB,7
48:               	}
49:               	for (i = 0; i < inittempl; i++)
  0377    01C4    CLR	0x44
  0378    01C5    CLR	0x45
  0379    0875    LD	A,0x75
  037A    0245    SUBA	0x45
  037B    1D03    SNZB	0x3,2
  037C    2B7F    JP	0x37F
  037D    0874    LD	A,0x74
  037E    0244    SUBA	0x44
  037F    1803    SZB	0x3,0
  0380    2B8E    JP	0x38E
50:               	{
51:               		Delay(154);
  0381    309A    LDIA	0x9A
  0382    00F2    LD	0x72,A
  0383    01F3    CLR	0x73
  0384    2392    CALL	0x392
  0385    120A    CLRB	0xA,4
  0386    118A    CLRB	0xA,3
  0387    0064    CLRWDT
  0388    1283    CLRB	0x3,5
  0389    1303    CLRB	0x3,6
  038A    0AC4    INCR	0x44
  038B    1903    SZB	0x3,2
  038C    0AC5    INCR	0x45
  038D    2B79    JP	0x379
52:               		asm("clrwdt");
53:               	}
54:               	if (gtemp == 1)
  038E    0B46    SZDECA	0x46
  038F    0008    RET
55:               		GIE = 1;
  0390    178B    SETB	0xB,7
  0391    0008    RET
56:               }
57:               
58:               /************************************************************
59:               函数名称：Init_GPIO()
60:               函数功能：初始化IO端口
61:               入口参数：
62:               出口参数：
63:               备注：
64:               ************************************************************/
65:               void Init_GPIO(void)
66:               {
67:               
68:               	/*引脚数据*/
69:               	PORTA = 0B00000000;
  03B0    1283    CLRB	0x3,5
  03B1    1303    CLRB	0x3,6
  03B2    0185    CLR	0x5
70:               	PORTB = 0B00000000;
  03B3    0186    CLR	0x6
71:               	PORTC = 0B00000000;
  03B4    0187    CLR	0x7
72:               
73:               	/* 全部配置成输入状态，1: 输入，0: 输出 */
74:               	TRISA = 0B00000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  03B5    1683    SETB	0x3,5
  03B6    0185    CLR	0x5
75:               	TRISB = 0B00000010; /* RB1-龙头感应 */
  03B7    3002    LDIA	0x2
  03B8    0086    LD	0x6,A
76:               	TRISC = 0B00000000;
  03B9    0187    CLR	0x7
77:               
78:               	/*内部上拉关闭, 1: 开启, 0: 关闭 */
79:               	WPUA = 0B00000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  03BA    1703    SETB	0x3,6
  03BB    018E    CLR	0xE
80:               	WPUB = 0B00000010; /* RB1-龙头感应<置1则不插为有人状态，RB1低有效> */
  03BC    1303    CLRB	0x3,6
  03BD    0095    LD	0x15,A
81:               	WPUC = 0B00000000;
  03BE    1703    SETB	0x3,6
  03BF    018F    CLR	0xF
  03C0    0008    RET
82:               
83:               	/* 内部下拉 */
84:               	// WPDB =  0B00000000; /* RB1-龙头感应<1不插为无人状态，RB1高有效> */
85:               
86:               	/*模拟通道选择*/
87:               //	ANSEL0 = 0B00000000; // AN7 - AN0
88:               //	ANSEL1 = 0B00000000; // AN15 - AN8
89:               //	ANSEL2 = 0B00000000; //------AN17 AN16
90:               }
91:               
92:               /************************************************************
93:               函数名称：Init_IC()
94:               函数功能：上电初始化系统寄存器
95:               入口参数：
96:               出口参数：
97:               备注：
98:               ************************************************************/
99:               void Init_IC(void)
  039E    0064    CLRWDT
100:              {
101:              	asm("clrwdt");
102:              
103:              	// 7			6			5			4			3			2			1			0
104:              	// GIE		PEIE		TOIE		INTE		RBIE		TOIF		INTF		RBIF
105:              	// 全局允许	外设允许	T0允许		INT允许		PB允许		T0标志		INT标志		PB标志
106:              	INTCON = 0x00; // 中断控制寄存器
  039F    018B    CLR	0xB
107:              
108:              	// 7			6			5			4			3			2			1			0
109:              	//--		ADIF		RCIF		TXIF		--			CCP1IF		TMR2IF		TMR1IF
110:              	// NC		AD转换完成	UART接收满	UART发送满		NC		CCP1中断	T2与PR2匹配		T1
111:              	PIR1 = 0; // 外设中断请求寄存器
  03A0    1283    CLRB	0x3,5
  03A1    1303    CLRB	0x3,6
  03A2    018C    CLR	0xC
112:              
113:              	// 7			6			5			4			3			2			1			0
114:              	//--		TKIF		RACIF		EEIF		--			--			--			CCP2IF
115:              	// NC		触摸检测结束 PA变化		 EEP写完成	  NC		  NC		  NC		  CCP2中断
116:              	PIR2 = 0; // 外设中断请求寄存器
  03A3    018D    CLR	0xD
117:              
118:              	// 7			6			5			4			3			2			1			0
119:              	//--		--			--			--			--			--			--			SWDTEN
120:              	// NC		NC			NC			NC			NC			NC			NC			使能
121:              	WDTCON = 0x01; // 看门狗
  03A4    3001    LDIA	0x1
  03A5    1703    SETB	0x3,6
  03A6    0085    LD	0x5,A
122:              
123:              	// 7				6			5			4			3			2			1		0
124:              	// RBPU			INTEDG			T0CS		T0SE		PSA			PS2			PS1		PS0
125:              	// PB上拉使能	中断边沿选择  	T0时钟源	  T0边沿选择	预分配		预分配参数
126:              	OPTION_REG = 0b00001110; // 开启PORTB上来使能，看门狗复位时间=18*分频系数 (规格书 2.6/2.8.1)
  03A7    300E    LDIA	0xE
  03A8    1683    SETB	0x3,5
  03A9    1303    CLRB	0x3,6
  03AA    0081    LD	0x1,A
127:              
128:              	// 7			6			5			4			3			2			1			0
129:              	//--		IRCF2		IRCF1		IRCF0		--			--			--			--
130:              	// NC		内振分频							NC			NC			NC			NC
131:              	OSCCON = 0x71; // 振荡器控制
  03AB    3071    LDIA	0x71
  03AC    008F    LD	0xF,A
132:              
133:              	// 7			6			5			4			3			2			1				0
134:              	//--		ADIE		RCIE		TXIE		--			CCP1IE		TMR2IE			TMR1IE
135:              	// NC		AD转换允许	UART接收允许 UART发送允许 NC		  CCP1允许	  T2与PR2匹配允许	T1溢出允许
136:              	PIE1 = 0; // 外设中断允许
  03AD    018C    CLR	0xC
137:              
138:              	//
139:              	//--	TKIE				RACIE			EEIE			--		--		--		CCP2IE
140:              	// NC	触摸检测结束允许	PA变化允许			EEP写允许		NC		NC		NC		CCP2中断允许
141:              	PIE2 = 0; // 外设中断允许
  03AE    018D    CLR	0xD
  03AF    0008    RET
142:              }
143:              
144:              /************************************************************
145:              函数名称：Init_TIMER1()
146:              函数功能：定时器1初始化函数
147:              入口参数：
148:              出口参数：
149:              备注：	  定时时间计算方法
150:              		  定时时间T = {1/[(Fosc)*预分频比)]}*(65535-[TMR1H:TMR1L])
151:              		  本程序计算示例：
152:              		  T = {1/[(8)*(1/1)]}*(65536 - 63936)
153:              			= 125 us
154:              ************************************************************/
155:              void Init_TIMER1(void)
156:              {
157:              	// TMR1L = 0xC0; //赋初值
158:              	// TMR1H = 0xF9;
159:              	TMR1 = TIMER1_TIME;
  03CC    30E0    LDIA	0xE0
  03CD    008F    LD	0xF,A
  03CE    30C0    LDIA	0xC0
  03CF    008E    LD	0xE,A
160:              	TMR1IF = 0;	  // 清中断标志位
  03D0    100C    CLRB	0xC,0
161:              	TMR1IE = 1;	  // 允许Timer1中断
  03D1    1683    SETB	0x3,5
  03D2    140C    SETB	0xC,0
162:              	T1CON = 0x01; // 开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  03D3    3001    LDIA	0x1
  03D4    1283    CLRB	0x3,5
  03D5    0090    LD	0x10,A
  03D6    0008    RET
163:              }
164:              
165:              /************************************************************
166:              函数名称：Init_TIMER2()
167:              函数功能：定时器2初始化函数
168:              入口参数：
169:              出口参数：
170:              备注：	  定时时间计算方法
171:              		  时钟输入为系统指令时钟（即为Fosc/4）
172:              		  定时时间T = {1/[(Fosc/4)*预分频比*后分频比]}*(PR2+1)
173:              		  本程序计算示例：
174:              		  T = {1/[(8/4)*(1/4)*1]}*50 = 100 us
175:              
176:              ************************************************************/
177:              void Init_TIMER2(void)
178:              {
179:              	PR2 = 24;	// 8M下将TMR2设置为50us中断?
  03C1    3018    LDIA	0x18
  03C2    1683    SETB	0x3,5
  03C3    0092    LD	0x12,A
180:              	TMR2IF = 0; // 清中断标志位
  03C4    1283    CLRB	0x3,5
  03C5    108C    CLRB	0xC,1
181:              	TMR2IE = 1; // 允许Timer2中断
  03C6    1683    SETB	0x3,5
  03C7    148C    SETB	0xC,1
182:              	T2CON = 5;	// 开启Timer2，预分频值为4，后分频比为1:1
  03C8    3005    LDIA	0x5
  03C9    1283    CLRB	0x3,5
  03CA    0092    LD	0x12,A
  03CB    0008    RET
183:              }
184:              
185:              /* 遥控器接收数据时钟，50μs */
186:              // void Init_TIMER2_Remo(void)
187:              //{
188:              //	PR2 = 24;		//16M下将TMR2设置为50μs中断
189:              //	TMR2IF = 0; 	//清中断标志位
190:              //	TMR2IE = 1; 	//允许Timer2中断
191:              //	T2CON = 5;		//开启Timer2，预分频值为4，后分频比为1:1
192:              // }
193:              
194:              /***********************************************
195:              函数名称：Set_CCP_PWM
196:              函数功能：CCP PWM模式初始化
197:              入口参数：无
198:              出口参数：无
199:              备注：
200:              	   周期 = (PWMxCYC+1)*4/Fosc*PWMxCNT预分频值
201:              	  占空比 = (CCPRxL:CCPCON<5:4>)/(4*(PWMxCYC + 1))
202:              	  由于CCPx 引脚与端口数据锁存器复用，必须清零相应的TRIS 位才能使能CCPx 引脚的输出驱动器。
203:              ************************************************/
204:              void Set_CCP_PWM()
205:              {
206:              //	PWMCON = 0B00000001; // PWM1设置为16分频，使能PWM1
207:              
208:              	// // PWM1 周期设置为500us，占空比50%
209:              	// CCP1CON = 0B00001100; // PWM模式,10位占空比数据低2位为0；
210:              	// PWM1CYC = 124;		  // PWM1周期为：(249+1)* （4/8） * 4 =500uS
211:              	// CCPR1L = 62;		  // 低2位为0,(CCPRxL:CCPCON<5:4>)=CCPR1L*4
212:              	// CYC1EN = 1;			  /* PWM1的周期计数器使能位,1使能，0禁止 */
213:              	// PWMTL = 0x8f;					//PWM0~3共周期，周期低位
214:              	PWMT4L = 0x7C;					//PWM4独立周期，周期低位,0x7C,(124+1)* （4/8） * 4 =250μs
215:              	PWMTH = 0B00011101;				//周期高两位及PWM4占空比高两位	
216:              	/* PWMTH: bit5~bit4- PWM4占空比高2位，bit3~bit2-PWM周期高2位，bit1~bit0-PWM0~PWM3周期高2位 */
217:              	
218:              	//PWM0~3周期为：(0B110001111+1)*(1/16)*2 =50uS
219:              	//PWM4周期为：(0B1110001111+1)*(1/16)*2 =114uS
220:              	/* PWM4 0B00001100 */
221:              	
222:              	// PWMD01H = 0x00;					//高位改变后不能立即生效，需要给占空比的低位寄存器后才能加载
223:              	// //PWM0 占空比设置为20%
224:              	// PWMD0L = 0x4f;					//(79+1)/(399+1) = 20%
225:              	// //PWM1 占空比设置为40%
226:              	// PWMD1L = 0x9f;					//(159+1)/(399+1) = 40%
227:              
228:              	// PWMD23H = 0x10;
229:              	// //PWM2 占空比设置为60%
230:              	// PWMD2L = 0xef;					//(239+1)/(399+1) = 60%
231:              	// //PWM3 占空比设置为80%
232:              	// PWMD3L = 0x3f;					//(319+1)/(399+1) = 80%
233:              
234:              	//PWM4 占空比设置为25%
235:              	PWMD4L = 0xC7;					//(227+1)/(911+1) = 25% ()
236:              	/* 50% 0x01C7, (455+1)/(911+1) */
237:              	
238:              	// PWM01DT = 0x3F;					//死区时间，低6位有效位=(0B00111111+1)*(1/16)*1 =4uS
239:              	// PWM23DT = 0;
240:              	
241:              	PWMCON2 = 0B00000000;			//正常输出
242:              	PWMCON1 = 0B00000000;			//PWM01位置选择为RB5/RB4;禁止死区；可使能PWM0/1互补，PWM2/3互补
243:              	PWMCON0 = 0B00110000;			//PWM分频Fosc/2，使能PWM4
244:              }
245:              
246:              /***********************************************
247:              函数名称：Memory_Write
248:              函数功能：写数据
249:              入口参数：Addr - 写入地址
250:              		  Value - 写入数值
251:              出口参数：返回值 0 - 写操作错误 1 - 写完毕
252:              备注：
253:              写程序EE过程中需要暂时关闭中断，以保证写EE时序中的写55H和写AAH能够连续进行，否则将有可能写错，并且写EE的可靠工作电压范围为3V以上。
254:              ************************************************/
255:              unsigned char Memory_Write(unsigned char Addr, unsigned char Value)
256:              {
257:              
258:              	volatile unsigned char i = 0;
259:              	// 将要写入的地址放入EEADDR寄存器
260:              	EEADR = Addr;
261:              	EEDAT = Value; // 将要写入的数据给EEPROM的数据寄存器
262:              	EECON1 = 0;
263:              	EEPGD = 0;		 // 访问数据存储器
264:              	EECON1 | = 0x10; // 烧写时间10ms（0x30）,时间非固定精准,用户可自定义(最长烧写等待时间2.5ms, 0x10)
265:              	asm("clrwdt");
266:              
267:              	WREN = 1; // 允许写周期
268:              	GIE = 0;  // 关闭中断
269:              	GIE = 0;
270:              	GIE = 0;
271:              	while (GIE)
272:              	{
273:              		GIE = 0; // 确保中断已关闭
274:              		if (0 == --i)
275:              		{
276:              			// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
277:              			GIE = 1; // 总中断GIE置1
278:              			return 0;
279:              		}
280:              	}
281:              	asm("clrwdt");
282:              
283:              	EECON2 = 0x55; // 给EECON2写入0x55
284:              	EECON2 = 0xaa; // 给EECON2写入0xaa
285:              	WR = 1;		   // 启动写周期
286:              	asm("nop");
287:              	asm("nop");
288:              	asm("clrwdt");
289:              	WREN = 0; // 禁止写入
290:              	// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
291:              	GIE = 1; // 总中断GIE置1
292:              
293:              	if (WRERR)
294:              		return 0; // 写操作错误
295:              	else
296:              		return 1; // 写完毕
297:              }
298:              
299:              void Flash_Write(unsigned char Addr, unsigned char Value)
300:              {
301:              	uint8_t bufAddress;
302:              	uint8_t bufValue;
303:              	bufAddress = Addr;
304:              	bufValue = Value;
305:              	templ = 10; //错误计数，用户可自定义
306:              	do
307:              	{
308:              		asm("clrwdt");
309:              		asm("clrwdt");
310:              	} while ((0 == Memory_Write(bufAddress, bufValue)) && (templ--)); //调用写函数：地址0x00处写入数据0x5a
311:              }
312:              
313:              /***********************************************
314:              函数名称：Memory_Read
315:              函数功能：读数据
316:              入口参数：Addr - 读取地址
317:              出口参数：返回读取地址相应数值
318:              备注：
319:              ************************************************/
320:              unsigned char Memory_Read(unsigned char Addr)
321:              {
322:              
323:              	EEADR = Addr;
324:              	EEPGD = 0; // 访问数据存储器
325:              
326:              	RD = 1; // 允许读操作
327:              	asm("nop");
328:              	asm("nop");
329:              
330:              	return (EEDAT);
331:              }
332:              
333:              /************************************************************
334:              函数名称：AD_Testing()
335:              函数功能：AD采样函数
336:              入口参数：ad_fd - 分频 00Fosc/8; 01Fosc/16; 10Fosc/32; 11Frc;
337:              		  ad_ch - AD通道选择1~15，15通道为内部基准1.2V固定输入值
338:              		  ad_lr - 左/右对齐，输入0或1，0为左对齐，1为右对齐
339:              
340:              出口参数：AdResult - AD结果
341:              备    注：BUFmotor_ad = AD_Testing(0, 10, 0); //8分频，AN10通道，右对齐	规格书11.2.4，8M主频最快8分频
342:              ************************************************************/
343:              unsigned int AD_Testing(unsigned char ad_fd, unsigned char ad_ch, unsigned char ad_lr)
344:              {
345:              	// static volatile unsigned char adtimes;
346:              	// static volatile unsigned int admin, admax, adsum;
347:              	volatile unsigned int data;
348:              	volatile unsigned char i = 0;
349:              
350:              	if (!ad_lr)
351:              		ADCON1 = 0; // 左对齐,出12位
352:              	else
353:              		ADCON1 = 0x80; // 右对齐,出10位
354:              
355:              	if (ad_ch & 0x10) // 设置CHS4，此位在ADCON1寄存器中
356:              		ADCON1 |= 0x40;
357:              
358:              	ADCON0 = 0;
359:              	ad_ch &= 0x0f;
360:              	ADCON0 |= (unsigned char)(ad_fd << 6); // 不同的VDD或参考电压需要配置合理的分频
361:              	ADCON0 |= (unsigned char)(ad_ch << 2); // 设置通道
362:              	ADCON0 |= 0x01;						   // 使能ADC
363:              
364:              	asm("nop");
365:              	asm("nop");
366:              	GODONE = 1; // 开始转换
367:              
368:              	while (GODONE)
369:              	{
370:              		asm("nop");
371:              		asm("nop");
372:              		if ((--i) == 0) // ad等待限时，防止出现死循环，但要考虑转换时间不能长于此时间
373:              			return 0;
374:              	}
375:              
376:              	if (!ad_lr) // 左对齐
377:              	{
378:              		data = (unsigned int)(ADRESH << 4);
379:              		data |= (unsigned int)(ADRESL >> 4);
380:              	}
381:              	else // 右对齐
382:              	{
383:              		data = (unsigned int)(ADRESH << 8);
384:              		data |= (unsigned int)ADRESL;
385:              	}
386:              
387:              	return data;
388:              }
389:              
390:              /***********************************************
391:              函数名称：Set_Usart_Async
392:              函数功能：Usart状态设置（异步）
393:              入口参数：无
394:              出口参数：无
395:              备注：
396:              1、串口通讯，设置波特率寄存器时，应控制在19200及以下，实际应用时应考虑到芯片内振的电压及温度特性。
397:              2、SYNC = 0;目标波特率 = Fosc/(16*(SPBRG+1))
398:              ************************************************/
399:              void Set_Usart_Async()
400:              {
401:              	BRGHEN1 = 1;
402:              	BRG16EN1 = 0; //设置BRG是一个8位定时器
403:              
404:              	SPBRGH1 = 0;
405:              	SPBRG1 = 51; //设置波特率为9600 bps (8M/(16*52))
406:              
407:              //	SPBRG = 25; /* 19200bps, 8M/(16*26) */
408:              
409:              	SYNC1 = 0; // 0为异步模式，1为同步模式
410:              	SCKP1 = 0; // 直接将数据字符发送到TX/CK引脚
411:              
412:              	SPEN1 = 1;  // 允许串口操作
413:              	RC1IE = 1;  // 接收中断  //暂时关闭
414:              	TX1IE = 0;  // 发送中断
415:              	RX9EN1 = 0; // 0为8位接收，1为9位接收
416:              	TX9EN1 = 0; // 0为8位发送，1为9位发送
417:              	CREN1 = 1;  // 0为禁止接收，1为使能接收 //暂时关闭
418:              	TXEN1 = 1;  // 0为禁止发送，1为使能发送
419:              }
420:              
421:              /************************************************************
422:              函数名称：Uart_Send_NByte()
423:              函数功能：串口多字节发送函数
424:              入口参数：n 待发送字节数量
425:              		  nSendByte 待发送数组
426:              出口参数：
427:              备    注：
428:              ************************************************************/
429:              // void Uart_Send_NByte(uint8_t n, uint8_t *nSendByte)
430:              // {
431:              // 	uint8_t i;
432:              // 	for(i = 0; i < n; i++)
433:              // 	{
434:              // 		TX_Buf[i] = nSendByte[i];
435:              // 	}
436:              // 	tx_index = n;
437:              // 	TXIE = 1;
438:              // }
439:              
440:              /************************************************************
441:              函数名称：Init_PA_Isr()
442:              函数功能：PA中断初始化函数
443:              入口参数：
444:              出口参数：
445:              备    注：
446:              ************************************************************/
447:              // void Init_PA_Isr()
448:              // {
449:              // 	IOCA = 0B01100110; // 允许RA1的IO口电平变化中断
450:              // 	RACIE = 1;		   // 使能PORTA电平变化中断
451:              // 	PORTA;			   // 读取PORTA并锁存
452:              // }
453:              
454:              /************************************************************
455:              函数名称：Init_PB_Isr()
456:              函数功能：PB中断初始化函数
457:              入口参数：
458:              出口参数：
459:              备    注：
460:              ************************************************************/
461:              // void Init_PB_Isr()
462:              // {
463:              // 	IOCB = 0B00000001; // 允许RB0的IO口电平变化中断
464:              // 	RBIE = 1;		   // 使能PORTB电平变化中断
465:              // 	// INTCON = 0x88;			//允许所有未被屏蔽的中断、禁止外设中断，使能PORTB电平变化中断
466:              // 	PORTB;			   // 读取PORTB并锁存
467:              // }
468:              
469:              /************************************************************
470:              函数名称：mainr()
471:              函数功能：主循环
472:              入口参数：
473:              出口参数：
474:              备    注：
475:              ************************************************************/
476:              void main(void)
  02D1    0000    NOP
  02D2    0064    CLRWDT
477:              {
478:              	/******************************************************************/
479:              	asm("nop");
480:              	asm("clrwdt");
481:              	INTCON = 0;		 //禁止中断
  02D3    018B    CLR	0xB
482:              
483:              	Init_GPIO();	// 初始化GPIO
  02D4    120A    CLRB	0xA,4
  02D5    118A    CLRB	0xA,3
  02D6    23B0    CALL	0x3B0
484:              	Init_IC();		// 相关寄存器初始化
  02D9    120A    CLRB	0xA,4
  02DA    118A    CLRB	0xA,3
  02DB    239E    CALL	0x39E
485:              	Delay_nms(200); // 上电延时200ms 非精准延时
  02DE    30C8    LDIA	0xC8
  02DF    00F4    LD	0x74,A
  02E0    01F5    CLR	0x75
  02E1    120A    CLRB	0xA,4
  02E2    118A    CLRB	0xA,3
  02E3    2370    CALL	0x370
486:              	Init_TIMER1();	// 定时器1初始化
  02E6    120A    CLRB	0xA,4
  02E7    118A    CLRB	0xA,3
  02E8    23CC    CALL	0x3CC
487:              	Init_TIMER2();	// 定时器2初始化
  02EB    120A    CLRB	0xA,4
  02EC    118A    CLRB	0xA,3
  02ED    23C1    CALL	0x3C1
488:              //	Init_PA_Isr();		 //PA中断初始化函数
489:              //	Init_PB_Isr();		 //PB中断初始化函数
490:              // #if FCT
491:              // 	/* FCT串口不初始化，TX、RX作为普通端口使用 */
492:              // #else
493:              // 	Set_Usart_Async(); // 串口初始化
494:              // #endif
495:              
496:              	//	Set_CCP_PWM();		 //PWM初始化
497:              
498:              	INTCON = 0XC0;	   // 允许所有未被屏蔽的中断、外设中断
  02F0    30C0    LDIA	0xC0
  02F1    008B    LD	0xB,A
499:              
500:              	// RemoFlash_Read();  /* 读取存储的数值 */
501:              	while (1)
502:              	{
503:              		/*主循环10ms*/
504:              		if (F1ms == SET)
  02F2    1CC3    SNZB	0x43,1
  02F3    2AF2    JP	0x2F2
  02F4    0064    CLRWDT
505:              		{
506:              			CLRWDT(); /*清看门狗*/
507:              			F1ms = CLR;
  02F5    1283    CLRB	0x3,5
  02F6    1303    CLRB	0x3,6
  02F7    10C3    CLRB	0x43,1
508:              			switch (SEQmain)
  02F8    2B0B    JP	0x30B
509:              			{
510:              #if FCT_TEST
511:              				case 0:
512:              					FCTloop();
513:              					break;
514:              #else
515:              				case 0:
516:              					GsensorLoop();
  02F9    120A    CLRB	0xA,4
  02FA    118A    CLRB	0xA,3
  02FB    2118    CALL	0x118
517:              					break;
  02FE    2B2B    JP	0x32B
518:              				case 1:
519:              
520:              					break;
521:              				case 2:
522:              
523:              					break;
524:              				case 3:
525:              
526:              					break;
527:              				case 4:
528:              					GflushLoop();
  02FF    120A    CLRB	0xA,4
  0300    118A    CLRB	0xA,3
  0301    201F    CALL	0x1F
529:              					break;
  0304    2B2B    JP	0x32B
530:              				case 5:
531:              
532:              					break;
533:              				case 6:
534:              
535:              					break;
536:              				case 7:
537:              
538:              					break;
539:              				case 8:
540:              					GledLoop();
  0305    120A    CLRB	0xA,4
  0306    118A    CLRB	0xA,3
  0307    220E    CALL	0x20E
541:              				break;
  030A    2B2B    JP	0x32B
  030B    083E    LD	A,0x3E
  030C    3A00    XORIA	0x0
  030D    1903    SZB	0x3,2
  030E    2AF9    JP	0x2F9
  030F    3A01    XORIA	0x1
  0310    1903    SZB	0x3,2
  0311    2B2B    JP	0x32B
  0312    3A03    XORIA	0x3
  0313    1903    SZB	0x3,2
  0314    2B2B    JP	0x32B
  0315    3A01    XORIA	0x1
  0316    1903    SZB	0x3,2
  0317    2B2B    JP	0x32B
  0318    3A07    XORIA	0x7
  0319    1903    SZB	0x3,2
  031A    2AFF    JP	0x2FF
  031B    3A01    XORIA	0x1
  031C    1903    SZB	0x3,2
  031D    2B2B    JP	0x32B
  031E    3A03    XORIA	0x3
  031F    1903    SZB	0x3,2
  0320    2B2B    JP	0x32B
  0321    3A01    XORIA	0x1
  0322    1903    SZB	0x3,2
  0323    2B2B    JP	0x32B
  0324    3A0F    XORIA	0xF
  0325    1903    SZB	0x3,2
  0326    2B05    JP	0x305
  0327    3A01    XORIA	0x1
  0328    1903    SZB	0x3,2
  0329    2B2B    JP	0x32B
  032A    2B2B    JP	0x32B
542:              				case 9:
543:              
544:              					break;
545:              #endif
546:              				default:
547:              					// SEQmain = 0;
548:              					break;
549:              			}
550:              			if (++SEQmain >= 10)
  032B    300A    LDIA	0xA
  032C    1283    CLRB	0x3,5
  032D    1303    CLRB	0x3,6
  032E    0ABE    INCR	0x3E
  032F    023E    SUBA	0x3E
  0330    1C03    SNZB	0x3,0
  0331    2AF2    JP	0x2F2
551:              			{
552:              				SEQmain = 0;
  0332    01BE    CLR	0x3E
  0333    2AF2    JP	0x2F2
553:              			}
554:              		}
555:              	}
556:              }
557:              
558:              // /***********************************************************************
559:              // 函数功能：中断入口函数
560:              // RISC内核无中断优先级，不可嵌套
561:              // ***********************************************************************/
562:              void interrupt Int_ALL(void)
563:              {
564:              	// 1ms定时器中断服务函数
565:              	if (TMR1IF)
  0334    1283    CLRB	0x3,5
  0335    1303    CLRB	0x3,6
  0336    1C0C    SNZB	0xC,0
  0337    2B4C    JP	0x34C
566:              	{
567:              		// ---------------------------------------
568:              		// TMR1L += 0xC0;
569:              		// TMR1H += 0xF9; //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
570:              		// 在进入中断等过程中其实Time是一直在计数的
571:              		// ---------------------------------------
572:              		TMR1 = TIMER1_TIME;
  0338    30E0    LDIA	0xE0
  0339    008F    LD	0xF,A
  033A    30C0    LDIA	0xC0
  033B    008E    LD	0xE,A
573:              		TMR1IF = 0; // 清中断标志位
  033C    100C    CLRB	0xC,0
574:              
575:              		/* 主循环1ms标志位 */
576:              		F1ms = 1;
  033D    14C3    SETB	0x43,1
577:              
578:              		/* 1s标志位 */
579:              		if (++MainTime_1s >= 1000)
  033E    0AB0    INCR	0x30
  033F    1903    SZB	0x3,2
  0340    0AB1    INCR	0x31
  0341    3003    LDIA	0x3
  0342    0231    SUBA	0x31
  0343    30E8    LDIA	0xE8
  0344    1903    SZB	0x3,2
  0345    0230    SUBA	0x30
  0346    1C03    SNZB	0x3,0
  0347    2B4C    JP	0x34C
580:              		{
581:              			MainTime_1s = 0;
  0348    01B0    CLR	0x30
  0349    01B1    CLR	0x31
582:              			Fsys1s.byte = 0xFF; /* 1s' flag */
  034A    30FF    LDIA	0xFF
  034B    00C2    LD	0x42,A
583:              // #if (VER_2510M || VER_2510U)
584:              // 			if (++MainTime_1min >= 60) /* 1min标识位 */
585:              // 			{
586:              // 				MainTime_1min = 0;
587:              // 				Fsys1m.byte = 0xFF; /* 1min' flag */
588:              // 			}
589:              // #endif
590:              		}
591:              	}
592:              
593:              	// 50us定时器中断服务函数
594:              	if (TMR2IF)
  034C    1C8C    SNZB	0xC,1
  034D    2B50    JP	0x350
595:              	{
596:              		TMR2IF = 0; /*	8位，自重载，无需二次配置	*/
  034E    108C    CLRB	0xC,1
597:              		INT_LED_SHOW(); /* 氛围灯中断函数 */
  034F    2357    CALL	0x357
  0350    0871    LD	A,0x71
  0351    008A    LD	0xA,A
  0352    0E70    SWAPA	0x70
  0353    0083    LD	0x3,A
  0354    0EFE    SWAPR	0x7E
  0355    0E7E    SWAPA	0x7E
  0356    0009    RETI
598:              	}
599:              
600:              // #if FCT
601:              // 	/* FCT停止uart通讯中断服务 */
602:              // #else
603:              // 	// 串口接收中断服务函数
604:              // 	if (RC1IF)
605:              // 	{
606:              // 		//-------------------------------------------
607:              // 		// 接收控制，如果接收标志位为1，说明有数据接收完毕
608:              // 		// RCIF在寄存器被读出后自动清零
609:              // 		if (FERR1)
610:              // 		{
611:              // 			RCREG1; // 帧错误
612:              // 			return;
613:              // 		}
614:              
615:              // 		RX_Buf = RCREG1; // 将接收缓冲区内容读出
616:              
617:              // 		Uart_ReceiveLogic(); /* UART*/
618:              
619:              // 		if (OERR1) // 如果有溢出错误
620:              // 		{
621:              // 			CREN1 = 0; // 清零CREN1位可将OERR位清零
622:              // 			CREN1 = 1; // 再次将CREN1置一，以允许继续接收
623:              // 		}
624:              // 	}
625:              
626:              // 	// 串口发送中断服务函数
627:              // 	if (TX1IF && TX1IE)
628:              // 	{
629:              // 		// 发送控制
630:              // 		if (TRMT1)
631:              // 		{
632:              // 			Uart_SendLogic();
633:              // 			// TXREG = TX_Buf[tx_cnt];
634:              // 			// tx_cnt++;
635:              // 			// if(tx_cnt >= tx_index)
636:              // 			// {
637:              // 			// 	tx_cnt = 0;
638:              // 			// 	TXIE = 0;
639:              // 			// }
640:              // 		}
641:              // 	}
642:              // #endif
643:              	// PA中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
644:              	// if(RACIF)
645:              	// {
646:              	// 	PORTA;		 //读取PORTA状态
647:              	// 	RACIF = 0; //清中断标志
648:              	// }
649:              
650:              	// PB中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
651:              	// if(RBIF)
652:              	// {
653:              	// 	PORTB;		//读取PORTB状态
654:              	// 	RBIF = 0; //清中断标志
655:              	// }
656:              }
---- C:\Users\汪强升\Desktop\ABM007_79F133(2)\ABM007_79F133\source\sensor.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                volatile BYTE Fbodysensor;
5:                
6:                v_uint8 u8stsBodySensor = 0;
7:                v_uint8 SEQbody = 0;
8:                v_uint16 CNTbody_h = 0;         /* 感应高电平计时 */
9:                v_uint16 CNTbody_l = 0;         /* 感应低电平计时 */
10:               v_uint16 BufCntAdd = 0;         /* 感应计时 */
11:               v_uint16 CNTbodyInTime = 0;     /* 感应到人计时 */
12:               v_uint16 CNTbodyExitTime = 0;   /* 感应到人离开计时 */
13:               
14:               void SensorKey(void);
15:               void SensorTime(void);
16:               void SensorJudge(void);
17:               void SensorControl(void);
18:               
19:               void GsensorLoop(void)
20:               {
21:                   SensorKey();
  0118    2122    CALL	0x122
  0119    120A    CLRB	0xA,4
  011A    118A    CLRB	0xA,3
22:                   SensorTime();
  011B    2123    CALL	0x123
  011C    120A    CLRB	0xA,4
  011D    118A    CLRB	0xA,3
23:                   SensorJudge();
  011E    2176    CALL	0x176
  011F    120A    CLRB	0xA,4
  0120    118A    CLRB	0xA,3
24:                   SensorControl();
  0121    295B    JP	0x15B
25:               }
26:               
27:               void SensorKey(void)
  0122    0008    RET
28:               {
29:               
30:               }
31:               
32:               /* 人体感应计时函数 */
33:               void SensorTime(void)
34:               {
35:                   if(Fbody == SET)
  0123    1C7A    SNZB	0x7A,0
  0124    2947    JP	0x147
36:                   {
37:                       FbodyEx5s = CLR;
  0125    12FA    CLRB	0x7A,5
38:                       CNTbodyExitTime = 0;
  0126    01A2    CLR	0x22
  0127    01A3    CLR	0x23
39:                       if(FlightLeave == CLR)  /* 检测到人有效时间 */
  0128    1979    SZB	0x79,2
  0129    2942    JP	0x142
40:                       {
41:                           if(++CNTbodyInTime >= BODY_ENTER_KEEP_60S)	/* 60s */
  012A    0AA4    INCR	0x24
  012B    1903    SZB	0x3,2
  012C    0AA5    INCR	0x25
  012D    3017    LDIA	0x17
  012E    0225    SUBA	0x25
  012F    3070    LDIA	0x70
  0130    1903    SZB	0x3,2
  0131    0224    SUBA	0x24
  0132    1C03    SNZB	0x3,0
  0133    293A    JP	0x13A
42:                           {
43:                               CNTbodyInTime = BODY_ENTER_KEEP_60S;
  0134    3070    LDIA	0x70
  0135    00A4    LD	0x24,A
  0136    3017    LDIA	0x17
  0137    00A5    LD	0x25,A
44:                               FbodyIn60s = SET;
  0138    15FA    SETB	0x7A,3
45:                           }
  0139    0008    RET
46:                           else if(CNTbodyInTime >= BODY_ENTER_KEEP_5S)		/* 5s */
  013A    3001    LDIA	0x1
  013B    0225    SUBA	0x25
  013C    30F4    LDIA	0xF4
  013D    1903    SZB	0x3,2
  013E    0224    SUBA	0x24
  013F    1803    SZB	0x3,0
47:                           {
48:                               FbodyIn5s = SET;
  0140    167A    SETB	0x7A,4
  0141    0008    RET
49:                           }
50:                       }
51:                       else
52:                       {
53:                           if(FbodyIn5s == CLR)    /* 未待满5s，时间清零 */
  0142    1A7A    SZB	0x7A,4
  0143    0008    RET
54:                           {
55:                               CNTbodyInTime = 0;
  0144    01A4    CLR	0x24
  0145    01A5    CLR	0x25
56:                           }
57:                       }
58:                   }
  0146    0008    RET
59:                   else
60:                   {
61:                       CNTbodyInTime = 0;
  0147    01A4    CLR	0x24
  0148    01A5    CLR	0x25
62:                       FbodyIn5s = CLR;
  0149    127A    CLRB	0x7A,4
63:                       FbodyIn60s = CLR;
  014A    11FA    CLRB	0x7A,3
64:                       if(++CNTbodyExitTime >= BODY_EXIT_KEEP_5S)
  014B    0AA2    INCR	0x22
  014C    1903    SZB	0x3,2
  014D    0AA3    INCR	0x23
  014E    3001    LDIA	0x1
  014F    0223    SUBA	0x23
  0150    30F4    LDIA	0xF4
  0151    1903    SZB	0x3,2
  0152    0222    SUBA	0x22
  0153    1C03    SNZB	0x3,0
  0154    0008    RET
65:                       {
66:                           CNTbodyExitTime = BODY_EXIT_KEEP_5S;
  0155    30F4    LDIA	0xF4
  0156    00A2    LD	0x22,A
  0157    3001    LDIA	0x1
  0158    00A3    LD	0x23,A
67:                           FbodyEx5s = SET;        /* 人离开5秒 */
  0159    16FA    SETB	0x7A,5
  015A    0008    RET
68:                       }
69:                   }
70:               }
71:               
72:               /* 人体感应判定函数 */
73:               void SensorJudge(void)
74:               {
75:                   switch (SEQbody)
  0176    29F3    JP	0x1F3
76:                   {
77:                       case 0:
78:                           Fbody = CLR;
  0177    107A    CLRB	0x7A,0
79:                           FlightLeave = CLR;
  0178    1179    CLRB	0x79,2
80:                           SEQbody = 1;
  0188    3001    LDIA	0x1
  0189    00BA    LD	0x3A,A
81:                           break;
  018A    0008    RET
82:               
83:                       /* 人离开确认 */
84:                       case 1:
85:                           Fbody = CLR;
  018B    107A    CLRB	0x7A,0
86:                           FlightLeave = CLR;
  018C    1179    CLRB	0x79,2
87:                           if(PIsensor == LOW)
  018D    1886    SZB	0x6,1
  018E    29A0    JP	0x1A0
88:                           {
89:                               if(++CNTbody_h >= SENSOR_TRG)
  018F    0AAA    INCR	0x2A
  0190    1903    SZB	0x3,2
  0191    0AAB    INCR	0x2B
  0192    3000    LDIA	0x0
  0193    022B    SUBA	0x2B
  0194    3003    LDIA	0x3
  0195    1903    SZB	0x3,2
  0196    022A    SUBA	0x2A
  0197    1C03    SNZB	0x3,0
  0198    0008    RET
90:                               {
91:                                   CNTbody_h = 0;
  0199    01AA    CLR	0x2A
  019A    01AB    CLR	0x2B
92:               					CNTbody_l = 0;
  019B    01A8    CLR	0x28
  019C    01A9    CLR	0x29
93:               					SEQbody = 2;
  019D    3002    LDIA	0x2
  019E    00BA    LD	0x3A,A
94:               					break;
  019F    0008    RET
95:                               }
96:                           }
97:                           else
98:                           {
99:                               CNTbody_h = 0;
  01A0    01AA    CLR	0x2A
  01A1    01AB    CLR	0x2B
  01A2    0008    RET
100:                          }
101:                          break;
102:              
103:                      /* 感应到人判定开始 */
104:                      case 2:
105:                          Fbody = CLR;
  01A3    107A    CLRB	0x7A,0
106:                          FlightLeave = CLR;
  01A4    1179    CLRB	0x79,2
107:                          if(PIsensor == LOW)
  01A5    1886    SZB	0x6,1
  01A6    297A    JP	0x17A
108:                          {
109:                              ++CNTbody_h;
  01A7    0AAA    INCR	0x2A
  01A8    1903    SZB	0x3,2
  01A9    0AAB    INCR	0x2B
110:                          }
  0179    2988    JP	0x188
111:                          else
112:                          {
113:                              if(++CNTbody_l >= SENSOR_ERROR)
  017A    0AA8    INCR	0x28
  017B    1903    SZB	0x3,2
  017C    0AA9    INCR	0x29
  017D    3000    LDIA	0x0
  017E    0229    SUBA	0x29
  017F    3006    LDIA	0x6
  0180    1903    SZB	0x3,2
  0181    0228    SUBA	0x28
  0182    1C03    SNZB	0x3,0
  0183    29AA    JP	0x1AA
114:                              {
115:                                  CNTbody_h = 0;
  0184    01AA    CLR	0x2A
  0185    01AB    CLR	0x2B
116:                                  CNTbody_l = 0;
  0186    01A8    CLR	0x28
  0187    01A9    CLR	0x29
117:                                  SEQbody = 1;
118:                                  break;
119:                              }
120:                          }
121:                          BufCntAdd = CNTbody_h +CNTbody_l;
  01AA    2205    CALL	0x205
  01AB    120A    CLRB	0xA,4
  01AC    118A    CLRB	0xA,3
122:                          if(BufCntAdd >= SENSOR_BODY_ENTER_X_0S)
  01AD    3000    LDIA	0x0
  01AE    0227    SUBA	0x27
  01AF    301E    LDIA	0x1E
  01B0    1903    SZB	0x3,2
  01B1    0226    SUBA	0x26
  01B2    1C03    SNZB	0x3,0
  01B3    0008    RET
123:                          {
124:                              SEQbody = 3;
  01B4    3003    LDIA	0x3
  01B5    00BA    LD	0x3A,A
125:                              break;
  01B6    0008    RET
126:                          }
127:                          break;
128:                      /* 感应到人确认 */
129:                      case 3:
130:                          Fbody = SET;
  01B7    147A    SETB	0x7A,0
131:                          FlightLeave = CLR;
  01B8    1179    CLRB	0x79,2
132:                          if(PIsensor == HIGH)
  01B9    1C86    SNZB	0x6,1
  01BA    29CC    JP	0x1CC
133:                          {
134:                              if(++CNTbody_l >= SENSOR_TRG)
  01BB    0AA8    INCR	0x28
  01BC    1903    SZB	0x3,2
  01BD    0AA9    INCR	0x29
  01BE    3000    LDIA	0x0
  01BF    0229    SUBA	0x29
  01C0    3003    LDIA	0x3
  01C1    1903    SZB	0x3,2
  01C2    0228    SUBA	0x28
  01C3    1C03    SNZB	0x3,0
  01C4    0008    RET
135:                              {
136:                                  CNTbody_h = 0;
  01C5    01AA    CLR	0x2A
  01C6    01AB    CLR	0x2B
137:                                  CNTbody_l = 0;
  01C7    01A8    CLR	0x28
  01C8    01A9    CLR	0x29
138:                                  SEQbody = 4;
  01C9    3004    LDIA	0x4
  01CA    00BA    LD	0x3A,A
139:                                  break;
  01CB    0008    RET
140:                              }
141:                          }
142:                          else
143:                          {
144:                              CNTbody_l = 0;
  01CC    01A8    CLR	0x28
  01CD    01A9    CLR	0x29
  01CE    0008    RET
145:                          }
146:                          break;
147:                      /* 人离开判定开始 */
148:                      case 4:
149:                          Fbody = SET;
  01CF    147A    SETB	0x7A,0
150:                          FlightLeave = SET;
  01D0    1579    SETB	0x79,2
151:                          if(PIsensor == LOW)
  01D1    1886    SZB	0x6,1
  01D2    29E2    JP	0x1E2
152:                          {
153:                              if(++CNTbody_h >= SENSOR_ERROR)
  01D3    0AAA    INCR	0x2A
  01D4    1903    SZB	0x3,2
  01D5    0AAB    INCR	0x2B
  01D6    3000    LDIA	0x0
  01D7    022B    SUBA	0x2B
  01D8    3006    LDIA	0x6
  01D9    1903    SZB	0x3,2
  01DA    022A    SUBA	0x2A
  01DB    1C03    SNZB	0x3,0
  01DC    29E5    JP	0x1E5
154:                              {
155:                                  CNTbody_h = 0;
  01DD    01AA    CLR	0x2A
  01DE    01AB    CLR	0x2B
156:                                  CNTbody_l = 0;
  01DF    01A8    CLR	0x28
  01E0    01A9    CLR	0x29
  01E1    29B4    JP	0x1B4
157:                                  SEQbody = 3;
158:                                  break;
159:                              }
160:                          }
161:                          else
162:                          {
163:                              ++CNTbody_l;
  01E2    0AA8    INCR	0x28
  01E3    1903    SZB	0x3,2
  01E4    0AA9    INCR	0x29
164:                          }
165:                          BufCntAdd = CNTbody_h +CNTbody_l;
  01E5    2205    CALL	0x205
  01E6    120A    CLRB	0xA,4
  01E7    118A    CLRB	0xA,3
166:                          if(BufCntAdd >= SENSOR_BODY_EXIT_X_0S)      /* 暂改为5s */
  01E8    3001    LDIA	0x1
  01E9    0227    SUBA	0x27
  01EA    30F4    LDIA	0xF4
  01EB    1903    SZB	0x3,2
  01EC    0226    SUBA	0x26
  01ED    1C03    SNZB	0x3,0
  01EE    0008    RET
  01EF    2988    JP	0x188
167:                          {
168:                              SEQbody = 1;
169:                              break;
170:                          }
171:                          break;
172:                      default:
173:                          SEQbody = 0;
  01F0    01BA    CLR	0x3A
174:                          FlightLeave = CLR;
  01F1    1179    CLRB	0x79,2
175:                          break;
  01F2    0008    RET
  01F3    083A    LD	A,0x3A
  01F4    3A00    XORIA	0x0
  01F5    1903    SZB	0x3,2
  01F6    2977    JP	0x177
  01F7    3A01    XORIA	0x1
  01F8    1903    SZB	0x3,2
  01F9    298B    JP	0x18B
  01FA    3A03    XORIA	0x3
  01FB    1903    SZB	0x3,2
  01FC    29A3    JP	0x1A3
  01FD    3A01    XORIA	0x1
  01FE    1903    SZB	0x3,2
  01FF    29B7    JP	0x1B7
  0200    3A07    XORIA	0x7
  0201    1903    SZB	0x3,2
  0202    29CF    JP	0x1CF
  0203    29F0    JP	0x1F0
  0204    0008    RET
176:                  }
177:              }
178:              
179:              void SensorControl(void)
180:              {
181:                  FbodyEnter = CLR;
  015B    10FA    CLRB	0x7A,1
182:                  FbodyExit = CLR;
  015C    117A    CLRB	0x7A,2
183:                  if(Fbufbody != Fbody)
  015D    1C7A    SNZB	0x7A,0
  015E    2961    JP	0x161
  015F    3001    LDIA	0x1
  0160    2962    JP	0x162
  0161    3000    LDIA	0x0
  0162    00F2    LD	0x72,A
  0163    1F7A    SNZB	0x7A,6
  0164    2967    JP	0x167
  0165    3001    LDIA	0x1
  0166    2968    JP	0x168
  0167    3000    LDIA	0x0
  0168    0672    XORA	0x72
  0169    1903    SZB	0x3,2
  016A    0008    RET
184:                  {
185:                      if(Fbody == SET)
  016B    1C7A    SNZB	0x7A,0
  016C    296F    JP	0x16F
186:                      {
187:                          FbodyEnter = SET;   /* 感应到人瞬间 */
  016D    14FA    SETB	0x7A,1
188:                      }
  016E    2970    JP	0x170
189:                      else
190:                      {
191:                          FbodyExit = SET;    /* 人离开瞬间 */
  016F    157A    SETB	0x7A,2
192:                      }
193:                      Fbufbody = Fbody;
  0170    1C7A    SNZB	0x7A,0
  0171    2974    JP	0x174
  0172    177A    SETB	0x7A,6
  0173    0008    RET
  0174    137A    CLRB	0x7A,6
  0175    0008    RET
194:                  }
195:              }
196:              
---- C:\Users\汪强升\Desktop\ABM007_79F133(2)\ABM007_79F133\source\light.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                volatile BYTE FledBits01;
5:                
6:                v_uint16 CNTbreath_Led;
7:                v_uint16 CNTbreath_Led1;
8:                v_uint16 CNTbreath_Led2;
9:                v_uint16 CNTbreath_Led3;
10:               
11:               void LED_Key(void);
12:               void LED_Judge(void);
13:               void LED_Con(void);
14:               void LED_Time(void);
15:               
16:               void GledLoop(void)
17:               {
18:               	LED_Time();
  020E    2219    CALL	0x219
  020F    120A    CLRB	0xA,4
  0210    118A    CLRB	0xA,3
19:               	LED_Key();
  0211    2218    CALL	0x218
  0212    120A    CLRB	0xA,4
  0213    118A    CLRB	0xA,3
20:               	LED_Judge();
  0214    22BD    CALL	0x2BD
  0215    120A    CLRB	0xA,4
  0216    118A    CLRB	0xA,3
21:               	LED_Con();
  0217    2A1C    JP	0x21C
22:               }
23:               
24:               void LED_Key(void)
  0218    0008    RET
25:               {
26:               	// switch(SiCon_SETkey)
27:               	// {	
28:               	// 	case KEY_LIGHT:
29:               	// 		Flight = ~Flight;
30:               	// 		if(Flight == SET)
31:               	// 		{
32:               	// 			GbuzOutSet(2);
33:               	// 		}
34:               	// 		else
35:               	// 		{
36:               	// 			GbuzOutSet(1);
37:               	// 		}
38:               	// 		break;
39:               	// 	default:
40:               			
41:               	// 		break;
42:               	// }
43:               }
44:               
45:               void LED_Time(void)
46:               {
47:               	if(F1min_lgt == SET)
  0219    1841    SZB	0x41,0
48:               	{
49:               		F1min_lgt = CLR;
  021A    1041    CLRB	0x41,0
  021B    0008    RET
50:               	}
51:               }
52:               
53:               void LED_Judge(void)
54:               {
55:               	if(Fbody == SET)	/* 感应到人开启 */
  02BD    1C7A    SNZB	0x7A,0
  02BE    2AC3    JP	0x2C3
56:               	{
57:               		Flight = SET;
  02BF    1479    SETB	0x79,0
58:               		if(FbodyIn5s == CLR)	/* 检测到人5秒之内 */
  02C0    1E7A    SNZB	0x7A,4
59:               		{
60:               			if(FlightLeave == SET)	/* 离开状态，熄灭指示灯 */
  02C1    1D79    SNZB	0x79,2
  02C2    0008    RET
61:               			{
62:               				Flight = CLR;
  02C3    1079    CLRB	0x79,0
  02C4    0008    RET
63:               			}
64:               		}
65:               	}
66:               	else
67:               	{
68:               		// if(Fbuflight == SET)
69:               		// {
70:               		// 	Flight = SET;	/* 离开5s内 */
71:               		// 	if(FbodyEx5s == SET)
72:               		// 	{
73:               		// 		Flight = CLR;
74:               		// 		Fbuflight = CLR;
75:               		// 	}
76:               		// }
77:               		// else
78:               		// {
79:               			Flight = CLR;
80:               		// }
81:               	}
82:               }
83:               
84:               void LED_Con(void)
85:               {
86:               	// POlight	= Flight;
87:               	/* 呼吸灯频率 */
88:               	if (Flight == SET)
  021C    1C79    SNZB	0x79,0
  021D    2AB6    JP	0x2B6
89:               	{
90:               		if (FbreathDir == CLR)
  021E    19F9    SZB	0x79,3
  021F    2A6C    JP	0x26C
91:               		{
92:               			if (CNTbreath_Led2 >= 80)	/* 亮度降低 */
  0220    3000    LDIA	0x0
  0221    0277    SUBA	0x77
  0222    3050    LDIA	0x50
  0223    1903    SZB	0x3,2
  0224    0276    SUBA	0x76
  0225    1C03    SNZB	0x3,0
  0226    2A38    JP	0x238
93:               			{
94:               				CNTbreath_Led2 = 80;
  0227    3050    LDIA	0x50
  0228    00F6    LD	0x76,A
  0229    01F7    CLR	0x77
95:               				if (++CNTbreath_Led3 > 10)	/* 100ms，min */
  022A    0AB2    INCR	0x32
  022B    1903    SZB	0x3,2
  022C    0AB3    INCR	0x33
  022D    3000    LDIA	0x0
  022E    0233    SUBA	0x33
  022F    300B    LDIA	0xB
  0230    1903    SZB	0x3,2
  0231    0232    SUBA	0x32
  0232    1C03    SNZB	0x3,0
  0233    0008    RET
96:               				{
97:               					FbreathDir = SET;
  0234    15F9    SETB	0x79,3
98:               					CNTbreath_Led3 = 0;
  0235    01B2    CLR	0x32
  0236    01B3    CLR	0x33
  0237    0008    RET
99:               				}
100:              			}
101:              			else if (CNTbreath_Led2 > 45)	/* 35*4*10=1050ms */
  0238    3000    LDIA	0x0
  0239    0277    SUBA	0x77
  023A    302E    LDIA	0x2E
  023B    1903    SZB	0x3,2
  023C    0276    SUBA	0x76
  023D    1C03    SNZB	0x3,0
  023E    2A57    JP	0x257
102:              			{
103:              				if (++CNTbreath_Led1 >= 3)
  023F    22CB    CALL	0x2CB
  0240    120A    CLRB	0xA,4
  0241    118A    CLRB	0xA,3
  0242    2A4D    JP	0x24D
104:              				{
105:              					CNTbreath_Led1 = 0;
  0251    01B4    CLR	0x34
  0252    01B5    CLR	0x35
106:              					CNTbreath_Led2++;
  0253    0AF6    INCR	0x76
  0254    1903    SZB	0x3,2
  0255    0AF7    INCR	0x77
  0256    0008    RET
107:              				}
108:              			}
109:              			else if (CNTbreath_Led2 > 30)	/* 15*8*10 = 1200ms */
  0257    3000    LDIA	0x0
  0258    0277    SUBA	0x77
  0259    301F    LDIA	0x1F
  025A    1903    SZB	0x3,2
  025B    0276    SUBA	0x76
  025C    1803    SZB	0x3,0
  025D    2A43    JP	0x243
110:              			{
111:              				if (++CNTbreath_Led1 >= 8)
  0243    22C5    CALL	0x2C5
  0244    120A    CLRB	0xA,4
  0245    118A    CLRB	0xA,3
  0246    2A4D    JP	0x24D
112:              				{
113:              					CNTbreath_Led1 = 0;
114:              					CNTbreath_Led2++;
115:              				}
116:              			}
117:              			else if (CNTbreath_Led2 > 10)	/* 1000ms */
  025E    3000    LDIA	0x0
  025F    0277    SUBA	0x77
  0260    300B    LDIA	0xB
  0261    1903    SZB	0x3,2
  0262    0276    SUBA	0x76
  0263    1803    SZB	0x3,0
  0264    2A47    JP	0x247
118:              			{
119:              				if (++CNTbreath_Led1 >= 5)
  0247    0AB4    INCR	0x34
  0248    1903    SZB	0x3,2
  0249    0AB5    INCR	0x35
  024A    3000    LDIA	0x0
  024B    0235    SUBA	0x35
  024C    3005    LDIA	0x5
  024D    1903    SZB	0x3,2
  024E    0234    SUBA	0x34
  024F    1C03    SNZB	0x3,0
  0250    0008    RET
120:              				{
121:              					CNTbreath_Led1 = 0;
122:              					CNTbreath_Led2++;
123:              				}
124:              			}
125:              			else
126:              			{
127:              				if (++CNTbreath_Led1 >= 11)	/* (11-5)*10=600ms，max */
  0265    0AB4    INCR	0x34
  0266    1903    SZB	0x3,2
  0267    0AB5    INCR	0x35
  0268    3000    LDIA	0x0
  0269    0235    SUBA	0x35
  026A    300B    LDIA	0xB
  026B    2A4D    JP	0x24D
128:              				{
129:              					CNTbreath_Led1 = 0;
130:              					CNTbreath_Led2++;
131:              				}
132:              			}
133:              		}
134:              		else
135:              		{
136:              			if (CNTbreath_Led2 < 5)	/* max */
  026C    3000    LDIA	0x0
  026D    0277    SUBA	0x77
  026E    3005    LDIA	0x5
  026F    1903    SZB	0x3,2
  0270    0276    SUBA	0x76
  0271    1803    SZB	0x3,0
  0272    2A78    JP	0x278
137:              			{
138:              				CNTbreath_Led2 = 5;
  0273    3005    LDIA	0x5
  0274    00F6    LD	0x76,A
  0275    01F7    CLR	0x77
139:              				FbreathDir = CLR;
  0276    11F9    CLRB	0x79,3
140:              			}
  0277    0008    RET
141:              			else if (CNTbreath_Led2 < 10)
  0278    3000    LDIA	0x0
  0279    0277    SUBA	0x77
  027A    300A    LDIA	0xA
  027B    1903    SZB	0x3,2
  027C    0276    SUBA	0x76
  027D    1803    SZB	0x3,0
  027E    2A9D    JP	0x29D
142:              			{
143:              				if (++CNTbreath_Led1 >= 6)	/* 600ms */
144:              				{
145:              					CNTbreath_Led1 = 0;
  0294    01B4    CLR	0x34
  0295    01B5    CLR	0x35
146:              					CNTbreath_Led2--;
  0296    3001    LDIA	0x1
  0297    02F6    SUBR	0x76
  0298    3000    LDIA	0x0
  0299    1C03    SNZB	0x3,0
  029A    03F7    DECR	0x77
  029B    02F7    SUBR	0x77
  029C    0008    RET
147:              				}
148:              			}
149:              			else if (CNTbreath_Led2 < 40)
  029D    3000    LDIA	0x0
  029E    0277    SUBA	0x77
  029F    3028    LDIA	0x28
  02A0    1903    SZB	0x3,2
  02A1    0276    SUBA	0x76
  02A2    1C03    SNZB	0x3,0
  02A3    2A7F    JP	0x27F
150:              			{
151:              				if (++CNTbreath_Led1 >= 6)	/* 1200ms */
  027F    0AB4    INCR	0x34
  0280    1903    SZB	0x3,2
  0281    0AB5    INCR	0x35
  0282    3000    LDIA	0x0
  0283    0235    SUBA	0x35
  0284    3006    LDIA	0x6
  0285    2A90    JP	0x290
152:              				{
153:              					CNTbreath_Led1 = 0;
154:              					CNTbreath_Led2--;
155:              				}
156:              			}
157:              			else if (CNTbreath_Led2 < 60)
  02A4    3000    LDIA	0x0
  02A5    0277    SUBA	0x77
  02A6    303C    LDIA	0x3C
  02A7    1903    SZB	0x3,2
  02A8    0276    SUBA	0x76
  02A9    1C03    SNZB	0x3,0
  02AA    2A86    JP	0x286
158:              			{
159:              				if (++CNTbreath_Led1 >= 8)	/* 800ms */
  0286    22C5    CALL	0x2C5
  0287    120A    CLRB	0xA,4
  0288    118A    CLRB	0xA,3
  0289    2A90    JP	0x290
160:              				{
161:              					CNTbreath_Led1 = 0;
162:              					CNTbreath_Led2--;
163:              				}
164:              			}
165:              			else if (CNTbreath_Led2 < 70)
  02AB    3000    LDIA	0x0
  02AC    0277    SUBA	0x77
  02AD    3046    LDIA	0x46
  02AE    1903    SZB	0x3,2
  02AF    0276    SUBA	0x76
  02B0    1C03    SNZB	0x3,0
  02B1    2A8A    JP	0x28A
166:              			{
167:              				if (++CNTbreath_Led1 >= 4)	/* 800ms */
  028A    0AB4    INCR	0x34
  028B    1903    SZB	0x3,2
  028C    0AB5    INCR	0x35
  028D    3000    LDIA	0x0
  028E    0235    SUBA	0x35
  028F    3004    LDIA	0x4
  0290    1903    SZB	0x3,2
  0291    0234    SUBA	0x34
  0292    1C03    SNZB	0x3,0
  0293    0008    RET
168:              				{
169:              					CNTbreath_Led1 = 0;
170:              					CNTbreath_Led2--;
171:              				}
172:              			}
173:              			else
174:              			{
175:              				if (++CNTbreath_Led1 >= 3)	/* 600ms，min */
  02B2    22CB    CALL	0x2CB
  02B3    120A    CLRB	0xA,4
  02B4    118A    CLRB	0xA,3
  02B5    2A90    JP	0x290
176:              				{
177:              					CNTbreath_Led1 = 0;
178:              					CNTbreath_Led2--;
179:              				}
180:              			}
181:              		}
182:              	}
183:              	else
184:              	{
185:              		CNTbreath_Led1 = 0;
  02B6    01B4    CLR	0x34
  02B7    01B5    CLR	0x35
186:              		CNTbreath_Led2 = 0;
  02B8    01F6    CLR	0x76
  02B9    01F7    CLR	0x77
187:              		CNTbreath_Led3 = 0;
  02BA    01B2    CLR	0x32
  02BB    01B3    CLR	0x33
  02BC    2A76    JP	0x276
188:              		FbreathDir = CLR;
189:              	}
190:              }
191:              
192:              void INT_LED_SHOW(void)
193:              {
194:              	if(Flight == SET)
  0357    1C79    SNZB	0x79,0
  0358    0008    RET
195:              	{
196:              		if (++CNTbreath_Led == 80)
  0359    0AB6    INCR	0x36
  035A    1903    SZB	0x3,2
  035B    0AB7    INCR	0x37
  035C    3050    LDIA	0x50
  035D    0636    XORA	0x36
  035E    0437    ORA	0x37
  035F    1D03    SNZB	0x3,2
  0360    2B64    JP	0x364
197:              		{
198:              			CNTbreath_Led = 0;
  0361    01B6    CLR	0x36
  0362    01B7    CLR	0x37
199:              			POlight = OFF;
  0363    1285    CLRB	0x5,5
200:              		}
201:              		if (CNTbreath_Led >= CNTbreath_Led2)
  0364    0877    LD	A,0x77
  0365    0237    SUBA	0x37
  0366    1D03    SNZB	0x3,2
  0367    2B6A    JP	0x36A
  0368    0876    LD	A,0x76
  0369    0236    SUBA	0x36
  036A    1C03    SNZB	0x3,0
  036B    2B6E    JP	0x36E
202:              		{
203:              			POlight = ON;
  036C    1685    SETB	0x5,5
204:              		}
  036D    0008    RET
205:              		else
206:              		{
207:              			POlight = OFF;
  036E    1285    CLRB	0x5,5
  036F    0008    RET
208:              		}
209:              	}
210:              }
---- C:\Users\汪强升\Desktop\ABM007_79F133(2)\ABM007_79F133\source\flush.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                volatile BYTE Fflush1;
5:                
6:                enum{
7:                    FLUSH_INIT_0 = 0,
8:                    FLUSH_INIT_1,
9:                    FLUSH_INIT_2,
10:                   FLUSH_BIG_0,
11:                   FLUSH_BIG_1,
12:                   FLUSH_BIG_2,
13:                   FLUSH_SML_0,
14:                   FLUSH_SML_1,
15:                   FLUSH_SML_2,
16:                   FLUSH_END_0,
17:                   FLUSH_END_1,
18:                   FLUSH_END_2,
19:               };
20:               
21:               v_uint8 SEQflsuh = 0;
22:               v_uint16 CNTflush = 0;  /* 冲水计时 */
23:               
24:               void FlushTime(void);
25:               void FlushJudge(void);
26:               void FlushCon(void);
27:               
28:               void GflushLoop(void)
29:               {
30:                   FlushTime();
  001F    2026    CALL	0x26
  0020    120A    CLRB	0xA,4
  0021    118A    CLRB	0xA,3
31:                   FlushJudge();
  0022    20E7    CALL	0xE7
  0023    120A    CLRB	0xA,4
  0024    118A    CLRB	0xA,3
32:                   FlushCon();
  0025    2827    JP	0x27
33:               }
34:               
35:               void FlushTime(void)
  0026    0008    RET
36:               {
37:               
38:               }
39:               void FlushJudge(void)
40:               {
41:                   /* 请求判定 */
42:               #if DUBLE_FLUSH_MODE
43:                   if(FbodyIn60s == SET)   /* 感应到60秒以上，大冲请求置位 */
  00E7    1DFA    SNZB	0x7A,3
  00E8    28EC    JP	0xEC
44:                   {
45:                       YKfls_Big = SET;
  00E9    1478    SETB	0x78,0
46:                       YKfls_Sml = CLR;
  00EA    1178    CLRB	0x78,2
47:                   }
  00EB    28F2    JP	0xF2
48:                   else if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
  00EC    1E7A    SNZB	0x7A,4
  00ED    28F0    JP	0xF0
49:                   {
50:                       YKfls_Sml = SET;
  00EE    1578    SETB	0x78,2
  00EF    28F1    JP	0xF1
51:                       YKfls_Big = CLR;
52:                   }
53:                   else
54:                   {
55:                       YKfls_Sml = CLR;
  00F0    1178    CLRB	0x78,2
56:                       YKfls_Big = CLR;
  00F1    1078    CLRB	0x78,0
57:                   }
58:               #else
59:                   if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
60:                   {
61:                       // YKfls_Sml = SET;
62:                       // YKfls_Big = CLR;
63:                       YKfls_Sml = CLR;
64:                       YKfls_Big = SET;
65:                   }
66:                   else
67:                   {
68:                       YKfls_Sml = CLR;
69:                       YKfls_Big = CLR;
70:                   }
71:               #endif
72:                   /*********************************************/
73:               	/*	自动冲水判断	*/
74:               	if (FbodyExit == SET)	/* 离开冲水 */
  00F2    197A    SZB	0x7A,2
75:               	{
76:                       Flush_AutoLeaveWait = SET;
  00F3    17F8    SETB	0x78,7
77:               	}
78:               	if (Flush_AutoLeaveWait == SET) /*	离开自动冲水	*/
  00F4    1FF8    SNZB	0x78,7
  00F5    0008    RET
79:               	{
80:               		if (f_STSflush == SET)
  00F6    1F78    SNZB	0x78,6
  00F7    28FB    JP	0xFB
81:               		{
82:                           YKfls_Sml = CLR;
  00F8    1178    CLRB	0x78,2
83:                           YKfls_Big = CLR;    /* 正在冲水，请求清除 */
  00F9    1078    CLRB	0x78,0
84:               			return;
  00FA    0008    RET
85:               		}
86:               		Flush_AutoLeaveWait = CLR;
  00FB    13F8    CLRB	0x78,7
87:                       if(YKfls_Big == SET)
  00FC    1C78    SNZB	0x78,0
  00FD    2901    JP	0x101
88:                       {
89:                           YKfls_Big = CLR;
  00FE    1078    CLRB	0x78,0
90:                           OKfls_Big = SET;
  00FF    14F8    SETB	0x78,1
91:                           return;
  0100    0008    RET
92:                       }
93:               		if(YKfls_Sml == SET)
  0101    1D78    SNZB	0x78,2
  0102    0008    RET
94:                       {
95:                           YKfls_Sml = CLR;
  0103    1178    CLRB	0x78,2
96:                           OKfls_Sml = SET;
  0104    15F8    SETB	0x78,3
  0105    0008    RET
97:                       }
98:               		return;
99:               	}
100:              	/*	自动冲水判断	*/
101:              	/******************************************/
102:              }
103:              
104:              /* 主阀气泵控制函数 */
105:              void FlushCon(void)
106:              {
107:                  switch (SEQflsuh)
  0027    28C3    JP	0xC3
108:                  {
109:                      case FLUSH_INIT_0:
110:                          f_STSflush = CLR;
  0028    1378    CLRB	0x78,6
111:                          POairPump = OFF;
  0029    1105    CLRB	0x5,2
112:                          POmainValue = OFF;
  002A    1205    CLRB	0x5,4
113:                          if((OKfls_Big == SET) || (OKfls_Sml == SET))
  002B    18F8    SZB	0x78,1
  002C    282F    JP	0x2F
  002D    1DF8    SNZB	0x78,3
  002E    0008    RET
114:                          {
115:                              SEQflsuh = FLUSH_INIT_1;
  002F    3001    LDIA	0x1
  0030    2832    JP	0x32
116:                              CNTflush = 0;
  0033    01AC    CLR	0x2C
  0034    01AD    CLR	0x2D
  0035    0008    RET
117:                          }
118:                          break;
119:                      case FLUSH_INIT_1:
120:                          f_STSflush = SET;
  0036    1778    SETB	0x78,6
121:                          POairPump = OFF;
  0037    1105    CLRB	0x5,2
122:                          POmainValue = OFF;
  0038    1205    CLRB	0x5,4
123:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  0039    187A    SZB	0x7A,0
  003A    2831    JP	0x31
124:                          {
125:                              SEQflsuh = FLUSH_END_0;
  0031    3009    LDIA	0x9
  0032    00BC    LD	0x3C,A
126:                              CNTflush = 0;
127:                              break;
128:                          }
129:                          if(++CNTflush >= 5)
  003B    0AAC    INCR	0x2C
  003C    1903    SZB	0x3,2
  003D    0AAD    INCR	0x2D
  003E    3000    LDIA	0x0
  003F    022D    SUBA	0x2D
  0040    3005    LDIA	0x5
  0041    1903    SZB	0x3,2
  0042    022C    SUBA	0x2C
  0043    1C03    SNZB	0x3,0
  0044    0008    RET
130:                          {
131:                              CNTflush = 0;
  0045    01AC    CLR	0x2C
  0046    01AD    CLR	0x2D
132:                              SEQflsuh = FLUSH_INIT_2;
  0047    3002    LDIA	0x2
  0048    00BC    LD	0x3C,A
  0049    0008    RET
133:                          }
134:                          break;
135:                      case FLUSH_INIT_2:
136:                          f_STSflush = SET;
  004A    1778    SETB	0x78,6
137:                          POairPump = OFF;        /* 冲水关闭 */
  004B    1105    CLRB	0x5,2
138:                          POmainValue = OFF;      /* 冲水通道1 */
  004C    1205    CLRB	0x5,4
139:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  004D    187A    SZB	0x7A,0
  004E    2831    JP	0x31
140:                          {
141:                              SEQflsuh = FLUSH_END_0;
142:                              CNTflush = 0;
143:                              break;
144:                          }
145:              
146:                          if(OKfls_Big == SET)
  004F    1CF8    SNZB	0x78,1
  0050    2854    JP	0x54
147:                          {
148:                              SEQflsuh = FLUSH_BIG_0;
  0051    3003    LDIA	0x3
  0052    00BC    LD	0x3C,A
149:                          }
  0053    0008    RET
150:                          else if(OKfls_Sml == SET)
  0054    1DF8    SNZB	0x78,3
  0055    0008    RET
151:                          {
152:                              SEQflsuh = FLUSH_SML_0;
  0056    3006    LDIA	0x6
  0057    00BC    LD	0x3C,A
  0058    0008    RET
153:                          }
154:                          break;
155:                      case FLUSH_BIG_0:   /* 大冲阶段 */
156:                          f_STSflush = SET;
157:                          POairPump = OFF;        /* 大冲先开电磁阀换大冲，后开气泵冲水 */
158:                          POmainValue = ON;       /* 切换通道2 */     /* 冲水通道2 */
159:                          if(++CNTflush >= 10)    /* 延迟100ms后打开气泵冲水 */
  0059    210F    CALL	0x10F
  005A    120A    CLRB	0xA,4
  005B    118A    CLRB	0xA,3
  005C    1903    SZB	0x3,2
  005D    022C    SUBA	0x2C
  005E    1C03    SNZB	0x3,0
  005F    0008    RET
160:                          {
161:                              CNTflush = 0;
  0060    01AC    CLR	0x2C
  0061    01AD    CLR	0x2D
162:                              SEQflsuh = FLUSH_BIG_1;
  0062    3004    LDIA	0x4
  0063    00BC    LD	0x3C,A
  0064    0008    RET
163:                          }
164:                          break;
165:                      case FLUSH_BIG_1:
166:                          f_STSflush = SET;
  0065    1778    SETB	0x78,6
167:                          POairPump = ON;
  0066    1505    SETB	0x5,2
168:                          POmainValue = ON;
  0067    1605    SETB	0x5,4
169:              #if ABM007_FLUSH_2
170:                          if(++CNTflush >= 100)   /* 冲水1s */
  0068    0AAC    INCR	0x2C
  0069    1903    SZB	0x3,2
  006A    0AAD    INCR	0x2D
  006B    3000    LDIA	0x0
  006C    022D    SUBA	0x2D
  006D    3064    LDIA	0x64
  006E    1903    SZB	0x3,2
  006F    022C    SUBA	0x2C
  0070    1C03    SNZB	0x3,0
  0071    0008    RET
171:                          {
172:                              CNTflush = 0;
  0072    01AC    CLR	0x2C
  0073    01AD    CLR	0x2D
173:                              SEQflsuh = FLUSH_BIG_2;
  0074    3005    LDIA	0x5
  0075    00BC    LD	0x3C,A
  0076    0008    RET
174:                          }
175:              #else
176:                          if(++CNTflush >= 200)   /* 冲水2s */
177:                          {
178:                              CNTflush = 0;
179:                              SEQflsuh = FLUSH_BIG_2;
180:                          }
181:              #endif
182:                          break;
183:                      case FLUSH_BIG_2:
184:                          f_STSflush = SET;
185:                          POairPump = OFF;        /* 关气泵，停止冲水 */
186:                          POmainValue = SET;      /* 大冲先关气泵停止冲水，后关主阀 */    /* 冲水通道2 */
187:                          if(++CNTflush >= 10)
  0077    210F    CALL	0x10F
  0078    120A    CLRB	0xA,4
  0079    118A    CLRB	0xA,3
  007A    1903    SZB	0x3,2
  007B    022C    SUBA	0x2C
  007C    1C03    SNZB	0x3,0
  007D    0008    RET
188:                          {
189:                              CNTflush = 0;
  007E    01AC    CLR	0x2C
  007F    01AD    CLR	0x2D
190:                              SEQflsuh = FLUSH_END_0;
  0080    3009    LDIA	0x9
  0081    00BC    LD	0x3C,A
  0082    0008    RET
191:                          }
192:                          break;
193:              
194:                      case FLUSH_SML_0:           /* 小冲阶段 */
195:                          f_STSflush = SET;
196:                          POairPump = OFF;        /* 小冲关闭电磁阀 */
197:                          POmainValue = OFF;      /* 冲水通道1 */
198:                          if(++CNTflush >= 5)
  0083    2106    CALL	0x106
  0084    120A    CLRB	0xA,4
  0085    118A    CLRB	0xA,3
  0086    1903    SZB	0x3,2
  0087    022C    SUBA	0x2C
  0088    1C03    SNZB	0x3,0
  0089    0008    RET
199:                          {
200:                              CNTflush = 0;
  008A    01AC    CLR	0x2C
  008B    01AD    CLR	0x2D
201:                              SEQflsuh = FLUSH_SML_1;
  008C    3007    LDIA	0x7
  008D    00BC    LD	0x3C,A
  008E    0008    RET
202:                          }
203:                          break;
204:                      case FLUSH_SML_1:
205:                          f_STSflush = SET;
  008F    1778    SETB	0x78,6
206:                          POairPump = ON;         /* 冲水 */
  0090    1505    SETB	0x5,2
207:                          POmainValue = OFF;      /* 冲水通道1 */
  0091    1205    CLRB	0x5,4
208:                          if(++CNTflush >= 200)
  0092    0AAC    INCR	0x2C
  0093    1903    SZB	0x3,2
  0094    0AAD    INCR	0x2D
  0095    3000    LDIA	0x0
  0096    022D    SUBA	0x2D
  0097    30C8    LDIA	0xC8
  0098    1903    SZB	0x3,2
  0099    022C    SUBA	0x2C
  009A    1C03    SNZB	0x3,0
  009B    0008    RET
209:                          {
210:                              CNTflush = 0;
  009C    01AC    CLR	0x2C
  009D    01AD    CLR	0x2D
211:                              SEQflsuh = FLUSH_SML_2;
  009E    3008    LDIA	0x8
  009F    00BC    LD	0x3C,A
  00A0    0008    RET
212:                          }
213:                          break;
214:                      case FLUSH_SML_2:
215:                          f_STSflush = SET;
216:                          POairPump = OFF;        /* 关气泵，停止冲水 */
217:                          POmainValue = OFF;      /* 冲水通道1 */
218:                          if(++CNTflush >= 5)
  00A1    2106    CALL	0x106
  00A2    120A    CLRB	0xA,4
  00A3    118A    CLRB	0xA,3
  00A4    287A    JP	0x7A
219:                          {
220:                              CNTflush = 0;
221:                              SEQflsuh = FLUSH_END_0;
222:                          }
223:                          break;
224:              
225:                      case FLUSH_END_0:
226:                          f_STSflush = SET;
227:                          POairPump = OFF;        /* 停止冲水 */
228:                          POmainValue = OFF;      /* 返回通道1 */
229:                          if(++CNTflush >= 5)
  00A5    2106    CALL	0x106
  00A6    120A    CLRB	0xA,4
  00A7    118A    CLRB	0xA,3
  00A8    1903    SZB	0x3,2
  00A9    022C    SUBA	0x2C
  00AA    1C03    SNZB	0x3,0
  00AB    0008    RET
230:                          {
231:                              CNTflush = 0;
  00AC    01AC    CLR	0x2C
  00AD    01AD    CLR	0x2D
232:                              SEQflsuh = FLUSH_END_1;
  00AE    300A    LDIA	0xA
  00AF    00BC    LD	0x3C,A
  00B0    0008    RET
233:                          }
234:                          break;
235:                      case FLUSH_END_1:
236:                          f_STSflush = CLR;
  00B1    1378    CLRB	0x78,6
237:                          POairPump = OFF;
  00B2    1105    CLRB	0x5,2
238:                          POmainValue = OFF;
  00B3    1205    CLRB	0x5,4
239:                          SEQflsuh = FLUSH_INIT_0;
  00B4    01BC    CLR	0x3C
240:                          CNTflush = 0;
  00B5    01AC    CLR	0x2C
  00B6    01AD    CLR	0x2D
241:                          OKfls_Big = CLR;
  00B7    10F8    CLRB	0x78,1
242:                          OKfls_Sml = CLR;
  00B8    11F8    CLRB	0x78,3
243:                          break;
  00B9    0008    RET
244:                      default:
245:                          f_STSflush = CLR;
  00BA    1378    CLRB	0x78,6
246:                          POairPump = OFF;
  00BB    1105    CLRB	0x5,2
247:                          POmainValue = OFF;
  00BC    1205    CLRB	0x5,4
248:                          OKfls_Big = CLR;
  00BD    10F8    CLRB	0x78,1
249:                          OKfls_Sml = CLR;
  00BE    11F8    CLRB	0x78,3
250:                          SEQflsuh = FLUSH_INIT_0;
  00BF    01BC    CLR	0x3C
251:                          CNTflush = 0;
  00C0    01AC    CLR	0x2C
  00C1    01AD    CLR	0x2D
252:                          break;
  00C2    0008    RET
  00C3    083C    LD	A,0x3C
  00C4    3A00    XORIA	0x0
  00C5    1903    SZB	0x3,2
  00C6    2828    JP	0x28
  00C7    3A01    XORIA	0x1
  00C8    1903    SZB	0x3,2
  00C9    2836    JP	0x36
  00CA    3A03    XORIA	0x3
  00CB    1903    SZB	0x3,2
  00CC    284A    JP	0x4A
  00CD    3A01    XORIA	0x1
  00CE    1903    SZB	0x3,2
  00CF    2859    JP	0x59
  00D0    3A07    XORIA	0x7
  00D1    1903    SZB	0x3,2
  00D2    2865    JP	0x65
  00D3    3A01    XORIA	0x1
  00D4    1903    SZB	0x3,2
  00D5    2877    JP	0x77
  00D6    3A03    XORIA	0x3
  00D7    1903    SZB	0x3,2
  00D8    2883    JP	0x83
  00D9    3A01    XORIA	0x1
  00DA    1903    SZB	0x3,2
  00DB    288F    JP	0x8F
  00DC    3A0F    XORIA	0xF
  00DD    1903    SZB	0x3,2
  00DE    28A1    JP	0xA1
  00DF    3A01    XORIA	0x1
  00E0    1903    SZB	0x3,2
  00E1    28A5    JP	0xA5
  00E2    3A03    XORIA	0x3
  00E3    1903    SZB	0x3,2
  00E4    28B1    JP	0xB1
  00E5    28BA    JP	0xBA
  00E6    0008    RET
253:                  }
254:              }
255:              
256:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    3020    LDIA	0x20
  0010    01F6    CLR	0x76
  0011    01F7    CLR	0x77
  0012    01F8    CLR	0x78
  0013    01F9    CLR	0x79
  0014    01FA    CLR	0x7A
  0015    1383    CLRB	0x3,7
  0016    0084    LD	0x4,A
  0017    3044    LDIA	0x44
  0018    120A    CLRB	0xA,4
  0019    118A    CLRB	0xA,3
  001A    23D7    CALL	0x3D7
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    2B34    JP	0x334
---- common_function ------------------------------------------------------------------
  001B    0183    CLR	0x3
  001C    120A    CLRB	0xA,4
  001D    118A    CLRB	0xA,3
  001E    2AD1    JP	0x2D1
  0106    1778    SETB	0x78,6
  0107    1105    CLRB	0x5,2
  0108    1205    CLRB	0x5,4
  0109    0AAC    INCR	0x2C
  010A    1903    SZB	0x3,2
  010B    0AAD    INCR	0x2D
  010C    3000    LDIA	0x0
  010D    022D    SUBA	0x2D
  010E    3405    RET	0x5
  010F    1778    SETB	0x78,6
  0110    1105    CLRB	0x5,2
  0111    1605    SETB	0x5,4
  0112    0AAC    INCR	0x2C
  0113    1903    SZB	0x3,2
  0114    0AAD    INCR	0x2D
  0115    3000    LDIA	0x0
  0116    022D    SUBA	0x2D
  0117    340A    RET	0xA
  0205    0828    LD	A,0x28
  0206    072A    ADDA	0x2A
  0207    00A6    LD	0x26,A
  0208    0829    LD	A,0x29
  0209    1803    SZB	0x3,0
  020A    0A29    INCA	0x29
  020B    072B    ADDA	0x2B
  020C    00A7    LD	0x27,A
  020D    0008    RET
  02C5    0AB4    INCR	0x34
  02C6    1903    SZB	0x3,2
  02C7    0AB5    INCR	0x35
  02C8    3000    LDIA	0x0
  02C9    0235    SUBA	0x35
  02CA    3408    RET	0x8
  02CB    0AB4    INCR	0x34
  02CC    1903    SZB	0x3,2
  02CD    0AB5    INCR	0x35
  02CE    3000    LDIA	0x0
  02CF    0235    SUBA	0x35
  02D0    3403    RET	0x3
  03D7    0064    CLRWDT
  03D8    0180    CLR	0x0
  03D9    0A84    INCR	0x4
  03DA    0604    XORA	0x4
  03DB    1903    SZB	0x3,2
  03DC    3400    RET	0x0
  03DD    0604    XORA	0x4
  03DE    2BD8    JP	0x3D8
