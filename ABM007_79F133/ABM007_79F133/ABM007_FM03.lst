---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\main.c ----------------------------------------------------------------------
1:                // #include <cms.h>	//芯片头文件，会根据工程选项自动寻找对应型号头文件
2:                #include "cfg_user.h"
3:                #include "cfg_case.h"
4:                #include "math.h"
5:                #include "string.h"
6:                
7:                volatile unsigned int TMR1 @0x000E;
8:                #define TIMER1_TIME 0xE0C0
9:                
10:               /**********************************************************************/
11:               /*全局变量声明*/
12:               /**********************************************************************/
13:               
14:               /*变量*/
15:               v_uint8 RX_Buf;
16:               v_uint8 templ = 0;
17:               v_uint8 SEQmain = 0;
18:               v_uint8 MainTime_1min = 0;	/* 定时1min计数 */
19:               v_uint16 MainTime_1s = 0;	/* 定时1s计数 */
20:               v_uint16 AD_Result = 0;
21:               
22:               extern  void INT_LED_SHOW(void);
23:               
24:               /***********************************************************************
25:               函数功能：延时子函数，13个指令周期1循环
26:               ***********************************************************************/
27:               void Delay(unsigned int dtemp)
28:               {
29:               	while (dtemp--)
  0521    3001    LDIA	0x1
  0522    02F2    SUBR	0x72
  0523    3000    LDIA	0x0
  0524    1C03    SNZB	0x3,0
  0525    03F3    DECR	0x73
  0526    02F3    SUBR	0x73
  0527    0F72    SZINCA	0x72
  0528    2D21    JP	0x521
  0529    0A73    INCA	0x73
  052A    1903    SZB	0x3,2
  052B    0008    RET
  052C    2D21    JP	0x521
30:               		;
31:               }
32:               /***********************************************************************
33:               子函数功能：延时templ  ms，有中断则不准
34:               ***********************************************************************/
35:               void Delay_nms(unsigned int inittempl)
36:               {
37:               	unsigned int i;
38:               	unsigned char gtemp;
39:               	/******************************************************************/
40:               	gtemp = 0;
  0502    01F8    CLR	0x78
41:               	if (GIE == 1)
  0503    1F8B    SNZB	0xB,7
  0504    2D08    JP	0x508
42:               	{
43:               		gtemp = 1;
  0505    01F8    CLR	0x78
  0506    0AF8    INCR	0x78
44:               		GIE = 0;
  0507    138B    CLRB	0xB,7
45:               	}
46:               	for (i = 0; i < inittempl; i++)
  0508    01F6    CLR	0x76
  0509    01F7    CLR	0x77
  050A    0875    LD	A,0x75
  050B    0277    SUBA	0x77
  050C    1D03    SNZB	0x3,2
  050D    2D10    JP	0x510
  050E    0874    LD	A,0x74
  050F    0276    SUBA	0x76
  0510    1803    SZB	0x3,0
  0511    2D1D    JP	0x51D
47:               	{
48:               		Delay(154);
  0512    309A    LDIA	0x9A
  0513    00F2    LD	0x72,A
  0514    01F3    CLR	0x73
  0515    2521    CALL	0x521
  0516    120A    CLRB	0xA,4
  0517    118A    CLRB	0xA,3
  0518    0064    CLRWDT
  0519    0AF6    INCR	0x76
  051A    1903    SZB	0x3,2
  051B    0AF7    INCR	0x77
  051C    2D0A    JP	0x50A
49:               		asm("clrwdt");
50:               	}
51:               	if (gtemp == 1)
  051D    0B78    SZDECA	0x78
  051E    0008    RET
52:               		GIE = 1;
  051F    178B    SETB	0xB,7
  0520    0008    RET
53:               }
54:               
55:               /************************************************************
56:               函数名称：Init_GPIO()
57:               函数功能：初始化IO端口
58:               入口参数：
59:               出口参数：
60:               备注：
61:               ************************************************************/
62:               void Init_GPIO(void)
63:               {
64:               
65:               	/*引脚数据*/
66:               	PORTA = 0B01000000;
  052D    3040    LDIA	0x40
  052E    1283    CLRB	0x3,5
  052F    1303    CLRB	0x3,6
  0530    0085    LD	0x5,A
67:               	PORTB = 0B00000001;
  0531    3001    LDIA	0x1
  0532    0086    LD	0x6,A
68:               	PORTC = 0B00000000;
  0533    0187    CLR	0x7
69:               
70:               	/* 全部配置成输入状态，1: 输入，0: 输出 */
71:               	TRISA = 0B01000000; /*RA1直流阀 RA2-气泵	RA4-主阀  RA5-氛围灯 RA6按键1*/
  0534    3040    LDIA	0x40
  0535    1683    SETB	0x3,5
  0536    0085    LD	0x5,A
72:               	TRISB = 0B00000111; /* RB0按键2	RB1-龙头感应，RB0测试点 */
  0537    3007    LDIA	0x7
  0538    0086    LD	0x6,A
73:               	TRISC = 0B00000000;
  0539    0187    CLR	0x7
74:               
75:               	/*内部上拉关闭, 1: 开启, 0: 关闭 */
76:               	WPUA = 0B00000000; /* RA1直流阀		RA2-气泵	RA4-主阀 RA5-氛围灯 */
  053A    1703    SETB	0x3,6
  053B    018E    CLR	0xE
77:               	WPUB = 0B00000010; /* RB1-龙头感应<置1则不插为有人状态，RB1低有效>，RB0-测试点，硬件下拉 */
  053C    3002    LDIA	0x2
  053D    1303    CLRB	0x3,6
  053E    0095    LD	0x15,A
78:               	WPUC = 0B00000000;
  053F    1703    SETB	0x3,6
  0540    018F    CLR	0xF
  0541    0008    RET
79:               
80:               	/* 内部下拉 */
81:               	// WPDB =  0B00000000; /* RB1-龙头感应<1不插为无人状态，RB1高有效> */
82:               
83:               	/*模拟通道选择*/
84:               //	ANSEL0 = 0B00000000; // AN7 - AN0
85:               //	ANSEL1 = 0B00000000; // AN15 - AN8
86:               //	ANSEL2 = 0B00000000; //------AN17 AN16
87:               }
88:               
89:               /************************************************************
90:               函数名称：Init_IC()
91:               函数功能：上电初始化系统寄存器
92:               入口参数：
93:               出口参数：
94:               备注：
95:               ************************************************************/
96:               void Init_IC(void)
  0542    0064    CLRWDT
97:               {
98:               	asm("clrwdt");
99:               
100:              	// 7			6			5			4			3			2			1			0
101:              	// GIE		PEIE		TOIE		INTE		RBIE		TOIF		INTF		RBIF
102:              	// 全局允许	外设允许	T0允许		INT允许		PB允许		T0标志		INT标志		PB标志
103:              	INTCON = 0x00; // 中断控制寄存器
  0543    018B    CLR	0xB
104:              
105:              	// 7			6			5			4			3			2			1			0
106:              	//--		ADIF		RCIF		TXIF		--			CCP1IF		TMR2IF		TMR1IF
107:              	// NC		AD转换完成	UART接收满	UART发送满		NC		CCP1中断	T2与PR2匹配		T1
108:              	PIR1 = 0; // 外设中断请求寄存器
  0544    1283    CLRB	0x3,5
  0545    1303    CLRB	0x3,6
  0546    018C    CLR	0xC
109:              
110:              	// 7			6			5			4			3			2			1			0
111:              	//--		TKIF		RACIF		EEIF		--			--			--			CCP2IF
112:              	// NC		触摸检测结束 PA变化		 EEP写完成	  NC		  NC		  NC		  CCP2中断
113:              	PIR2 = 0; // 外设中断请求寄存器
  0547    018D    CLR	0xD
114:              
115:              	// 7			6			5			4			3			2			1			0
116:              	//--		--			--			--			--			--			--			SWDTEN
117:              	// NC		NC			NC			NC			NC			NC			NC			使能
118:              	WDTCON = 0x01; // 看门狗
  0548    3001    LDIA	0x1
  0549    1703    SETB	0x3,6
  054A    0085    LD	0x5,A
119:              
120:              	// 7				6			5			4			3			2			1		0
121:              	// RBPU			INTEDG			T0CS		T0SE		PSA			PS2			PS1		PS0
122:              	// PB上拉使能	中断边沿选择  	T0时钟源	  T0边沿选择	预分配		预分配参数
123:              	OPTION_REG = 0b00001110; // 开启PORTB上来使能，看门狗复位时间=18*分频系数 (规格书 2.6/2.8.1)
  054B    300E    LDIA	0xE
  054C    1683    SETB	0x3,5
  054D    1303    CLRB	0x3,6
  054E    0081    LD	0x1,A
124:              
125:              	// 7			6			5			4			3			2			1			0
126:              	//--		IRCF2		IRCF1		IRCF0		--			--			--			--
127:              	// NC		内振分频							NC			NC			NC			NC
128:              	OSCCON = 0x71; // 振荡器控制
  054F    3071    LDIA	0x71
  0550    008F    LD	0xF,A
129:              
130:              	// 7			6			5			4			3			2			1				0
131:              	//--		ADIE		RCIE		TXIE		--			CCP1IE		TMR2IE			TMR1IE
132:              	// NC		AD转换允许	UART接收允许 UART发送允许 NC		  CCP1允许	  T2与PR2匹配允许	T1溢出允许
133:              	PIE1 = 0; // 外设中断允许
  0551    018C    CLR	0xC
134:              
135:              	//
136:              	//--	TKIE				RACIE			EEIE			--		--		--		CCP2IE
137:              	// NC	触摸检测结束允许	PA变化允许			EEP写允许		NC		NC		NC		CCP2中断允许
138:              	PIE2 = 0; // 外设中断允许
  0552    018D    CLR	0xD
  0553    0008    RET
139:              }
140:              
141:              /************************************************************
142:              函数名称：Init_TIMER1()
143:              函数功能：定时器1初始化函数
144:              入口参数：
145:              出口参数：
146:              备注：	  定时时间计算方法
147:              		  定时时间T = {1/[(Fosc)*预分频比)]}*(65535-[TMR1H:TMR1L])
148:              		  本程序计算示例：
149:              		  T = {1/[(8)*(1/1)]}*(65536 - 63936)
150:              			= 125 us
151:              ************************************************************/
152:              void Init_TIMER1(void)
153:              {
154:              	// TMR1L = 0xC0; //赋初值
155:              	// TMR1H = 0xF9;
156:              	TMR1 = TIMER1_TIME;
  0554    30E0    LDIA	0xE0
  0555    1283    CLRB	0x3,5
  0556    1303    CLRB	0x3,6
  0557    008F    LD	0xF,A
  0558    30C0    LDIA	0xC0
  0559    008E    LD	0xE,A
157:              	TMR1IF = 0;	  // 清中断标志位
  055A    100C    CLRB	0xC,0
158:              	TMR1IE = 1;	  // 允许Timer1中断
  055B    1683    SETB	0x3,5
  055C    140C    SETB	0xC,0
159:              	T1CON = 0x01; // 开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  055D    3001    LDIA	0x1
  055E    1283    CLRB	0x3,5
  055F    0090    LD	0x10,A
  0560    0008    RET
160:              }
161:              
162:              /************************************************************
163:              函数名称：Init_TIMER2()
164:              函数功能：定时器2初始化函数
165:              入口参数：
166:              出口参数：
167:              备注：	  定时时间计算方法
168:              		  时钟输入为系统指令时钟（即为Fosc/4）
169:              		  定时时间T = {1/[(Fosc/4)*预分频比*后分频比]}*(PR2+1)
170:              		  本程序计算示例：
171:              		  T = {1/[(8/4)*(1/4)*1]}*50 = 100 us
172:              
173:              ************************************************************/
174:              void Init_TIMER2(void)
175:              {
176:              	PR2 = 24;	// 8M下将TMR2设置为50us中断?
  0561    3018    LDIA	0x18
  0562    1683    SETB	0x3,5
  0563    0092    LD	0x12,A
177:              	TMR2IF = 0; // 清中断标志位
  0564    1283    CLRB	0x3,5
  0565    108C    CLRB	0xC,1
178:              	TMR2IE = 1; // 允许Timer2中断
  0566    1683    SETB	0x3,5
  0567    148C    SETB	0xC,1
179:              	T2CON = 5;	// 开启Timer2，预分频值为4，后分频比为1:1
  0568    3005    LDIA	0x5
  0569    1283    CLRB	0x3,5
  056A    0092    LD	0x12,A
  056B    0008    RET
180:              }
181:              
182:              /* 遥控器接收数据时钟，50μs */
183:              // void Init_TIMER2_Remo(void)
184:              //{
185:              //	PR2 = 24;		//16M下将TMR2设置为50μs中断
186:              //	TMR2IF = 0; 	//清中断标志位
187:              //	TMR2IE = 1; 	//允许Timer2中断
188:              //	T2CON = 5;		//开启Timer2，预分频值为4，后分频比为1:1
189:              // }
190:              
191:              /***********************************************
192:              函数名称：Set_CCP_PWM
193:              函数功能：CCP PWM模式初始化
194:              入口参数：无
195:              出口参数：无
196:              备注：
197:              	   周期 = (PWMxCYC+1)*4/Fosc*PWMxCNT预分频值
198:              	  占空比 = (CCPRxL:CCPCON<5:4>)/(4*(PWMxCYC + 1))
199:              	  由于CCPx 引脚与端口数据锁存器复用，必须清零相应的TRIS 位才能使能CCPx 引脚的输出驱动器。
200:              ************************************************/
201:              void Set_CCP_PWM()
202:              {
203:              //	PWMCON = 0B00000001; // PWM1设置为16分频，使能PWM1
204:              
205:              	// // PWM1 周期设置为500us，占空比50%
206:              	// CCP1CON = 0B00001100; // PWM模式,10位占空比数据低2位为0；
207:              	// PWM1CYC = 124;		  // PWM1周期为：(249+1)* （4/8） * 4 =500uS
208:              	// CCPR1L = 62;		  // 低2位为0,(CCPRxL:CCPCON<5:4>)=CCPR1L*4
209:              	// CYC1EN = 1;			  /* PWM1的周期计数器使能位,1使能，0禁止 */
210:              	// PWMTL = 0x8f;					//PWM0~3共周期，周期低位
211:              	PWMT4L = 0x7C;					//PWM4独立周期，周期低位,0x7C,(124+1)* （4/8） * 4 =250μs
212:              	PWMTH = 0B00011101;				//周期高两位及PWM4占空比高两位	
213:              	/* PWMTH: bit5~bit4- PWM4占空比高2位，bit3~bit2-PWM周期高2位，bit1~bit0-PWM0~PWM3周期高2位 */
214:              	
215:              	//PWM0~3周期为：(0B110001111+1)*(1/16)*2 =50uS
216:              	//PWM4周期为：(0B1110001111+1)*(1/16)*2 =114uS
217:              	/* PWM4 0B00001100 */
218:              	
219:              	// PWMD01H = 0x00;					//高位改变后不能立即生效，需要给占空比的低位寄存器后才能加载
220:              	// //PWM0 占空比设置为20%
221:              	// PWMD0L = 0x4f;					//(79+1)/(399+1) = 20%
222:              	// //PWM1 占空比设置为40%
223:              	// PWMD1L = 0x9f;					//(159+1)/(399+1) = 40%
224:              
225:              	// PWMD23H = 0x10;
226:              	// //PWM2 占空比设置为60%
227:              	// PWMD2L = 0xef;					//(239+1)/(399+1) = 60%
228:              	// //PWM3 占空比设置为80%
229:              	// PWMD3L = 0x3f;					//(319+1)/(399+1) = 80%
230:              
231:              	//PWM4 占空比设置为25%
232:              	PWMD4L = 0xC7;					//(227+1)/(911+1) = 25% ()
233:              	/* 50% 0x01C7, (455+1)/(911+1) */
234:              	
235:              	// PWM01DT = 0x3F;					//死区时间，低6位有效位=(0B00111111+1)*(1/16)*1 =4uS
236:              	// PWM23DT = 0;
237:              	
238:              	PWMCON2 = 0B00000000;			//正常输出
239:              	PWMCON1 = 0B00000000;			//PWM01位置选择为RB5/RB4;禁止死区；可使能PWM0/1互补，PWM2/3互补
240:              	PWMCON0 = 0B00110000;			//PWM分频Fosc/2，使能PWM4
241:              }
242:              
243:              /***********************************************
244:              函数名称：Memory_Write
245:              函数功能：写数据
246:              入口参数：Addr - 写入地址
247:              		  Value - 写入数值
248:              出口参数：返回值 0 - 写操作错误 1 - 写完毕
249:              备注：
250:              写程序EE过程中需要暂时关闭中断，以保证写EE时序中的写55H和写AAH能够连续进行，否则将有可能写错，并且写EE的可靠工作电压范围为3V以上。
251:              ************************************************/
252:              unsigned char Memory_Write(unsigned char Addr, unsigned char Value)
253:              {
254:              
255:              	volatile unsigned char i = 0;
256:              	// 将要写入的地址放入EEADDR寄存器
257:              	EEADR = Addr;
258:              	EEDAT = Value; // 将要写入的数据给EEPROM的数据寄存器
259:              	EECON1 = 0;
260:              	EEPGD = 0;		 // 访问数据存储器
261:              	EECON1 | = 0x10; // 烧写时间10ms（0x30）,时间非固定精准,用户可自定义(最长烧写等待时间2.5ms, 0x10)
262:              	asm("clrwdt");
263:              
264:              	WREN = 1; // 允许写周期
265:              	GIE = 0;  // 关闭中断
266:              	GIE = 0;
267:              	GIE = 0;
268:              	while (GIE)
269:              	{
270:              		GIE = 0; // 确保中断已关闭
271:              		if (0 == --i)
272:              		{
273:              			// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
274:              			GIE = 1; // 总中断GIE置1
275:              			return 0;
276:              		}
277:              	}
278:              	asm("clrwdt");
279:              
280:              	EECON2 = 0x55; // 给EECON2写入0x55
281:              	EECON2 = 0xaa; // 给EECON2写入0xaa
282:              	WR = 1;		   // 启动写周期
283:              	asm("nop");
284:              	asm("nop");
285:              	asm("clrwdt");
286:              	WREN = 0; // 禁止写入
287:              	// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
288:              	GIE = 1; // 总中断GIE置1
289:              
290:              	if (WRERR)
291:              		return 0; // 写操作错误
292:              	else
293:              		return 1; // 写完毕
294:              }
295:              
296:              void Flash_Write(unsigned char Addr, unsigned char Value)
297:              {
298:              	uint8_t bufAddress;
299:              	uint8_t bufValue;
300:              	bufAddress = Addr;
301:              	bufValue = Value;
302:              	templ = 10; //错误计数，用户可自定义
303:              	do
304:              	{
305:              		asm("clrwdt");
306:              		asm("clrwdt");
307:              	} while ((0 == Memory_Write(bufAddress, bufValue)) && (templ--)); //调用写函数：地址0x00处写入数据0x5a
308:              }
309:              
310:              /***********************************************
311:              函数名称：Memory_Read
312:              函数功能：读数据
313:              入口参数：Addr - 读取地址
314:              出口参数：返回读取地址相应数值
315:              备注：
316:              ************************************************/
317:              unsigned char Memory_Read(unsigned char Addr)
318:              {
319:              
320:              	EEADR = Addr;
321:              	EEPGD = 0; // 访问数据存储器
322:              
323:              	RD = 1; // 允许读操作
324:              	asm("nop");
325:              	asm("nop");
326:              
327:              	return (EEDAT);
328:              }
329:              
330:              /************************************************************
331:              函数名称：AD_Testing()
332:              函数功能：AD采样函数
333:              入口参数：ad_fd - 分频 00Fosc/8; 01Fosc/16; 10Fosc/32; 11Frc;
334:              		  ad_ch - AD通道选择1~15，15通道为内部基准1.2V固定输入值
335:              		  ad_lr - 左/右对齐，输入0或1，0为左对齐，1为右对齐
336:              
337:              出口参数：AdResult - AD结果
338:              备    注：BUFmotor_ad = AD_Testing(0, 10, 0); //8分频，AN10通道，右对齐	规格书11.2.4，8M主频最快8分频
339:              ************************************************************/
340:              unsigned int AD_Testing(unsigned char ad_fd, unsigned char ad_ch, unsigned char ad_lr)
341:              {
342:              	// static volatile unsigned char adtimes;
343:              	// static volatile unsigned int admin, admax, adsum;
344:              	volatile unsigned int data;
345:              	volatile unsigned char i = 0;
346:              
347:              	if (!ad_lr)
348:              		ADCON1 = 0; // 左对齐,出12位
349:              	else
350:              		ADCON1 = 0x80; // 右对齐,出10位
351:              
352:              	if (ad_ch & 0x10) // 设置CHS4，此位在ADCON1寄存器中
353:              		ADCON1 |= 0x40;
354:              
355:              	ADCON0 = 0;
356:              	ad_ch &= 0x0f;
357:              	ADCON0 |= (unsigned char)(ad_fd << 6); // 不同的VDD或参考电压需要配置合理的分频
358:              	ADCON0 |= (unsigned char)(ad_ch << 2); // 设置通道
359:              	ADCON0 |= 0x01;						   // 使能ADC
360:              
361:              	asm("nop");
362:              	asm("nop");
363:              	GODONE = 1; // 开始转换
364:              
365:              	while (GODONE)
366:              	{
367:              		asm("nop");
368:              		asm("nop");
369:              		if ((--i) == 0) // ad等待限时，防止出现死循环，但要考虑转换时间不能长于此时间
370:              			return 0;
371:              	}
372:              
373:              	if (!ad_lr) // 左对齐
374:              	{
375:              		data = (unsigned int)(ADRESH << 4);
376:              		data |= (unsigned int)(ADRESL >> 4);
377:              	}
378:              	else // 右对齐
379:              	{
380:              		data = (unsigned int)(ADRESH << 8);
381:              		data |= (unsigned int)ADRESL;
382:              	}
383:              
384:              	return data;
385:              }
386:              
387:              /***********************************************
388:              函数名称：Set_Usart_Async
389:              函数功能：Usart状态设置（异步）
390:              入口参数：无
391:              出口参数：无
392:              备注：
393:              1、串口通讯，设置波特率寄存器时，应控制在19200及以下，实际应用时应考虑到芯片内振的电压及温度特性。
394:              2、SYNC = 0;目标波特率 = Fosc/(16*(SPBRG+1))
395:              ************************************************/
396:              void Set_Usart_Async()
397:              {
398:              	BRGHEN1 = 1;
399:              	BRG16EN1 = 0; //设置BRG是一个8位定时器
400:              
401:              	SPBRGH1 = 0;
402:              	SPBRG1 = 51; //设置波特率为9600 bps (8M/(16*52))
403:              
404:              //	SPBRG = 25; /* 19200bps, 8M/(16*26) */
405:              
406:              	SYNC1 = 0; // 0为异步模式，1为同步模式
407:              	SCKP1 = 0; // 直接将数据字符发送到TX/CK引脚
408:              
409:              	SPEN1 = 1;  // 允许串口操作
410:              	RC1IE = 1;  // 接收中断  //暂时关闭
411:              	TX1IE = 0;  // 发送中断
412:              	RX9EN1 = 0; // 0为8位接收，1为9位接收
413:              	TX9EN1 = 0; // 0为8位发送，1为9位发送
414:              	CREN1 = 1;  // 0为禁止接收，1为使能接收 //暂时关闭
415:              	TXEN1 = 1;  // 0为禁止发送，1为使能发送
416:              }
417:              
418:              /************************************************************
419:              函数名称：Uart_Send_NByte()
420:              函数功能：串口多字节发送函数
421:              入口参数：n 待发送字节数量
422:              		  nSendByte 待发送数组
423:              出口参数：
424:              备    注：
425:              ************************************************************/
426:              // void Uart_Send_NByte(uint8_t n, uint8_t *nSendByte)
427:              // {
428:              // 	uint8_t i;
429:              // 	for(i = 0; i < n; i++)
430:              // 	{
431:              // 		TX_Buf[i] = nSendByte[i];
432:              // 	}
433:              // 	tx_index = n;
434:              // 	TXIE = 1;
435:              // }
436:              
437:              /************************************************************
438:              函数名称：Init_PA_Isr()
439:              函数功能：PA中断初始化函数
440:              入口参数：
441:              出口参数：
442:              备    注：
443:              ************************************************************/
444:              // void Init_PA_Isr()
445:              // {
446:              // 	IOCA = 0B01100110; // 允许RA1的IO口电平变化中断
447:              // 	RACIE = 1;		   // 使能PORTA电平变化中断
448:              // 	PORTA;			   // 读取PORTA并锁存
449:              // }
450:              
451:              /************************************************************
452:              函数名称：Init_PB_Isr()
453:              函数功能：PB中断初始化函数
454:              入口参数：
455:              出口参数：
456:              备    注：
457:              ************************************************************/
458:              // void Init_PB_Isr()
459:              // {
460:              // 	IOCB = 0B00000001; // 允许RB0的IO口电平变化中断
461:              // 	RBIE = 1;		   // 使能PORTB电平变化中断
462:              // 	// INTCON = 0x88;			//允许所有未被屏蔽的中断、禁止外设中断，使能PORTB电平变化中断
463:              // 	PORTB;			   // 读取PORTB并锁存
464:              // }
465:              
466:              /************************************************************
467:              函数名称：mainr()
468:              函数功能：主循环
469:              入口参数：
470:              出口参数：
471:              备    注：
472:              ************************************************************/
473:              void main(void)
  03F4    0000    NOP
  03F5    0064    CLRWDT
474:              {
475:              	/******************************************************************/
476:              	asm("nop");
477:              	asm("clrwdt");
478:              	INTCON = 0;		 //禁止中断
  03F6    018B    CLR	0xB
479:              
480:              	Init_GPIO();	// 初始化GPIO
  03F7    120A    CLRB	0xA,4
  03F8    118A    CLRB	0xA,3
  03F9    252D    CALL	0x52D
481:              	Init_IC();		// 相关寄存器初始化
  03FC    120A    CLRB	0xA,4
  03FD    118A    CLRB	0xA,3
  03FE    2542    CALL	0x542
482:              	Delay_nms(200); // 上电延时200ms 非精准延时
  0401    30C8    LDIA	0xC8
  0402    00F4    LD	0x74,A
  0403    01F5    CLR	0x75
  0404    120A    CLRB	0xA,4
  0405    118A    CLRB	0xA,3
  0406    2502    CALL	0x502
483:              	Init_TIMER1();	// 定时器1初始化
  0409    120A    CLRB	0xA,4
  040A    118A    CLRB	0xA,3
  040B    2554    CALL	0x554
484:              	Init_TIMER2();	// 定时器2初始化
  040E    120A    CLRB	0xA,4
  040F    118A    CLRB	0xA,3
  0410    2561    CALL	0x561
485:              //	Init_PA_Isr();		 //PA中断初始化函数
486:              //	Init_PB_Isr();		 //PB中断初始化函数
487:              // #if FCT
488:              // 	/* FCT串口不初始化，TX、RX作为普通端口使用 */
489:              // #else
490:              // 	Set_Usart_Async(); // 串口初始化
491:              // #endif
492:              
493:              	//	Set_CCP_PWM();		 //PWM初始化
494:              
495:              	INTCON = 0XC0;	   // 允许所有未被屏蔽的中断、外设中断
  0413    30C0    LDIA	0xC0
  0414    008B    LD	0xB,A
496:              
497:              	// RemoFlash_Read();  /* 读取存储的数值 */
498:              	while (1)
499:              	{
500:              		/*主循环10ms*/
501:              		if (F1ms == SET)
  0415    1CCA    SNZB	0x4A,1
  0416    2C15    JP	0x415
  0417    0064    CLRWDT
502:              		{
503:              			CLRWDT(); /*清看门狗*/
504:              			// ScanIO();
505:              			F1ms = CLR;
  0418    1283    CLRB	0x3,5
  0419    1303    CLRB	0x3,6
  041A    10CA    CLRB	0x4A,1
506:              			switch (SEQmain)
  041B    2C3A    JP	0x43A
507:              			{
508:              				case 0:
509:              					FCTloop();
  041C    120A    CLRB	0xA,4
  041D    118A    CLRB	0xA,3
  041E    2463    CALL	0x463
510:              					break;
  0421    2C5A    JP	0x45A
511:              				case 1:
512:              					if(FfctTest == CLR)
  0422    1846    SZB	0x46,0
  0423    2C5A    JP	0x45A
513:              					{
514:              						GsensorLoop();
  0424    120A    CLRB	0xA,4
  0425    118A    CLRB	0xA,3
  0426    2230    CALL	0x230
  0429    2C5A    JP	0x45A
515:              					}
516:              					break;
517:              				case 2:
518:              						// GkeyLoop();
519:              					break;
520:              				case 3:
521:              
522:              					break;
523:              				case 4:
524:              					if(FfctTest == CLR)
  042A    1846    SZB	0x46,0
  042B    2C5A    JP	0x45A
525:              					{
526:              						GflushLoop();
  042C    120A    CLRB	0xA,4
  042D    118A    CLRB	0xA,3
  042E    201C    CALL	0x1C
  0431    2C5A    JP	0x45A
527:              					}
528:              					break;
529:              				case 5:
530:              
531:              					break;
532:              				case 6:
533:              
534:              					break;
535:              				case 7:
536:              
537:              					break;
538:              				case 8:
539:              					if(FfctTest == CLR)
  0432    1846    SZB	0x46,0
  0433    2C5A    JP	0x45A
540:              					{
541:              						GledLoop();
  0434    120A    CLRB	0xA,4
  0435    118A    CLRB	0xA,3
  0436    2326    CALL	0x326
  0439    2C5A    JP	0x45A
  043A    0843    LD	A,0x43
  043B    3A00    XORIA	0x0
  043C    1903    SZB	0x3,2
  043D    2C1C    JP	0x41C
  043E    3A01    XORIA	0x1
  043F    1903    SZB	0x3,2
  0440    2C22    JP	0x422
  0441    3A03    XORIA	0x3
  0442    1903    SZB	0x3,2
  0443    2C5A    JP	0x45A
  0444    3A01    XORIA	0x1
  0445    1903    SZB	0x3,2
  0446    2C5A    JP	0x45A
  0447    3A07    XORIA	0x7
  0448    1903    SZB	0x3,2
  0449    2C2A    JP	0x42A
  044A    3A01    XORIA	0x1
  044B    1903    SZB	0x3,2
  044C    2C5A    JP	0x45A
  044D    3A03    XORIA	0x3
  044E    1903    SZB	0x3,2
  044F    2C5A    JP	0x45A
  0450    3A01    XORIA	0x1
  0451    1903    SZB	0x3,2
  0452    2C5A    JP	0x45A
  0453    3A0F    XORIA	0xF
  0454    1903    SZB	0x3,2
  0455    2C32    JP	0x432
  0456    3A01    XORIA	0x1
  0457    1903    SZB	0x3,2
  0458    2C5A    JP	0x45A
  0459    2C5A    JP	0x45A
542:              					}
543:              				break;
544:              				case 9:
545:              
546:              					break;
547:              				default:
548:              					// SEQmain = 0;
549:              					break;
550:              			}
551:              			if (++SEQmain >= 10)
  045A    300A    LDIA	0xA
  045B    1283    CLRB	0x3,5
  045C    1303    CLRB	0x3,6
  045D    0AC3    INCR	0x43
  045E    0243    SUBA	0x43
  045F    1C03    SNZB	0x3,0
  0460    2C15    JP	0x415
552:              			{
553:              				SEQmain = 0;
  0461    01C3    CLR	0x43
  0462    2C15    JP	0x415
554:              			}
555:              		}
556:              	}
557:              }
558:              
559:              // /***********************************************************************
560:              // 函数功能：中断入口函数
561:              // RISC内核无中断优先级，不可嵌套
562:              // ***********************************************************************/
563:              void interrupt Int_ALL(void)
564:              {
565:              	// 1ms定时器中断服务函数
566:              	if (TMR1IF)
  04C6    1283    CLRB	0x3,5
  04C7    1303    CLRB	0x3,6
  04C8    1C0C    SNZB	0xC,0
  04C9    2CDE    JP	0x4DE
567:              	{
568:              		// ---------------------------------------
569:              		// TMR1L += 0xC0;
570:              		// TMR1H += 0xF9; //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
571:              		// 在进入中断等过程中其实Time是一直在计数的
572:              		// ---------------------------------------
573:              		TMR1 = TIMER1_TIME;
  04CA    30E0    LDIA	0xE0
  04CB    008F    LD	0xF,A
  04CC    30C0    LDIA	0xC0
  04CD    008E    LD	0xE,A
574:              		TMR1IF = 0; // 清中断标志位
  04CE    100C    CLRB	0xC,0
575:              
576:              		/* 主循环1ms标志位 */
577:              		F1ms = 1;
  04CF    14CA    SETB	0x4A,1
578:              
579:              		/* 1s标志位 */
580:              		if (++MainTime_1s >= 1000)
  04D0    0AB0    INCR	0x30
  04D1    1903    SZB	0x3,2
  04D2    0AB1    INCR	0x31
  04D3    3003    LDIA	0x3
  04D4    0231    SUBA	0x31
  04D5    30E8    LDIA	0xE8
  04D6    1903    SZB	0x3,2
  04D7    0230    SUBA	0x30
  04D8    1C03    SNZB	0x3,0
  04D9    2CDE    JP	0x4DE
581:              		{
582:              			MainTime_1s = 0;
  04DA    01B0    CLR	0x30
  04DB    01B1    CLR	0x31
583:              			Fsys1s.byte = 0xFF; /* 1s' flag */
  04DC    30FF    LDIA	0xFF
  04DD    00C9    LD	0x49,A
584:              // #if (VER_2510M || VER_2510U)
585:              // 			if (++MainTime_1min >= 60) /* 1min标识位 */
586:              // 			{
587:              // 				MainTime_1min = 0;
588:              // 				Fsys1m.byte = 0xFF; /* 1min' flag */
589:              // 			}
590:              // #endif
591:              		}
592:              	}
593:              
594:              	// 50us定时器中断服务函数
595:              	if (TMR2IF)
  04DE    1C8C    SNZB	0xC,1
  04DF    2CE2    JP	0x4E2
596:              	{
597:              		TMR2IF = 0; /*	8位，自重载，无需二次配置	*/
  04E0    108C    CLRB	0xC,1
598:              		INT_LED_SHOW(); /* 氛围灯中断函数 */
  04E1    24E9    CALL	0x4E9
  04E2    0871    LD	A,0x71
  04E3    008A    LD	0xA,A
  04E4    0E70    SWAPA	0x70
  04E5    0083    LD	0x3,A
  04E6    0EFE    SWAPR	0x7E
  04E7    0E7E    SWAPA	0x7E
  04E8    0009    RETI
599:              	}
600:              
601:              // #if FCT
602:              // 	/* FCT停止uart通讯中断服务 */
603:              // #else
604:              // 	// 串口接收中断服务函数
605:              // 	if (RC1IF)
606:              // 	{
607:              // 		//-------------------------------------------
608:              // 		// 接收控制，如果接收标志位为1，说明有数据接收完毕
609:              // 		// RCIF在寄存器被读出后自动清零
610:              // 		if (FERR1)
611:              // 		{
612:              // 			RCREG1; // 帧错误
613:              // 			return;
614:              // 		}
615:              
616:              // 		RX_Buf = RCREG1; // 将接收缓冲区内容读出
617:              
618:              // 		Uart_ReceiveLogic(); /* UART*/
619:              
620:              // 		if (OERR1) // 如果有溢出错误
621:              // 		{
622:              // 			CREN1 = 0; // 清零CREN1位可将OERR位清零
623:              // 			CREN1 = 1; // 再次将CREN1置一，以允许继续接收
624:              // 		}
625:              // 	}
626:              
627:              // 	// 串口发送中断服务函数
628:              // 	if (TX1IF && TX1IE)
629:              // 	{
630:              // 		// 发送控制
631:              // 		if (TRMT1)
632:              // 		{
633:              // 			Uart_SendLogic();
634:              // 			// TXREG = TX_Buf[tx_cnt];
635:              // 			// tx_cnt++;
636:              // 			// if(tx_cnt >= tx_index)
637:              // 			// {
638:              // 			// 	tx_cnt = 0;
639:              // 			// 	TXIE = 0;
640:              // 			// }
641:              // 		}
642:              // 	}
643:              // #endif
644:              	// PA中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
645:              	// if(RACIF)
646:              	// {
647:              	// 	PORTA;		 //读取PORTA状态
648:              	// 	RACIF = 0; //清中断标志
649:              	// }
650:              
651:              	// PB中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
652:              	// if(RBIF)
653:              	// {
654:              	// 	PORTB;		//读取PORTB状态
655:              	// 	RBIF = 0; //清中断标志
656:              	// }
657:              }
---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\sensor.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fbodysensor;
5:                
6:                v_uint8 u8stsBodySensor = 0;
7:                v_uint8 SEQbody = 0;
8:                v_uint16 CNTbody_h = 0;         /* 感应高电平计时 */
9:                v_uint16 CNTbody_l = 0;         /* 感应低电平计时 */
10:               v_uint16 BufCntAdd = 0;         /* 感应计时 */
11:               v_uint16 CNTbodyInTime = 0;     /* 感应到人计时 */
12:               v_uint16 CNTbodyExitTime = 0;   /* 感应到人离开计时 */
13:               
14:               void SensorKey(void);
15:               void SensorTime(void);
16:               void SensorJudge(void);
17:               void SensorControl(void);
18:               
19:               void GsensorLoop(void)
20:               {
21:                   SensorKey();
  0230    223A    CALL	0x23A
  0231    120A    CLRB	0xA,4
  0232    118A    CLRB	0xA,3
22:                   SensorTime();
  0233    223B    CALL	0x23B
  0234    120A    CLRB	0xA,4
  0235    118A    CLRB	0xA,3
23:                   SensorJudge();
  0236    228E    CALL	0x28E
  0237    120A    CLRB	0xA,4
  0238    118A    CLRB	0xA,3
24:                   SensorControl();
  0239    2A73    JP	0x273
25:               }
26:               
27:               void SensorKey(void)
  023A    0008    RET
28:               {
29:               
30:               }
31:               
32:               /* 人体感应计时函数 */
33:               void SensorTime(void)
34:               {
35:                   if(Fbody == SET)
  023B    1C7A    SNZB	0x7A,0
  023C    2A5F    JP	0x25F
36:                   {
37:                       FbodyEx5s = CLR;
  023D    12FA    CLRB	0x7A,5
38:                       CNTbodyExitTime = 0;
  023E    01A2    CLR	0x22
  023F    01A3    CLR	0x23
39:                       if(FlightLeave == CLR)  /* 检测到人有效时间 */
  0240    1947    SZB	0x47,2
  0241    2A5A    JP	0x25A
40:                       {
41:                           if(++CNTbodyInTime >= BODY_ENTER_KEEP_60S)	/* 60s */
  0242    0AA4    INCR	0x24
  0243    1903    SZB	0x3,2
  0244    0AA5    INCR	0x25
  0245    3017    LDIA	0x17
  0246    0225    SUBA	0x25
  0247    3070    LDIA	0x70
  0248    1903    SZB	0x3,2
  0249    0224    SUBA	0x24
  024A    1C03    SNZB	0x3,0
  024B    2A52    JP	0x252
42:                           {
43:                               CNTbodyInTime = BODY_ENTER_KEEP_60S;
  024C    3070    LDIA	0x70
  024D    00A4    LD	0x24,A
  024E    3017    LDIA	0x17
  024F    00A5    LD	0x25,A
44:                               FbodyIn60s = SET;
  0250    15FA    SETB	0x7A,3
45:                           }
  0251    0008    RET
46:                           else if(CNTbodyInTime >= BODY_ENTER_KEEP_5S)		/* 5s */
  0252    3001    LDIA	0x1
  0253    0225    SUBA	0x25
  0254    30F4    LDIA	0xF4
  0255    1903    SZB	0x3,2
  0256    0224    SUBA	0x24
  0257    1803    SZB	0x3,0
47:                           {
48:                               FbodyIn5s = SET;
  0258    167A    SETB	0x7A,4
  0259    0008    RET
49:                           }
50:                       }
51:                       else
52:                       {
53:                           if(FbodyIn5s == CLR)    /* 未待满5s，时间清零 */
  025A    1A7A    SZB	0x7A,4
  025B    0008    RET
54:                           {
55:                               CNTbodyInTime = 0;
  025C    01A4    CLR	0x24
  025D    01A5    CLR	0x25
56:                           }
57:                       }
58:                   }
  025E    0008    RET
59:                   else
60:                   {
61:                       CNTbodyInTime = 0;
  025F    01A4    CLR	0x24
  0260    01A5    CLR	0x25
62:                       FbodyIn5s = CLR;
  0261    127A    CLRB	0x7A,4
63:                       FbodyIn60s = CLR;
  0262    11FA    CLRB	0x7A,3
64:                       if(++CNTbodyExitTime >= BODY_EXIT_KEEP_5S)
  0263    0AA2    INCR	0x22
  0264    1903    SZB	0x3,2
  0265    0AA3    INCR	0x23
  0266    3001    LDIA	0x1
  0267    0223    SUBA	0x23
  0268    30F4    LDIA	0xF4
  0269    1903    SZB	0x3,2
  026A    0222    SUBA	0x22
  026B    1C03    SNZB	0x3,0
  026C    0008    RET
65:                       {
66:                           CNTbodyExitTime = BODY_EXIT_KEEP_5S;
  026D    30F4    LDIA	0xF4
  026E    00A2    LD	0x22,A
  026F    3001    LDIA	0x1
  0270    00A3    LD	0x23,A
67:                           FbodyEx5s = SET;        /* 人离开5秒 */
  0271    16FA    SETB	0x7A,5
  0272    0008    RET
68:                       }
69:                   }
70:               }
71:               
72:               /* 人体感应判定函数 */
73:               void SensorJudge(void)
74:               {
75:                   switch (SEQbody)
  028E    2B0B    JP	0x30B
76:                   {
77:                       case 0:
78:                           Fbody = CLR;
  028F    107A    CLRB	0x7A,0
79:                           FlightLeave = CLR;
  0290    1147    CLRB	0x47,2
80:                           SEQbody = 1;
  02A0    3001    LDIA	0x1
  02A1    00BE    LD	0x3E,A
81:                           break;
  02A2    0008    RET
82:               
83:                       /* 人离开确认 */
84:                       case 1:
85:                           Fbody = CLR;
  02A3    107A    CLRB	0x7A,0
86:                           FlightLeave = CLR;
  02A4    1147    CLRB	0x47,2
87:                           if(PIsensor == LOW)
  02A5    1886    SZB	0x6,1
  02A6    2AB8    JP	0x2B8
88:                           {
89:                               if(++CNTbody_h >= SENSOR_TRG)
  02A7    0AAA    INCR	0x2A
  02A8    1903    SZB	0x3,2
  02A9    0AAB    INCR	0x2B
  02AA    3000    LDIA	0x0
  02AB    022B    SUBA	0x2B
  02AC    3003    LDIA	0x3
  02AD    1903    SZB	0x3,2
  02AE    022A    SUBA	0x2A
  02AF    1C03    SNZB	0x3,0
  02B0    0008    RET
90:                               {
91:                                   CNTbody_h = 0;
  02B1    01AA    CLR	0x2A
  02B2    01AB    CLR	0x2B
92:               					CNTbody_l = 0;
  02B3    01A8    CLR	0x28
  02B4    01A9    CLR	0x29
93:               					SEQbody = 2;
  02B5    3002    LDIA	0x2
  02B6    00BE    LD	0x3E,A
94:               					break;
  02B7    0008    RET
95:                               }
96:                           }
97:                           else
98:                           {
99:                               CNTbody_h = 0;
  02B8    01AA    CLR	0x2A
  02B9    01AB    CLR	0x2B
  02BA    0008    RET
100:                          }
101:                          break;
102:              
103:                      /* 感应到人判定开始 */
104:                      case 2:
105:                          Fbody = CLR;
  02BB    107A    CLRB	0x7A,0
106:                          FlightLeave = CLR;
  02BC    1147    CLRB	0x47,2
107:                          if(PIsensor == LOW)
  02BD    1886    SZB	0x6,1
  02BE    2A92    JP	0x292
108:                          {
109:                              ++CNTbody_h;
  02BF    0AAA    INCR	0x2A
  02C0    1903    SZB	0x3,2
  02C1    0AAB    INCR	0x2B
110:                          }
  0291    2AA0    JP	0x2A0
111:                          else
112:                          {
113:                              if(++CNTbody_l >= SENSOR_ERROR)
  0292    0AA8    INCR	0x28
  0293    1903    SZB	0x3,2
  0294    0AA9    INCR	0x29
  0295    3000    LDIA	0x0
  0296    0229    SUBA	0x29
  0297    3006    LDIA	0x6
  0298    1903    SZB	0x3,2
  0299    0228    SUBA	0x28
  029A    1C03    SNZB	0x3,0
  029B    2AC2    JP	0x2C2
114:                              {
115:                                  CNTbody_h = 0;
  029C    01AA    CLR	0x2A
  029D    01AB    CLR	0x2B
116:                                  CNTbody_l = 0;
  029E    01A8    CLR	0x28
  029F    01A9    CLR	0x29
117:                                  SEQbody = 1;
118:                                  break;
119:                              }
120:                          }
121:                          BufCntAdd = CNTbody_h +CNTbody_l;
  02C2    231D    CALL	0x31D
  02C3    120A    CLRB	0xA,4
  02C4    118A    CLRB	0xA,3
122:                          if(BufCntAdd >= SENSOR_BODY_ENTER_X_0S)
  02C5    3000    LDIA	0x0
  02C6    0227    SUBA	0x27
  02C7    301E    LDIA	0x1E
  02C8    1903    SZB	0x3,2
  02C9    0226    SUBA	0x26
  02CA    1C03    SNZB	0x3,0
  02CB    0008    RET
123:                          {
124:                              SEQbody = 3;
  02CC    3003    LDIA	0x3
  02CD    00BE    LD	0x3E,A
125:                              break;
  02CE    0008    RET
126:                          }
127:                          break;
128:                      /* 感应到人确认 */
129:                      case 3:
130:                          Fbody = SET;
  02CF    147A    SETB	0x7A,0
131:                          FlightLeave = CLR;
  02D0    1147    CLRB	0x47,2
132:                          if(PIsensor == HIGH)
  02D1    1C86    SNZB	0x6,1
  02D2    2AE4    JP	0x2E4
133:                          {
134:                              if(++CNTbody_l >= SENSOR_TRG)
  02D3    0AA8    INCR	0x28
  02D4    1903    SZB	0x3,2
  02D5    0AA9    INCR	0x29
  02D6    3000    LDIA	0x0
  02D7    0229    SUBA	0x29
  02D8    3003    LDIA	0x3
  02D9    1903    SZB	0x3,2
  02DA    0228    SUBA	0x28
  02DB    1C03    SNZB	0x3,0
  02DC    0008    RET
135:                              {
136:                                  CNTbody_h = 0;
  02DD    01AA    CLR	0x2A
  02DE    01AB    CLR	0x2B
137:                                  CNTbody_l = 0;
  02DF    01A8    CLR	0x28
  02E0    01A9    CLR	0x29
138:                                  SEQbody = 4;
  02E1    3004    LDIA	0x4
  02E2    00BE    LD	0x3E,A
139:                                  break;
  02E3    0008    RET
140:                              }
141:                          }
142:                          else
143:                          {
144:                              CNTbody_l = 0;
  02E4    01A8    CLR	0x28
  02E5    01A9    CLR	0x29
  02E6    0008    RET
145:                          }
146:                          break;
147:                      /* 人离开判定开始 */
148:                      case 4:
149:                          Fbody = SET;
  02E7    147A    SETB	0x7A,0
150:                          FlightLeave = SET;
  02E8    1547    SETB	0x47,2
151:                          if(PIsensor == LOW)
  02E9    1886    SZB	0x6,1
  02EA    2AFA    JP	0x2FA
152:                          {
153:                              if(++CNTbody_h >= SENSOR_ERROR)
  02EB    0AAA    INCR	0x2A
  02EC    1903    SZB	0x3,2
  02ED    0AAB    INCR	0x2B
  02EE    3000    LDIA	0x0
  02EF    022B    SUBA	0x2B
  02F0    3006    LDIA	0x6
  02F1    1903    SZB	0x3,2
  02F2    022A    SUBA	0x2A
  02F3    1C03    SNZB	0x3,0
  02F4    2AFD    JP	0x2FD
154:                              {
155:                                  CNTbody_h = 0;
  02F5    01AA    CLR	0x2A
  02F6    01AB    CLR	0x2B
156:                                  CNTbody_l = 0;
  02F7    01A8    CLR	0x28
  02F8    01A9    CLR	0x29
  02F9    2ACC    JP	0x2CC
157:                                  SEQbody = 3;
158:                                  break;
159:                              }
160:                          }
161:                          else
162:                          {
163:                              ++CNTbody_l;
  02FA    0AA8    INCR	0x28
  02FB    1903    SZB	0x3,2
  02FC    0AA9    INCR	0x29
164:                          }
165:                          BufCntAdd = CNTbody_h +CNTbody_l;
  02FD    231D    CALL	0x31D
  02FE    120A    CLRB	0xA,4
  02FF    118A    CLRB	0xA,3
166:                          if(BufCntAdd >= SENSOR_BODY_EXIT_X_0S)      /* 暂改为5s */
  0300    3001    LDIA	0x1
  0301    0227    SUBA	0x27
  0302    30F4    LDIA	0xF4
  0303    1903    SZB	0x3,2
  0304    0226    SUBA	0x26
  0305    1C03    SNZB	0x3,0
  0306    0008    RET
  0307    2AA0    JP	0x2A0
167:                          {
168:                              SEQbody = 1;
169:                              break;
170:                          }
171:                          break;
172:                      default:
173:                          SEQbody = 0;
  0308    01BE    CLR	0x3E
174:                          FlightLeave = CLR;
  0309    1147    CLRB	0x47,2
175:                          break;
  030A    0008    RET
  030B    083E    LD	A,0x3E
  030C    3A00    XORIA	0x0
  030D    1903    SZB	0x3,2
  030E    2A8F    JP	0x28F
  030F    3A01    XORIA	0x1
  0310    1903    SZB	0x3,2
  0311    2AA3    JP	0x2A3
  0312    3A03    XORIA	0x3
  0313    1903    SZB	0x3,2
  0314    2ABB    JP	0x2BB
  0315    3A01    XORIA	0x1
  0316    1903    SZB	0x3,2
  0317    2ACF    JP	0x2CF
  0318    3A07    XORIA	0x7
  0319    1903    SZB	0x3,2
  031A    2AE7    JP	0x2E7
  031B    2B08    JP	0x308
  031C    0008    RET
176:                  }
177:              }
178:              
179:              void SensorControl(void)
180:              {
181:                  FbodyEnter = CLR;
  0273    10FA    CLRB	0x7A,1
182:                  FbodyExit = CLR;
  0274    117A    CLRB	0x7A,2
183:                  if(Fbufbody != Fbody)
  0275    1C7A    SNZB	0x7A,0
  0276    2A79    JP	0x279
  0277    3001    LDIA	0x1
  0278    2A7A    JP	0x27A
  0279    3000    LDIA	0x0
  027A    00F2    LD	0x72,A
  027B    1F7A    SNZB	0x7A,6
  027C    2A7F    JP	0x27F
  027D    3001    LDIA	0x1
  027E    2A80    JP	0x280
  027F    3000    LDIA	0x0
  0280    0672    XORA	0x72
  0281    1903    SZB	0x3,2
  0282    0008    RET
184:                  {
185:                      if(Fbody == SET)
  0283    1C7A    SNZB	0x7A,0
  0284    2A87    JP	0x287
186:                      {
187:                          FbodyEnter = SET;   /* 感应到人瞬间 */
  0285    14FA    SETB	0x7A,1
188:                      }
  0286    2A88    JP	0x288
189:                      else
190:                      {
191:                          FbodyExit = SET;    /* 人离开瞬间 */
  0287    157A    SETB	0x7A,2
192:                      }
193:                      Fbufbody = Fbody;
  0288    1C7A    SNZB	0x7A,0
  0289    2A8C    JP	0x28C
  028A    177A    SETB	0x7A,6
  028B    0008    RET
  028C    137A    CLRB	0x7A,6
  028D    0008    RET
194:                  }
195:              }
196:              
197:              
198:              // void ScanIO(void){
199:              // 	for (SeletedLine = 0; SeletedLine < 2; SeletedLine++)
200:              // 	{
201:              // 		judgeIO();
202:              // 	}
203:              
204:              // }
205:              // uint8_t ScanSignal(uint8_t i)
206:              // {
207:              // 	current_IO_Trgging[(unsigned char)i] = CurrentIO ^ last_IO_value[(unsigned char)i];
208:              
209:              // 	if(current_IO_Trgging[(unsigned char)i])
210:              // 	{
211:              // 		if(last_IO_value[(unsigned char)i])
212:              // 		{
213:              // 			last_IO_value[(unsigned char)i] = CLR;
214:              // 			return TRUE;
215:              // 		}
216:              // 		else
217:              // 		{
218:              // 			last_IO_value[(unsigned char)i] = SET;
219:              // 			IrIrqCnt_H[(unsigned char)i] = CLR;
220:              // 		}
221:              // 	}else if(last_IO_value[(unsigned char)i])	{
222:              // 		if(IrIrqCnt_H[(unsigned char)i] < UINT16_MAX){
223:              // 			IrIrqCnt_H[(unsigned char)i]++;
224:              // 		}
225:              // 	}
226:              // 	else {
227:              // 		if(IrIrqCnt_L[(unsigned char)i] < UINT16_MAX){
228:              // 			IrIrqCnt_L[(unsigned char)i]++;
229:              // 		}
230:              // 	} 
231:              // 	return FALSE;
232:              // }
233:              
234:              // void judgeIO(void)
235:              // {
236:              //     switch (SeletedLine)
237:              // 	{
238:              // 	case PortA:
239:              // 		CurrentIO = PIKey1;
240:              // 		break;
241:              // 	case PortB:
242:              // 		CurrentIO = PIKey2;
243:              // 		break;
244:              // 	default:
245:              // 		break;
246:              // 	}
247:              
248:              //     if(ScanSignal(SeletedLine))
249:              //     {
250:              //         key_flag = SET;
251:              //         switch (SeletedLine)
252:              //         {
253:              //         case PortA:
254:              //         POairPump = SET;
255:              //         POmainValue = SET;
256:              //         POdirectValue = CLR;
257:              //             break;
258:              //         case PortB:
259:              //         POdirectValue= SET;
260:              //         POairPump =SET;
261:              //         POmainValue = CLR;
262:              //             break;
263:              //         default:
264:              //         POdirectValue= CLR;
265:              //         POairPump =CLR;
266:              //         POmainValue = CLR;
267:              //             break;
268:              //         }
269:                       
270:              
271:              //     }
272:              //     else
273:              //     {
274:              //         if(key_flag)
275:              //         {
276:              //              switch (SeletedLine)
277:              //             {
278:              //             case PortA:
279:              //             POairPump = CLR;
280:              //             POmainValue = CLR;
281:              //             POdirectValue = CLR;
282:              //                 break;
283:              //             case PortB:
284:              //             POdirectValue= CLR;
285:              //             POairPump =CLR;
286:              //             POmainValue = CLR;
287:              //                 break;
288:              //             default:
289:              //             POdirectValue= CLR;
290:              //             POairPump =CLR;
291:              //             POmainValue = CLR;
292:              //                 break;
293:              //             }
294:              //             key_flag = CLR;
295:              //         }
296:              //     }
297:                 
298:               
299:              
300:              
301:              // }
302:              
303:              
---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\light.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE FledBits01;
5:                
6:                v_uint16 CNTbreath_Led;
7:                v_uint16 CNTbreath_Led1;
8:                v_uint16 CNTbreath_Led2;
9:                v_uint16 CNTbreath_Led3;
10:               
11:               void LED_Key(void);
12:               void LED_Judge(void);
13:               void LED_Con(void);
14:               void LED_Time(void);
15:               
16:               void GledLoop(void)
17:               {
18:               	LED_Time();
  0326    2331    CALL	0x331
  0327    120A    CLRB	0xA,4
  0328    118A    CLRB	0xA,3
19:               	LED_Key();
  0329    2330    CALL	0x330
  032A    120A    CLRB	0xA,4
  032B    118A    CLRB	0xA,3
20:               	LED_Judge();
  032C    23E0    CALL	0x3E0
  032D    120A    CLRB	0xA,4
  032E    118A    CLRB	0xA,3
21:               	LED_Con();
  032F    2B34    JP	0x334
22:               }
23:               
24:               void LED_Key(void)
  0330    0008    RET
25:               {
26:               	// switch(SiCon_SETkey)
27:               	// {	
28:               	// 	case KEY_LIGHT:
29:               	// 		Flight = ~Flight;
30:               	// 		if(Flight == SET)
31:               	// 		{
32:               	// 			GbuzOutSet(2);
33:               	// 		}
34:               	// 		else
35:               	// 		{
36:               	// 			GbuzOutSet(1);
37:               	// 		}
38:               	// 		break;
39:               	// 	default:
40:               			
41:               	// 		break;
42:               	// }
43:               }
44:               
45:               void LED_Time(void)
46:               {
47:               	if(F1min_lgt == SET)
  0331    1848    SZB	0x48,0
48:               	{
49:               		F1min_lgt = CLR;
  0332    1048    CLRB	0x48,0
  0333    0008    RET
50:               	}
51:               }
52:               
53:               void LED_Judge(void)
54:               {
55:               	if(Fbody == SET)	/* 感应到人开启 */
  03E0    1C7A    SNZB	0x7A,0
  03E1    2BE6    JP	0x3E6
56:               	{
57:               		Flight = SET;
  03E2    1447    SETB	0x47,0
58:               		if(FbodyIn5s == CLR)	/* 检测到人5秒之内 */
  03E3    1E7A    SNZB	0x7A,4
59:               		{
60:               			if(FlightLeave == SET)	/* 离开状态，熄灭指示灯 */
  03E4    1D47    SNZB	0x47,2
  03E5    0008    RET
61:               			{
62:               				Flight = CLR;
  03E6    1047    CLRB	0x47,0
  03E7    0008    RET
63:               			}
64:               		}
65:               	}
66:               	else
67:               	{
68:               		// if(Fbuflight == SET)
69:               		// {
70:               		// 	Flight = SET;	/* 离开5s内 */
71:               		// 	if(FbodyEx5s == SET)
72:               		// 	{
73:               		// 		Flight = CLR;
74:               		// 		Fbuflight = CLR;
75:               		// 	}
76:               		// }
77:               		// else
78:               		// {
79:               			Flight = CLR;
80:               		// }
81:               	}
82:               }
83:               
84:               void LED_Con(void)
85:               {
86:               	POlight	= Flight;
  0334    1C47    SNZB	0x47,0
  0335    2B3A    JP	0x33A
  0336    1283    CLRB	0x3,5
  0337    1303    CLRB	0x3,6
  0338    1685    SETB	0x5,5
  0339    2B3D    JP	0x33D
  033A    1283    CLRB	0x3,5
  033B    1303    CLRB	0x3,6
  033C    1285    CLRB	0x5,5
87:               	/* 呼吸灯频率 */
88:               	if (Flight == SET)
  033D    1C47    SNZB	0x47,0
  033E    2BD7    JP	0x3D7
89:               	{
90:               		if (FbreathDir == CLR)
  033F    19C7    SZB	0x47,3
  0340    2B8D    JP	0x38D
91:               		{
92:               			if (CNTbreath_Led2 >= 80)	/* 亮度降低 */
  0341    3000    LDIA	0x0
  0342    0235    SUBA	0x35
  0343    3050    LDIA	0x50
  0344    1903    SZB	0x3,2
  0345    0234    SUBA	0x34
  0346    1C03    SNZB	0x3,0
  0347    2B59    JP	0x359
93:               			{
94:               				CNTbreath_Led2 = 80;
  0348    3050    LDIA	0x50
  0349    00B4    LD	0x34,A
  034A    01B5    CLR	0x35
95:               				if (++CNTbreath_Led3 > 10)	/* 100ms，min */
  034B    0AB2    INCR	0x32
  034C    1903    SZB	0x3,2
  034D    0AB3    INCR	0x33
  034E    3000    LDIA	0x0
  034F    0233    SUBA	0x33
  0350    300B    LDIA	0xB
  0351    1903    SZB	0x3,2
  0352    0232    SUBA	0x32
  0353    1C03    SNZB	0x3,0
  0354    0008    RET
96:               				{
97:               					FbreathDir = SET;
  0355    15C7    SETB	0x47,3
98:               					CNTbreath_Led3 = 0;
  0356    01B2    CLR	0x32
  0357    01B3    CLR	0x33
  0358    0008    RET
99:               				}
100:              			}
101:              			else if (CNTbreath_Led2 > 45)	/* 35*4*10=1050ms */
  0359    3000    LDIA	0x0
  035A    0235    SUBA	0x35
  035B    302E    LDIA	0x2E
  035C    1903    SZB	0x3,2
  035D    0234    SUBA	0x34
  035E    1C03    SNZB	0x3,0
  035F    2B78    JP	0x378
102:              			{
103:              				if (++CNTbreath_Led1 >= 3)
  0360    23E8    CALL	0x3E8
  0361    120A    CLRB	0xA,4
  0362    118A    CLRB	0xA,3
  0363    2B6E    JP	0x36E
104:              				{
105:              					CNTbreath_Led1 = 0;
  0372    01B6    CLR	0x36
  0373    01B7    CLR	0x37
106:              					CNTbreath_Led2++;
  0374    0AB4    INCR	0x34
  0375    1903    SZB	0x3,2
  0376    0AB5    INCR	0x35
  0377    0008    RET
107:              				}
108:              			}
109:              			else if (CNTbreath_Led2 > 30)	/* 15*8*10 = 1200ms */
  0378    3000    LDIA	0x0
  0379    0235    SUBA	0x35
  037A    301F    LDIA	0x1F
  037B    1903    SZB	0x3,2
  037C    0234    SUBA	0x34
  037D    1803    SZB	0x3,0
  037E    2B64    JP	0x364
110:              			{
111:              				if (++CNTbreath_Led1 >= 8)
  0364    23EE    CALL	0x3EE
  0365    120A    CLRB	0xA,4
  0366    118A    CLRB	0xA,3
  0367    2B6E    JP	0x36E
112:              				{
113:              					CNTbreath_Led1 = 0;
114:              					CNTbreath_Led2++;
115:              				}
116:              			}
117:              			else if (CNTbreath_Led2 > 10)	/* 1000ms */
  037F    3000    LDIA	0x0
  0380    0235    SUBA	0x35
  0381    300B    LDIA	0xB
  0382    1903    SZB	0x3,2
  0383    0234    SUBA	0x34
  0384    1803    SZB	0x3,0
  0385    2B68    JP	0x368
118:              			{
119:              				if (++CNTbreath_Led1 >= 5)
  0368    0AB6    INCR	0x36
  0369    1903    SZB	0x3,2
  036A    0AB7    INCR	0x37
  036B    3000    LDIA	0x0
  036C    0237    SUBA	0x37
  036D    3005    LDIA	0x5
  036E    1903    SZB	0x3,2
  036F    0236    SUBA	0x36
  0370    1C03    SNZB	0x3,0
  0371    0008    RET
120:              				{
121:              					CNTbreath_Led1 = 0;
122:              					CNTbreath_Led2++;
123:              				}
124:              			}
125:              			else
126:              			{
127:              				if (++CNTbreath_Led1 >= 11)	/* (11-5)*10=600ms，max */
  0386    0AB6    INCR	0x36
  0387    1903    SZB	0x3,2
  0388    0AB7    INCR	0x37
  0389    3000    LDIA	0x0
  038A    0237    SUBA	0x37
  038B    300B    LDIA	0xB
  038C    2B6E    JP	0x36E
128:              				{
129:              					CNTbreath_Led1 = 0;
130:              					CNTbreath_Led2++;
131:              				}
132:              			}
133:              		}
134:              		else
135:              		{
136:              			if (CNTbreath_Led2 < 5)	/* max */
  038D    3000    LDIA	0x0
  038E    0235    SUBA	0x35
  038F    3005    LDIA	0x5
  0390    1903    SZB	0x3,2
  0391    0234    SUBA	0x34
  0392    1803    SZB	0x3,0
  0393    2B99    JP	0x399
137:              			{
138:              				CNTbreath_Led2 = 5;
  0394    3005    LDIA	0x5
  0395    00B4    LD	0x34,A
  0396    01B5    CLR	0x35
139:              				FbreathDir = CLR;
  0397    11C7    CLRB	0x47,3
140:              			}
  0398    0008    RET
141:              			else if (CNTbreath_Led2 < 10)
  0399    3000    LDIA	0x0
  039A    0235    SUBA	0x35
  039B    300A    LDIA	0xA
  039C    1903    SZB	0x3,2
  039D    0234    SUBA	0x34
  039E    1803    SZB	0x3,0
  039F    2BBE    JP	0x3BE
142:              			{
143:              				if (++CNTbreath_Led1 >= 6)	/* 600ms */
144:              				{
145:              					CNTbreath_Led1 = 0;
  03B5    01B6    CLR	0x36
  03B6    01B7    CLR	0x37
146:              					CNTbreath_Led2--;
  03B7    3001    LDIA	0x1
  03B8    02B4    SUBR	0x34
  03B9    3000    LDIA	0x0
  03BA    1C03    SNZB	0x3,0
  03BB    03B5    DECR	0x35
  03BC    02B5    SUBR	0x35
  03BD    0008    RET
147:              				}
148:              			}
149:              			else if (CNTbreath_Led2 < 30)
  03BE    3000    LDIA	0x0
  03BF    0235    SUBA	0x35
  03C0    301E    LDIA	0x1E
  03C1    1903    SZB	0x3,2
  03C2    0234    SUBA	0x34
  03C3    1C03    SNZB	0x3,0
  03C4    2BA0    JP	0x3A0
150:              			{
151:              				if (++CNTbreath_Led1 >= 6)	/* 1200ms */
  03A0    0AB6    INCR	0x36
  03A1    1903    SZB	0x3,2
  03A2    0AB7    INCR	0x37
  03A3    3000    LDIA	0x0
  03A4    0237    SUBA	0x37
  03A5    3006    LDIA	0x6
  03A6    2BB1    JP	0x3B1
152:              				{
153:              					CNTbreath_Led1 = 0;
154:              					CNTbreath_Led2--;
155:              				}
156:              			}
157:              			else if (CNTbreath_Led2 < 40)
  03C5    3000    LDIA	0x0
  03C6    0235    SUBA	0x35
  03C7    3028    LDIA	0x28
  03C8    1903    SZB	0x3,2
  03C9    0234    SUBA	0x34
  03CA    1C03    SNZB	0x3,0
  03CB    2BA7    JP	0x3A7
158:              			{
159:              				if (++CNTbreath_Led1 >= 8)	/* 800ms */
  03A7    23EE    CALL	0x3EE
  03A8    120A    CLRB	0xA,4
  03A9    118A    CLRB	0xA,3
  03AA    2BB1    JP	0x3B1
160:              				{
161:              					CNTbreath_Led1 = 0;
162:              					CNTbreath_Led2--;
163:              				}
164:              			}
165:              			else if (CNTbreath_Led2 < 60)
  03CC    3000    LDIA	0x0
  03CD    0235    SUBA	0x35
  03CE    303C    LDIA	0x3C
  03CF    1903    SZB	0x3,2
  03D0    0234    SUBA	0x34
  03D1    1C03    SNZB	0x3,0
  03D2    2BAB    JP	0x3AB
166:              			{
167:              				if (++CNTbreath_Led1 >= 4)	/* 800ms */
  03AB    0AB6    INCR	0x36
  03AC    1903    SZB	0x3,2
  03AD    0AB7    INCR	0x37
  03AE    3000    LDIA	0x0
  03AF    0237    SUBA	0x37
  03B0    3004    LDIA	0x4
  03B1    1903    SZB	0x3,2
  03B2    0236    SUBA	0x36
  03B3    1C03    SNZB	0x3,0
  03B4    0008    RET
168:              				{
169:              					CNTbreath_Led1 = 0;
170:              					CNTbreath_Led2--;
171:              				}
172:              			}
173:              			else
174:              			{
175:              				if (++CNTbreath_Led1 >= 3)	/* 600ms，min */
  03D3    23E8    CALL	0x3E8
  03D4    120A    CLRB	0xA,4
  03D5    118A    CLRB	0xA,3
  03D6    2BB1    JP	0x3B1
176:              				{
177:              					CNTbreath_Led1 = 0;
178:              					CNTbreath_Led2--;
179:              				}
180:              			}
181:              		}
182:              	}
183:              	else
184:              	{
185:              		CNTbreath_Led1 = 0;
  03D7    01B6    CLR	0x36
  03D8    01B7    CLR	0x37
186:              		CNTbreath_Led2 = 0;
  03D9    01B4    CLR	0x34
  03DA    01B5    CLR	0x35
187:              		CNTbreath_Led3 = 0;
  03DB    01B2    CLR	0x32
  03DC    01B3    CLR	0x33
188:              		FbreathDir = CLR;
  03DD    11C7    CLRB	0x47,3
189:              		POlight = OFF;
  03DE    1285    CLRB	0x5,5
  03DF    0008    RET
190:              	}
191:              }
192:              
193:              void INT_LED_SHOW(void)
194:              {
195:              	// if((Flight == SET) && (FfctTest == CLR))
196:              	if(Flight == SET)
  04E9    1C47    SNZB	0x47,0
  04EA    0008    RET
197:              	{
198:              		if (++CNTbreath_Led == 80)
  04EB    0AB8    INCR	0x38
  04EC    1903    SZB	0x3,2
  04ED    0AB9    INCR	0x39
  04EE    3050    LDIA	0x50
  04EF    0638    XORA	0x38
  04F0    0439    ORA	0x39
  04F1    1D03    SNZB	0x3,2
  04F2    2CF6    JP	0x4F6
199:              		{
200:              			CNTbreath_Led = 0;
  04F3    01B8    CLR	0x38
  04F4    01B9    CLR	0x39
201:              			POlight = OFF;
  04F5    1285    CLRB	0x5,5
202:              		}
203:              		if (CNTbreath_Led >= CNTbreath_Led2)
  04F6    0835    LD	A,0x35
  04F7    0239    SUBA	0x39
  04F8    1D03    SNZB	0x3,2
  04F9    2CFC    JP	0x4FC
  04FA    0834    LD	A,0x34
  04FB    0238    SUBA	0x38
  04FC    1C03    SNZB	0x3,0
  04FD    2D00    JP	0x500
204:              		{
205:              			POlight = ON;
  04FE    1685    SETB	0x5,5
206:              		}
  04FF    0008    RET
207:              		else
208:              		{
209:              			POlight = OFF;
  0500    1285    CLRB	0x5,5
  0501    0008    RET
210:              		}
211:              	}
212:              }
---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\flush.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fflush1;
5:                
6:                
7:                
8:                v_uint8 SEQflsuh = 0;
9:                v_uint16 CNTflush = 0;  /* 冲水计时 */
10:               
11:               void FlushTime(void);
12:               void FlushJudge(void);
13:               void FlushCon(void);
14:               
15:               void GflushLoop(void)
16:               {
17:                   FlushTime();
  001C    2023    CALL	0x23
  001D    120A    CLRB	0xA,4
  001E    118A    CLRB	0xA,3
18:                   FlushJudge();
  001F    20EC    CALL	0xEC
  0020    120A    CLRB	0xA,4
  0021    118A    CLRB	0xA,3
19:                   FlushCon();
  0022    2824    JP	0x24
20:               }
21:               
22:               void FlushTime(void)
  0023    0008    RET
23:               {
24:               
25:               }
26:               void FlushJudge(void)
27:               {
28:                   uint8_t Key_Step = 0;
29:                   /* 请求判定 */
30:                   #if DUBLE_FLUSH_MODE
31:                   if(FbodyIn60s == SET)   /* 感应到60秒以上，大冲请求置位 */
  00EC    1DFA    SNZB	0x7A,3
  00ED    28F1    JP	0xF1
32:                   {
33:                       YKfls_Big = SET;
  00EE    1441    SETB	0x41,0
34:                       YKfls_Sml = CLR;
  00EF    1141    CLRB	0x41,2
35:                   }
  00F0    2907    JP	0x107
36:                   else if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
  00F1    1E7A    SNZB	0x7A,4
  00F2    28F5    JP	0xF5
37:                   {
38:                       YKfls_Sml = SET;
  00F3    1541    SETB	0x41,2
  00F4    28F9    JP	0xF9
39:                       YKfls_Big = CLR;
40:                   }
41:                   else if (SEQflsuh)
  00F5    0840    LD	A,0x40
  00F6    1903    SZB	0x3,2
  00F7    28FB    JP	0xFB
42:                   {
43:                       YKfls_Sml = CLR;
  00F8    1141    CLRB	0x41,2
44:                       YKfls_Big = CLR;
  00F9    1041    CLRB	0x41,0
45:                   }
  00FA    2907    JP	0x107
46:                   else
47:                   {
48:                       Key_Step = GkeyLoop();
  00FB    211B    CALL	0x11B
  00FC    120A    CLRB	0xA,4
  00FD    118A    CLRB	0xA,3
  00FE    00F6    LD	0x76,A
49:                       if (Key_Step)
  00FF    0876    LD	A,0x76
  0100    1903    SZB	0x3,2
  0101    28F8    JP	0xF8
50:                       {
51:                           SEQflsuh = Key_Step;
  0102    0876    LD	A,0x76
  0103    00C0    LD	0x40,A
52:                           CNTflush = 0;
  0104    01AC    CLR	0x2C
  0105    01AD    CLR	0x2D
53:                           Flush_AutoLeaveWait = SET;
  0106    17C1    SETB	0x41,7
54:                       }else
55:                       {
56:                          YKfls_Sml = CLR;
57:                           YKfls_Big = CLR;
58:                       }
59:                   }
60:               #else
61:                   if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
62:                   {
63:                       // YKfls_Sml = SET;
64:                       // YKfls_Big = CLR;
65:                       YKfls_Sml = CLR;
66:                       YKfls_Big = SET;
67:                   }
68:                   else
69:                   {
70:                       YKfls_Sml = CLR;
71:                       YKfls_Big = CLR;
72:                   }
73:               #endif
74:                   /*********************************************/
75:               	/*	自动冲水判断	*/
76:               	if (FbodyExit == SET)	/* 离开冲水 */
  0107    197A    SZB	0x7A,2
77:               	{
78:                       Flush_AutoLeaveWait = SET;
  0108    17C1    SETB	0x41,7
79:               	}
80:               	if (Flush_AutoLeaveWait == SET) /*	离开自动冲水	*/
  0109    1FC1    SNZB	0x41,7
  010A    0008    RET
81:               	{
82:               		if (f_STSflush == SET)
  010B    1F41    SNZB	0x41,6
  010C    2910    JP	0x110
83:               		{
84:                           YKfls_Sml = CLR;
  010D    1141    CLRB	0x41,2
85:                           YKfls_Big = CLR;    /* 正在冲水，请求清除 */
  010E    1041    CLRB	0x41,0
86:               			return;
  010F    0008    RET
87:               		}
88:               		Flush_AutoLeaveWait = CLR;
  0110    13C1    CLRB	0x41,7
89:                       if(YKfls_Big == SET)
  0111    1C41    SNZB	0x41,0
  0112    2916    JP	0x116
90:                       {
91:                           YKfls_Big = CLR;
  0113    1041    CLRB	0x41,0
92:                           OKfls_Big = SET;
  0114    14C1    SETB	0x41,1
93:                           return;
  0115    0008    RET
94:                       }
95:               		if(YKfls_Sml == SET)
  0116    1D41    SNZB	0x41,2
  0117    0008    RET
96:                       {
97:                           YKfls_Sml = CLR;
  0118    1141    CLRB	0x41,2
98:                           OKfls_Sml = SET;
  0119    15C1    SETB	0x41,3
  011A    0008    RET
99:                       }
100:              		return;
101:              	}
102:              	/*	自动冲水判断	*/
103:              	/******************************************/
104:              }
105:              
106:              /* 主阀气泵控制函数 */
107:              void FlushCon(void)
108:              {
109:                  switch (SEQflsuh)
  0024    28C8    JP	0xC8
110:                  {
111:                      case FLUSH_INIT_0:
112:                          f_STSflush = CLR;
  0025    1341    CLRB	0x41,6
113:                          POairPump = OFF;
  0026    1105    CLRB	0x5,2
114:                          POmainValue = OFF;
  0027    1205    CLRB	0x5,4
115:                          POdirectValue = OFF;
  0028    1085    CLRB	0x5,1
116:                          if((OKfls_Big == SET) || (OKfls_Sml == SET))
  0029    18C1    SZB	0x41,1
  002A    282D    JP	0x2D
  002B    1DC1    SNZB	0x41,3
  002C    0008    RET
117:                          {
118:                              SEQflsuh = FLUSH_INIT_1;
  002D    3001    LDIA	0x1
  002E    2830    JP	0x30
119:                              CNTflush = 0;
  0031    01AC    CLR	0x2C
  0032    01AD    CLR	0x2D
  0033    0008    RET
120:                          }
121:                          break;
122:                      case FLUSH_INIT_1:
123:                          f_STSflush = SET;
  0034    1741    SETB	0x41,6
124:                          POairPump = OFF;
  0035    1105    CLRB	0x5,2
125:                          POmainValue = OFF;
  0036    1205    CLRB	0x5,4
126:                          POdirectValue = OFF;
  0037    1085    CLRB	0x5,1
127:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  0038    187A    SZB	0x7A,0
  0039    282F    JP	0x2F
128:                          {
129:                              SEQflsuh = FLUSH_END_0;
  002F    3009    LDIA	0x9
  0030    00C0    LD	0x40,A
130:                              CNTflush = 0;
131:                              break;
132:                          }
133:                          if(++CNTflush >= 5)
  003A    0AAC    INCR	0x2C
  003B    1903    SZB	0x3,2
  003C    0AAD    INCR	0x2D
  003D    3000    LDIA	0x0
  003E    022D    SUBA	0x2D
  003F    3005    LDIA	0x5
  0040    1903    SZB	0x3,2
  0041    022C    SUBA	0x2C
  0042    1C03    SNZB	0x3,0
  0043    0008    RET
134:                          {
135:                              CNTflush = 0;
  0044    01AC    CLR	0x2C
  0045    01AD    CLR	0x2D
136:                              SEQflsuh = FLUSH_INIT_2;
  0046    3002    LDIA	0x2
  0047    00C0    LD	0x40,A
  0048    0008    RET
137:                          }
138:                          break;
139:                      case FLUSH_INIT_2:
140:                          f_STSflush = SET;
  0049    1741    SETB	0x41,6
141:                          POairPump = OFF;        /* 冲水关闭 */
  004A    1105    CLRB	0x5,2
142:                          POmainValue = OFF;      /* 冲水通道1  默认冲水通道,先假设无默认尝试*/ 
  004B    1205    CLRB	0x5,4
143:                          POdirectValue = OFF;
  004C    1085    CLRB	0x5,1
144:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  004D    187A    SZB	0x7A,0
  004E    282F    JP	0x2F
145:                          {
146:                              SEQflsuh = FLUSH_END_0;
147:                              CNTflush = 0;
148:                              break;
149:                          }
150:              
151:                          if(OKfls_Big == SET)
  004F    1CC1    SNZB	0x41,1
  0050    2854    JP	0x54
152:                          {
153:                              SEQflsuh = FLUSH_BIG_0;
  0051    3003    LDIA	0x3
  0052    00C0    LD	0x40,A
154:                          }
  0053    0008    RET
155:                          else if(OKfls_Sml == SET)
  0054    1DC1    SNZB	0x41,3
  0055    0008    RET
156:                          {
157:                              SEQflsuh = FLUSH_SML_0;
  0056    3006    LDIA	0x6
  0057    00C0    LD	0x40,A
  0058    0008    RET
158:                          }
159:                          break;
160:                      case FLUSH_BIG_0:   /* 大冲阶段 */
161:                          f_STSflush = SET;
162:                          POairPump = OFF;        /* 大冲先开电磁阀换大冲，后开气泵冲水 */
163:                          POmainValue = ON;            /* 大冲*/
164:                          POdirectValue = ON;
165:                          if(++CNTflush >= 10)    /* 延迟100ms后打开气泵冲水 */
  0059    221F    CALL	0x21F
  005A    120A    CLRB	0xA,4
  005B    118A    CLRB	0xA,3
  005C    1903    SZB	0x3,2
  005D    022C    SUBA	0x2C
  005E    1C03    SNZB	0x3,0
  005F    0008    RET
166:                          {
167:                              CNTflush = 0;
  0060    01AC    CLR	0x2C
  0061    01AD    CLR	0x2D
168:                              SEQflsuh = FLUSH_BIG_1;
  0062    3004    LDIA	0x4
  0063    00C0    LD	0x40,A
  0064    0008    RET
169:                          }
170:                          break;
171:                      case FLUSH_BIG_1:
172:                          f_STSflush = SET;
  0065    1741    SETB	0x41,6
173:                          POairPump = ON;
  0066    1505    SETB	0x5,2
174:                          POmainValue = ON;
  0067    1605    SETB	0x5,4
175:                          POdirectValue = ON;
  0068    1485    SETB	0x5,1
176:              #if ABM007_FLUSH_2
177:                          if(++CNTflush >= 100)   /* 冲水1s */
  0069    0AAC    INCR	0x2C
  006A    1903    SZB	0x3,2
  006B    0AAD    INCR	0x2D
  006C    3000    LDIA	0x0
  006D    022D    SUBA	0x2D
  006E    3064    LDIA	0x64
  006F    1903    SZB	0x3,2
  0070    022C    SUBA	0x2C
  0071    1C03    SNZB	0x3,0
  0072    0008    RET
178:                          {
179:                              CNTflush = 0;
  0073    01AC    CLR	0x2C
  0074    01AD    CLR	0x2D
180:                              SEQflsuh = FLUSH_BIG_2;
  0075    3005    LDIA	0x5
  0076    00C0    LD	0x40,A
  0077    0008    RET
181:                          }
182:              #else
183:                          //if(++CNTflush >= 200)   /* 冲水2s */
184:                          if(++CNTflush >= 100)   /* 冲水1s */
185:                          {
186:                              CNTflush = 0;
187:                              SEQflsuh = FLUSH_BIG_2;
188:                          }
189:              #endif
190:                          break;
191:                      case FLUSH_BIG_2:
192:                          f_STSflush = SET;
193:                          POairPump = OFF;        /* 关气泵，停止冲水 */
194:                          POmainValue = SET;      /* 大冲先关气泵停止冲水，后关主阀 */    /* 冲水通道2 */
195:                          POdirectValue = SET;
196:                          if(++CNTflush >= 10)
  0078    221F    CALL	0x21F
  0079    120A    CLRB	0xA,4
  007A    118A    CLRB	0xA,3
  007B    1903    SZB	0x3,2
  007C    022C    SUBA	0x2C
  007D    1C03    SNZB	0x3,0
  007E    0008    RET
197:                          {
198:                              CNTflush = 0;
  007F    01AC    CLR	0x2C
  0080    01AD    CLR	0x2D
199:                              SEQflsuh = FLUSH_END_0;
  0081    3009    LDIA	0x9
  0082    00C0    LD	0x40,A
  0083    0008    RET
200:                          }
201:                          break;
202:              
203:                      case FLUSH_SML_0:           /* 小冲阶段 */
204:                          f_STSflush = SET;
205:                          POairPump = OFF;        /* 小冲先开主阀阀换小冲，后开气泵冲水 */
206:                          POmainValue = ON;      /* 冲水通道1 */
207:                          POdirectValue = OFF;
208:                          if(++CNTflush >= 5)
  0084    2215    CALL	0x215
  0085    120A    CLRB	0xA,4
  0086    118A    CLRB	0xA,3
  0087    1903    SZB	0x3,2
  0088    022C    SUBA	0x2C
  0089    1C03    SNZB	0x3,0
  008A    0008    RET
209:                          {
210:                              CNTflush = 0;
  008B    01AC    CLR	0x2C
  008C    01AD    CLR	0x2D
211:                              SEQflsuh = FLUSH_SML_1;
  008D    3007    LDIA	0x7
  008E    00C0    LD	0x40,A
  008F    0008    RET
212:                          }
213:                          break;
214:                      case FLUSH_SML_1:
215:                          f_STSflush = SET;
  0090    1741    SETB	0x41,6
216:                          POairPump = ON;         /* 冲水 */
  0091    1505    SETB	0x5,2
217:                          POmainValue = ON;      /* 冲水通道1 */
  0092    1605    SETB	0x5,4
218:                          POdirectValue = OFF;
219:                          // if(++CNTflush >= 200)
220:                          if(++CNTflush >= 100)
  0093    2229    CALL	0x229
  0094    120A    CLRB	0xA,4
  0095    118A    CLRB	0xA,3
  0096    3064    LDIA	0x64
  0097    1903    SZB	0x3,2
  0098    022C    SUBA	0x2C
  0099    1C03    SNZB	0x3,0
  009A    0008    RET
221:                          {
222:                              CNTflush = 0;
  009B    01AC    CLR	0x2C
  009C    01AD    CLR	0x2D
223:                              SEQflsuh = FLUSH_SML_2;
  009D    3008    LDIA	0x8
  009E    00C0    LD	0x40,A
  009F    0008    RET
224:                          }
225:                          break;
226:                      case FLUSH_SML_2:
227:                          f_STSflush = SET;
228:                          POairPump = OFF;        /* 关气泵，停止冲水 */
229:                          POmainValue = ON;      /* 冲水通道1 */
230:                          POdirectValue = OFF;
231:                          if(++CNTflush >= 5)
  00A0    2215    CALL	0x215
  00A1    120A    CLRB	0xA,4
  00A2    118A    CLRB	0xA,3
  00A3    287B    JP	0x7B
232:                          {
233:                              CNTflush = 0;
234:                              SEQflsuh = FLUSH_END_0;
235:                          }
236:                          break;
237:              
238:                      case FLUSH_END_0:
239:                          f_STSflush = SET;
  00A4    1741    SETB	0x41,6
240:                          POairPump = OFF;        /* 停止冲水 */
  00A5    1105    CLRB	0x5,2
241:                          POmainValue = OFF;      /* 返回通道1 */
  00A6    1205    CLRB	0x5,4
242:                          POdirectValue = OFF;
243:                          if(++CNTflush >= 5)
  00A7    2229    CALL	0x229
  00A8    120A    CLRB	0xA,4
  00A9    118A    CLRB	0xA,3
  00AA    3005    LDIA	0x5
  00AB    1903    SZB	0x3,2
  00AC    022C    SUBA	0x2C
  00AD    1C03    SNZB	0x3,0
  00AE    0008    RET
244:                          {
245:                              CNTflush = 0;
  00AF    01AC    CLR	0x2C
  00B0    01AD    CLR	0x2D
246:                              SEQflsuh = FLUSH_END_1;
  00B1    300A    LDIA	0xA
  00B2    00C0    LD	0x40,A
  00B3    0008    RET
247:                          }
248:                          break;
249:                      case FLUSH_END_1:
250:                          f_STSflush = CLR;
  00B4    1341    CLRB	0x41,6
251:                          POairPump = OFF;
  00B5    1105    CLRB	0x5,2
252:                          POmainValue = OFF;
  00B6    1205    CLRB	0x5,4
253:                          POdirectValue = OFF;
  00B7    1085    CLRB	0x5,1
254:                          SEQflsuh = FLUSH_INIT_0;
  00B8    01C0    CLR	0x40
255:                          CNTflush = 0;
  00B9    01AC    CLR	0x2C
  00BA    01AD    CLR	0x2D
256:                          OKfls_Big = CLR;
  00BB    10C1    CLRB	0x41,1
257:                          OKfls_Sml = CLR;
  00BC    11C1    CLRB	0x41,3
258:                          break;
  00BD    0008    RET
259:                      default:
260:                          f_STSflush = CLR;
  00BE    1341    CLRB	0x41,6
261:                          POairPump = OFF;
  00BF    1105    CLRB	0x5,2
262:                          POmainValue = OFF;
  00C0    1205    CLRB	0x5,4
263:                          POdirectValue = OFF;
  00C1    1085    CLRB	0x5,1
264:                          OKfls_Big = CLR;
  00C2    10C1    CLRB	0x41,1
265:                          OKfls_Sml = CLR;
  00C3    11C1    CLRB	0x41,3
266:                          SEQflsuh = FLUSH_INIT_0;
  00C4    01C0    CLR	0x40
267:                          CNTflush = 0;
  00C5    01AC    CLR	0x2C
  00C6    01AD    CLR	0x2D
268:                          break;
  00C7    0008    RET
  00C8    0840    LD	A,0x40
  00C9    3A00    XORIA	0x0
  00CA    1903    SZB	0x3,2
  00CB    2825    JP	0x25
  00CC    3A01    XORIA	0x1
  00CD    1903    SZB	0x3,2
  00CE    2834    JP	0x34
  00CF    3A03    XORIA	0x3
  00D0    1903    SZB	0x3,2
  00D1    2849    JP	0x49
  00D2    3A01    XORIA	0x1
  00D3    1903    SZB	0x3,2
  00D4    2859    JP	0x59
  00D5    3A07    XORIA	0x7
  00D6    1903    SZB	0x3,2
  00D7    2865    JP	0x65
  00D8    3A01    XORIA	0x1
  00D9    1903    SZB	0x3,2
  00DA    2878    JP	0x78
  00DB    3A03    XORIA	0x3
  00DC    1903    SZB	0x3,2
  00DD    2884    JP	0x84
  00DE    3A01    XORIA	0x1
  00DF    1903    SZB	0x3,2
  00E0    2890    JP	0x90
  00E1    3A0F    XORIA	0xF
  00E2    1903    SZB	0x3,2
  00E3    28A0    JP	0xA0
  00E4    3A01    XORIA	0x1
  00E5    1903    SZB	0x3,2
  00E6    28A4    JP	0xA4
  00E7    3A03    XORIA	0x3
  00E8    1903    SZB	0x3,2
  00E9    28B4    JP	0xB4
  00EA    28BE    JP	0xBE
  00EB    0008    RET
269:                  }
270:              }
271:              
272:              
---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\key.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                #include "key_Private.h"
4:                
5:                
6:                
7:                uint8_t GkeyLoop(void)
8:                {
9:                	for ( SeletedLine = 0; SeletedLine < 2; SeletedLine++)
  011B    01F9    CLR	0x79
  011C    3002    LDIA	0x2
  011D    0279    SUBA	0x79
  011E    1803    SZB	0x3,0
  011F    3400    RET	0x0
10:               	{
11:               		KeyLines[SeletedLine].flags.level =ScanKey(SeletedLine);
  0120    0879    LD	A,0x79
  0121    2202    CALL	0x202
  0122    120A    CLRB	0xA,4
  0123    118A    CLRB	0xA,3
  0124    00F4    LD	0x74,A
  0125    0879    LD	A,0x79
  0126    00F5    LD	0x75,A
  0127    3001    LDIA	0x1
  0128    1003    CLRB	0x3,0
  0129    0DF5    RLCR	0x75
  012A    3EFF    ADDIA	0xFF
  012B    1003    CLRB	0x3,0
  012C    1D03    SNZB	0x3,2
  012D    2929    JP	0x129
  012E    0D75    RLCA	0x75
  012F    3E4B    ADDIA	0x4B
  0130    0084    LD	0x4,A
  0131    0DF4    RLCR	0x74
  0132    0DF4    RLCR	0x74
  0133    1383    CLRB	0x3,7
  0134    0800    LD	A,0x0
  0135    0674    XORA	0x74
  0136    39FB    ANDIA	0xFB
  0137    0674    XORA	0x74
  0138    0080    LD	0x0,A
12:               
13:               		if(KeyLines[SeletedLine].flags.is_forbidden)
  0139    0879    LD	A,0x79
  013A    00F4    LD	0x74,A
  013B    3001    LDIA	0x1
  013C    1003    CLRB	0x3,0
  013D    0DF4    RLCR	0x74
  013E    3EFF    ADDIA	0xFF
  013F    1003    CLRB	0x3,0
  0140    1D03    SNZB	0x3,2
  0141    293D    JP	0x13D
  0142    0D74    RLCA	0x74
  0143    3E4B    ADDIA	0x4B
  0144    0084    LD	0x4,A
  0145    1C00    SNZB	0x0,0
  0146    2963    JP	0x163
14:               		{
15:               			if (KeyLines[SeletedLine].flags.level)
  0147    0879    LD	A,0x79
  0148    00F4    LD	0x74,A
  0149    3001    LDIA	0x1
  014A    1003    CLRB	0x3,0
  014B    0DF4    RLCR	0x74
  014C    3EFF    ADDIA	0xFF
  014D    1003    CLRB	0x3,0
  014E    1D03    SNZB	0x3,2
  014F    294B    JP	0x14B
  0150    0D74    RLCA	0x74
  0151    3E4B    ADDIA	0x4B
  0152    0084    LD	0x4,A
  0153    1D00    SNZB	0x0,2
  0154    2983    JP	0x183
16:               			{
17:               				KeyLines[SeletedLine].flags.is_forbidden = CLR;
  0155    0879    LD	A,0x79
  0156    00F4    LD	0x74,A
  0157    3001    LDIA	0x1
  0158    1003    CLRB	0x3,0
  0159    0DF4    RLCR	0x74
  015A    3EFF    ADDIA	0xFF
  015B    1003    CLRB	0x3,0
  015C    1D03    SNZB	0x3,2
  015D    2959    JP	0x159
  015E    0D74    RLCA	0x74
  015F    3E4B    ADDIA	0x4B
  0160    0084    LD	0x4,A
  0161    1000    CLRB	0x0,0
  0162    2983    JP	0x183
18:               			}
19:               			continue;
20:               		}
21:               		if (KeyControl(&KeyLines[SeletedLine]))
  0163    0879    LD	A,0x79
  0164    00F4    LD	0x74,A
  0165    3001    LDIA	0x1
  0166    1003    CLRB	0x3,0
  0167    0DF4    RLCR	0x74
  0168    3EFF    ADDIA	0xFF
  0169    1003    CLRB	0x3,0
  016A    1D03    SNZB	0x3,2
  016B    2967    JP	0x167
  016C    0D74    RLCA	0x74
  016D    3E4B    ADDIA	0x4B
  016E    2185    CALL	0x185
  016F    120A    CLRB	0xA,4
  0170    118A    CLRB	0xA,3
  0171    3A00    XORIA	0x0
  0172    1D03    SNZB	0x3,2
  0173    297B    JP	0x17B
  0174    2983    JP	0x183
22:               		{
23:               			switch (SeletedLine)
24:               			{
25:               			case PortA:
26:               				YKfls_Big = SET;
  0175    1441    SETB	0x41,0
27:               				KeyLines[PortB].flags.is_forbidden = SET;
  0176    144F    SETB	0x4F,0
28:               				return FLUSH_BIG_0;
  0177    3403    RET	0x3
29:               			case PortB:
30:               				YKfls_Sml = SET;
  0178    1541    SETB	0x41,2
31:               				KeyLines[PortA].flags.is_forbidden = SET;
  0179    144B    SETB	0x4B,0
32:               				return FLUSH_SML_0;
  017A    3406    RET	0x6
  017B    0879    LD	A,0x79
  017C    3A00    XORIA	0x0
  017D    1903    SZB	0x3,2
  017E    2975    JP	0x175
  017F    3A01    XORIA	0x1
  0180    1903    SZB	0x3,2
  0181    2978    JP	0x178
  0182    2983    JP	0x183
  0183    0AF9    INCR	0x79
  0184    291C    JP	0x11C
33:               			
34:               			default:
35:               				break;
36:               			}
37:               			
38:               		}
39:               	}
40:               	return FALSE;
41:               	
42:               }
43:               
44:               
45:               uint8_t ScanKey(SignalLines line_num)   /*用于判断按键引脚的状态*/
  0202    00F2    LD	0x72,A
46:               {
47:                   switch (line_num)
  0203    2A0C    JP	0x20C
48:               	{
49:               	case PortA:
50:               		return PIKey1;
  0204    3000    LDIA	0x0
  0205    1B05    SZB	0x5,6
  0206    3001    LDIA	0x1
  0207    0008    RET
51:               	case PortB:
52:               		return PIKey2;
  0208    3000    LDIA	0x0
  0209    1806    SZB	0x6,0
  020A    3001    LDIA	0x1
  020B    0008    RET
  020C    0872    LD	A,0x72
  020D    3A00    XORIA	0x0
  020E    1903    SZB	0x3,2
  020F    2A04    JP	0x204
  0210    3A01    XORIA	0x1
  0211    1903    SZB	0x3,2
  0212    2A08    JP	0x208
  0213    2A14    JP	0x214
  0214    0008    RET
53:               	}
54:               }
55:               
56:               
57:               
58:               uint8_t KeyControl(KEY_PRIVATE* this)/*用于按键的消除抖动处理*/
  0185    00D9    LD	0x59,A
59:               {
60:                   if(!(this->flags.level))  //按键按下有效时间判定
  0186    0084    LD	0x4,A
61:                   {
62:               		if (this->flags.is_pressing)
  0187    0859    LD	A,0x59
  0188    1900    SZB	0x0,2
  0189    29DB    JP	0x1DB
  018A    0084    LD	0x4,A
63:               		{
64:               			this->cnt = CLR;
  018B    0A59    INCA	0x59
  018C    1C80    SNZB	0x0,1
  018D    29C0    JP	0x1C0
  018E    0084    LD	0x4,A
  018F    0180    CLR	0x0
65:               
66:               			if (IncrementJudgeToCLR(this->cnt_timeout,CNTKeyOutTime))
  0190    0859    LD	A,0x59
  0191    3E02    ADDIA	0x2
  0192    0084    LD	0x4,A
  0193    3001    LDIA	0x1
  0194    0780    ADDR	0x0
  0195    0A84    INCR	0x4
  0196    1803    SZB	0x3,0
  0197    0A80    INCR	0x0
  0198    0384    DECR	0x4
  0199    0800    LD	A,0x0
  019A    00F2    LD	0x72,A
  019B    0A84    INCR	0x4
  019C    0800    LD	A,0x0
  019D    00F3    LD	0x73,A
  019E    3002    LDIA	0x2
  019F    0273    SUBA	0x73
  01A0    3059    LDIA	0x59
  01A1    1903    SZB	0x3,2
  01A2    0272    SUBA	0x72
  01A3    1803    SZB	0x3,0
  01A4    29A7    JP	0x1A7
  01A5    01D3    CLR	0x53
  01A6    29B7    JP	0x1B7
  01A7    0859    LD	A,0x59
  01A8    3E02    ADDIA	0x2
  01A9    0084    LD	0x4,A
  01AA    0180    CLR	0x0
  01AB    0A84    INCR	0x4
  01AC    0180    CLR	0x0
  01AD    01F2    CLR	0x72
  01AE    01F3    CLR	0x73
  01AF    0872    LD	A,0x72
  01B0    0473    ORA	0x73
  01B1    1D03    SNZB	0x3,2
  01B2    29B5    JP	0x1B5
  01B3    3001    LDIA	0x1
  01B4    29B6    JP	0x1B6
  01B5    3000    LDIA	0x0
  01B6    00D3    LD	0x53,A
  01B7    01D4    CLR	0x54
  01B8    0853    LD	A,0x53
  01B9    0454    ORA	0x54
  01BA    1903    SZB	0x3,2
  01BB    3400    RET	0x0
67:               			{			
68:               				this->flags.is_forbidden = SET;
  01BC    0859    LD	A,0x59
  01BD    0084    LD	0x4,A
  01BE    1400    SETB	0x0,0
  01BF    3400    RET	0x0
69:               			}
70:               
71:               		}else
72:               		{
73:               			if (IncrementJudgeToCLR(this->cnt,CNTKeyTime))
  01C0    0084    LD	0x4,A
  01C1    300B    LDIA	0xB
  01C2    0A80    INCR	0x0
  01C3    0200    SUBA	0x0
  01C4    1803    SZB	0x3,0
  01C5    29C8    JP	0x1C8
  01C6    01D5    CLR	0x55
  01C7    29D1    JP	0x1D1
  01C8    0A59    INCA	0x59
  01C9    0084    LD	0x4,A
  01CA    0180    CLR	0x0
  01CB    1D03    SNZB	0x3,2
  01CC    29CF    JP	0x1CF
  01CD    3001    LDIA	0x1
  01CE    29D0    JP	0x1D0
  01CF    3000    LDIA	0x0
  01D0    00D5    LD	0x55,A
  01D1    01D6    CLR	0x56
  01D2    0855    LD	A,0x55
  01D3    0456    ORA	0x56
  01D4    1903    SZB	0x3,2
  01D5    3400    RET	0x0
74:               			{
75:               				this->flags.is_pressing = SET;
  01D6    0859    LD	A,0x59
  01D7    0084    LD	0x4,A
  01D8    3001    LDIA	0x1
  01D9    1480    SETB	0x0,1
76:               				return TRUE;
  01DA    0008    RET
77:               			}
78:               		}	
79:               
80:                   }
81:                    else
82:                   {
83:               		if (this->flags.is_pressing)
  01DB    0084    LD	0x4,A
84:               		{
85:               			if (IncrementJudgeToCLR(this->cnt,CNTKeyTime))
  01DC    0A59    INCA	0x59
  01DD    1C80    SNZB	0x0,1
  01DE    29F9    JP	0x1F9
  01DF    0084    LD	0x4,A
  01E0    300B    LDIA	0xB
  01E1    0A80    INCR	0x0
  01E2    0200    SUBA	0x0
  01E3    1803    SZB	0x3,0
  01E4    29E7    JP	0x1E7
  01E5    01D7    CLR	0x57
  01E6    29F0    JP	0x1F0
  01E7    0A59    INCA	0x59
  01E8    0084    LD	0x4,A
  01E9    0180    CLR	0x0
  01EA    1D03    SNZB	0x3,2
  01EB    29EE    JP	0x1EE
  01EC    3001    LDIA	0x1
  01ED    29EF    JP	0x1EF
  01EE    3000    LDIA	0x0
  01EF    00D7    LD	0x57,A
  01F0    01D8    CLR	0x58
  01F1    0857    LD	A,0x57
  01F2    0458    ORA	0x58
  01F3    1903    SZB	0x3,2
  01F4    3400    RET	0x0
86:               			{
87:               				this->flags.is_pressing = CLR;
  01F5    0859    LD	A,0x59
  01F6    0084    LD	0x4,A
  01F7    1080    CLRB	0x0,1
  01F8    3400    RET	0x0
88:               			}
89:               		}else
90:               		{
91:               			this->cnt = CLR;
  01F9    0084    LD	0x4,A
  01FA    0180    CLR	0x0
92:               			this->cnt_timeout = CLR;
  01FB    0859    LD	A,0x59
  01FC    3E02    ADDIA	0x2
  01FD    0084    LD	0x4,A
  01FE    0180    CLR	0x0
  01FF    0A84    INCR	0x4
  0200    0180    CLR	0x0
93:               		}
94:                  
95:                   }
96:               	return FALSE;
  0201    3400    RET	0x0
97:               }
---- D:\mywork.wqs\ARROW\FM03_79F133\ABM007_79F133\source\fct.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE fctBits001;
5:                
6:                // #define FfctTest fctBits001.bits.bit_0
7:                
8:                volatile unsigned char CNTfctStart;
9:                volatile unsigned char CNTfctSensior;
10:               volatile unsigned char CNTfctFlashLed;
11:               volatile unsigned int CNTfct;
12:               
13:               void FCTkey(void);
14:               void FCTjudge(void);
15:               
16:               void FCTloop(void)
17:               {
18:                   FCTkey();
  0463    24B8    CALL	0x4B8
  0464    120A    CLRB	0xA,4
  0465    118A    CLRB	0xA,3
19:                   FCTjudge();
  0466    2C67    JP	0x467
20:               }
21:               
22:               void FCTkey(void)
23:               {
24:                   if(PItest == HIGH)
  04B8    1D06    SNZB	0x6,2
  04B9    2CC3    JP	0x4C3
25:                   {
26:                       if(++CNTfctStart >= 50)
  04BA    3032    LDIA	0x32
  04BB    0ABD    INCR	0x3D
  04BC    023D    SUBA	0x3D
  04BD    1C03    SNZB	0x3,0
  04BE    0008    RET
27:                       {
28:                           CNTfctStart = 50;
  04BF    3032    LDIA	0x32
  04C0    00BD    LD	0x3D,A
29:                           FfctTest = SET;
  04C1    1446    SETB	0x46,0
  04C2    0008    RET
30:                       }
31:                   }
32:                   else
33:                   {
34:                       FfctTest = CLR;
  04C3    1046    CLRB	0x46,0
35:                       CNTfctStart = 0;
  04C4    01BD    CLR	0x3D
  04C5    0008    RET
36:                   }
37:               }
38:               
39:               void FCTjudge(void)
40:               {
41:                   if(FfctTest == SET)
  0467    1C46    SNZB	0x46,0
  0468    2CB4    JP	0x4B4
42:                   {
43:                       if(PIsensor == LOW)
  0469    1886    SZB	0x6,1
  046A    2C88    JP	0x488
44:                       {
45:                           if(++CNTfctSensior >= 50)
  046B    3032    LDIA	0x32
  046C    0ABC    INCR	0x3C
  046D    023C    SUBA	0x3C
  046E    1C03    SNZB	0x3,0
  046F    0008    RET
46:                           {
47:                               CNTfct = 0;
  0470    01A0    CLR	0x20
  0471    01A1    CLR	0x21
48:                               CNTfctSensior = 50;
  0472    3032    LDIA	0x32
  0473    00BC    LD	0x3C,A
49:                               if(++CNTfctFlashLed >= 50)
  0474    0ABB    INCR	0x3B
  0475    023B    SUBA	0x3B
  0476    1C03    SNZB	0x3,0
  0477    2C7A    JP	0x47A
50:                               {
51:                                   CNTfctFlashLed = 0;
  0478    01BB    CLR	0x3B
52:                               }
  0479    0008    RET
53:                               else if(CNTfctFlashLed == 25)
  047A    3019    LDIA	0x19
  047B    063B    XORA	0x3B
  047C    1D03    SNZB	0x3,2
  047D    2C82    JP	0x482
54:                               {
55:                                   POlight = HIGH;
  047E    1685    SETB	0x5,5
56:                                   POairPump = HIGH;
  047F    1505    SETB	0x5,2
57:                                   POmainValue = HIGH;
  0480    1605    SETB	0x5,4
58:                               }
  0481    0008    RET
59:                               else if(CNTfctFlashLed == 1)
  0482    0B3B    SZDECA	0x3B
  0483    0008    RET
60:                               {
61:                                   POlight = LOW;
  0484    1285    CLRB	0x5,5
62:                                   POairPump = LOW;
  0485    1105    CLRB	0x5,2
63:                                   POmainValue = LOW;
  0486    1205    CLRB	0x5,4
64:                               }
65:                           }
66:                       }
  0487    0008    RET
67:                       else
68:                       {
69:                           CNTfctSensior = 0;
  0488    01BC    CLR	0x3C
70:                           if(++CNTfct >= 100)
  0489    0AA0    INCR	0x20
  048A    1903    SZB	0x3,2
  048B    0AA1    INCR	0x21
  048C    3000    LDIA	0x0
  048D    0221    SUBA	0x21
  048E    3064    LDIA	0x64
  048F    1903    SZB	0x3,2
  0490    0220    SUBA	0x20
  0491    1C03    SNZB	0x3,0
  0492    2C99    JP	0x499
71:                           {
72:                               CNTfct = 0;
  0493    01A0    CLR	0x20
  0494    01A1    CLR	0x21
73:                               // FfctTest = CLR;
74:                               POlight = LOW;
  0495    1285    CLRB	0x5,5
75:                               POairPump = LOW;
  0496    1105    CLRB	0x5,2
76:                               POmainValue = LOW;
  0497    1205    CLRB	0x5,4
77:                           }
  0498    0008    RET
78:                           else if(CNTfct == 75)
  0499    304B    LDIA	0x4B
  049A    0620    XORA	0x20
  049B    0421    ORA	0x21
  049C    1D03    SNZB	0x3,2
  049D    2CA2    JP	0x4A2
79:                           {
80:                               POlight = HIGH;
  049E    1685    SETB	0x5,5
81:                               POairPump = LOW;
  049F    1105    CLRB	0x5,2
82:                               POmainValue = LOW;
  04A0    1205    CLRB	0x5,4
83:                           }
  04A1    0008    RET
84:                           else if(CNTfct == 50)
  04A2    3032    LDIA	0x32
  04A3    0620    XORA	0x20
  04A4    0421    ORA	0x21
  04A5    1D03    SNZB	0x3,2
  04A6    2CAB    JP	0x4AB
85:                           {
86:                               POlight = LOW;
  04A7    1285    CLRB	0x5,5
87:                               POairPump = HIGH;
  04A8    1505    SETB	0x5,2
88:                               POmainValue = LOW;
  04A9    1205    CLRB	0x5,4
89:                           }
  04AA    0008    RET
90:                           else if(CNTfct == 25)
  04AB    3019    LDIA	0x19
  04AC    0620    XORA	0x20
  04AD    0421    ORA	0x21
  04AE    1D03    SNZB	0x3,2
  04AF    0008    RET
91:                           {
92:                               POlight = LOW;
  04B0    1285    CLRB	0x5,5
93:                               POairPump = LOW;
  04B1    1105    CLRB	0x5,2
94:                               POmainValue = HIGH;
  04B2    1605    SETB	0x5,4
  04B3    0008    RET
95:                           }
96:                       }
97:                   }
98:                   else
99:                   {
100:                      CNTfctSensior = 0;
  04B4    01BC    CLR	0x3C
101:                      CNTfct = 0;
  04B5    01A0    CLR	0x20
  04B6    01A1    CLR	0x21
  04B7    0008    RET
102:                  }
103:              }
104:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    3020    LDIA	0x20
  0010    01F9    CLR	0x79
  0011    01FA    CLR	0x7A
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3053    LDIA	0x53
  0015    120A    CLRB	0xA,4
  0016    118A    CLRB	0xA,3
  0017    256C    CALL	0x56C
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    2CC6    JP	0x4C6
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    120A    CLRB	0xA,4
  001A    118A    CLRB	0xA,3
  001B    2BF4    JP	0x3F4
  0215    1741    SETB	0x41,6
  0216    1105    CLRB	0x5,2
  0217    1605    SETB	0x5,4
  0218    1085    CLRB	0x5,1
  0219    0AAC    INCR	0x2C
  021A    1903    SZB	0x3,2
  021B    0AAD    INCR	0x2D
  021C    3000    LDIA	0x0
  021D    022D    SUBA	0x2D
  021E    3405    RET	0x5
  021F    1741    SETB	0x41,6
  0220    1105    CLRB	0x5,2
  0221    1605    SETB	0x5,4
  0222    1485    SETB	0x5,1
  0223    0AAC    INCR	0x2C
  0224    1903    SZB	0x3,2
  0225    0AAD    INCR	0x2D
  0226    3000    LDIA	0x0
  0227    022D    SUBA	0x2D
  0228    340A    RET	0xA
  0229    1085    CLRB	0x5,1
  022A    0AAC    INCR	0x2C
  022B    1903    SZB	0x3,2
  022C    0AAD    INCR	0x2D
  022D    3000    LDIA	0x0
  022E    022D    SUBA	0x2D
  022F    0008    RET
  031D    0828    LD	A,0x28
  031E    072A    ADDA	0x2A
  031F    00A6    LD	0x26,A
  0320    0829    LD	A,0x29
  0321    1803    SZB	0x3,0
  0322    0A29    INCA	0x29
  0323    072B    ADDA	0x2B
  0324    00A7    LD	0x27,A
  0325    0008    RET
  03E8    0AB6    INCR	0x36
  03E9    1903    SZB	0x3,2
  03EA    0AB7    INCR	0x37
  03EB    3000    LDIA	0x0
  03EC    0237    SUBA	0x37
  03ED    3403    RET	0x3
  03EE    0AB6    INCR	0x36
  03EF    1903    SZB	0x3,2
  03F0    0AB7    INCR	0x37
  03F1    3000    LDIA	0x0
  03F2    0237    SUBA	0x37
  03F3    3408    RET	0x8
  056C    0064    CLRWDT
  056D    0180    CLR	0x0
  056E    0A84    INCR	0x4
  056F    0604    XORA	0x4
  0570    1903    SZB	0x3,2
  0571    3400    RET	0x0
  0572    0604    XORA	0x4
  0573    2D6D    JP	0x56D
