---- D:\mywork.wqs\ARROW\ABM007_79F133\ABM007_79F133\source\main.c ----------------------------------------------------------------------
1:                // #include <cms.h>	//芯片头文件，会根据工程选项自动寻找对应型号头文件
2:                #include "cfg_user.h"
3:                #include "cfg_case.h"
4:                #include "math.h"
5:                #include "string.h"
6:                
7:                volatile unsigned int TMR1 @0x000E;
8:                #define TIMER1_TIME 0xE0C0
9:                
10:               /**********************************************************************/
11:               /*全局变量声明*/
12:               /**********************************************************************/
13:               
14:               /*变量*/
15:               v_uint8 RX_Buf;
16:               v_uint8 templ = 0;
17:               v_uint8 SEQmain = 0;
18:               v_uint8 MainTime_1min = 0;	/* 定时1min计数 */
19:               v_uint16 MainTime_1s = 0;	/* 定时1s计数 */
20:               v_uint16 AD_Result = 0;
21:               
22:               extern  void INT_LED_SHOW(void);
23:               
24:               /***********************************************************************
25:               函数功能：延时子函数，13个指令周期1循环
26:               ***********************************************************************/
27:               void Delay(unsigned int dtemp)
28:               {
29:               	while (dtemp--)
  02FE    3001    LDIA	0x1
  02FF    02F2    SUBR	0x72
  0300    3000    LDIA	0x0
  0301    1C03    SNZB	0x3,0
  0302    03F3    DECR	0x73
  0303    02F3    SUBR	0x73
  0304    0F72    SZINCA	0x72
  0305    2AFE    JP	0x2FE
  0306    0A73    INCA	0x73
  0307    1903    SZB	0x3,2
  0308    0008    RET
  0309    2AFE    JP	0x2FE
30:               		;
31:               }
32:               /***********************************************************************
33:               子函数功能：延时templ  ms，有中断则不准
34:               ***********************************************************************/
35:               void Delay_nms(unsigned int inittempl)
36:               {
37:               	unsigned int i;
38:               	unsigned char gtemp;
39:               	/******************************************************************/
40:               	gtemp = 0;
  02DC    1283    CLRB	0x3,5
  02DD    01C8    CLR	0x48
41:               	if (GIE == 1)
  02DE    1F8B    SNZB	0xB,7
  02DF    2AE3    JP	0x2E3
42:               	{
43:               		gtemp = 1;
  02E0    01C8    CLR	0x48
  02E1    0AC8    INCR	0x48
44:               		GIE = 0;
  02E2    138B    CLRB	0xB,7
45:               	}
46:               	for (i = 0; i < inittempl; i++)
  02E3    01C6    CLR	0x46
  02E4    01C7    CLR	0x47
  02E5    0875    LD	A,0x75
  02E6    0247    SUBA	0x47
  02E7    1D03    SNZB	0x3,2
  02E8    2AEB    JP	0x2EB
  02E9    0874    LD	A,0x74
  02EA    0246    SUBA	0x46
  02EB    1803    SZB	0x3,0
  02EC    2AFA    JP	0x2FA
47:               	{
48:               		Delay(154);
  02ED    309A    LDIA	0x9A
  02EE    00F2    LD	0x72,A
  02EF    01F3    CLR	0x73
  02F0    22FE    CALL	0x2FE
  02F1    120A    CLRB	0xA,4
  02F2    118A    CLRB	0xA,3
  02F3    0064    CLRWDT
  02F4    1283    CLRB	0x3,5
  02F5    1303    CLRB	0x3,6
  02F6    0AC6    INCR	0x46
  02F7    1903    SZB	0x3,2
  02F8    0AC7    INCR	0x47
  02F9    2AE5    JP	0x2E5
49:               		asm("clrwdt");
50:               	}
51:               	if (gtemp == 1)
  02FA    0B48    SZDECA	0x48
  02FB    0008    RET
52:               		GIE = 1;
  02FC    178B    SETB	0xB,7
  02FD    0008    RET
53:               }
54:               
55:               /************************************************************
56:               函数名称：Init_GPIO()
57:               函数功能：初始化IO端口
58:               入口参数：
59:               出口参数：
60:               备注：
61:               ************************************************************/
62:               void Init_GPIO(void)
63:               {
64:               
65:               	/*引脚数据*/
66:               	PORTA = 0B00000000;
  0360    1283    CLRB	0x3,5
  0361    1303    CLRB	0x3,6
  0362    0185    CLR	0x5
67:               	PORTB = 0B00000000;
  0363    0186    CLR	0x6
68:               	PORTC = 0B00000000;
  0364    0187    CLR	0x7
69:               
70:               	/* 全部配置成输入状态，1: 输入，0: 输出 */
71:               	TRISA = 0B00000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  0365    1683    SETB	0x3,5
  0366    0185    CLR	0x5
72:               	TRISB = 0B00000011; /* RB1-龙头感应，RB0测试点 */
  0367    3003    LDIA	0x3
  0368    0086    LD	0x6,A
73:               	TRISC = 0B00000000;
  0369    0187    CLR	0x7
74:               
75:               	/*内部上拉关闭, 1: 开启, 0: 关闭 */
76:               	WPUA = 0B00000000; /* RA2-气泵	RA4-主阀 RA5-氛围灯 */
  036A    1703    SETB	0x3,6
  036B    018E    CLR	0xE
77:               	WPUB = 0B00000010; /* RB1-龙头感应<置1则不插为有人状态，RB1低有效>，RB0-测试点，硬件下拉 */
  036C    3002    LDIA	0x2
  036D    1303    CLRB	0x3,6
  036E    0095    LD	0x15,A
78:               	WPUC = 0B00000000;
  036F    1703    SETB	0x3,6
  0370    018F    CLR	0xF
  0371    0008    RET
79:               
80:               	/* 内部下拉 */
81:               	// WPDB =  0B00000000; /* RB1-龙头感应<1不插为无人状态，RB1高有效> */
82:               
83:               	/*模拟通道选择*/
84:               //	ANSEL0 = 0B00000000; // AN7 - AN0
85:               //	ANSEL1 = 0B00000000; // AN15 - AN8
86:               //	ANSEL2 = 0B00000000; //------AN17 AN16
87:               }
88:               
89:               /************************************************************
90:               函数名称：Init_IC()
91:               函数功能：上电初始化系统寄存器
92:               入口参数：
93:               出口参数：
94:               备注：
95:               ************************************************************/
96:               void Init_IC(void)
  034E    0064    CLRWDT
97:               {
98:               	asm("clrwdt");
99:               
100:              	// 7			6			5			4			3			2			1			0
101:              	// GIE		PEIE		TOIE		INTE		RBIE		TOIF		INTF		RBIF
102:              	// 全局允许	外设允许	T0允许		INT允许		PB允许		T0标志		INT标志		PB标志
103:              	INTCON = 0x00; // 中断控制寄存器
  034F    018B    CLR	0xB
104:              
105:              	// 7			6			5			4			3			2			1			0
106:              	//--		ADIF		RCIF		TXIF		--			CCP1IF		TMR2IF		TMR1IF
107:              	// NC		AD转换完成	UART接收满	UART发送满		NC		CCP1中断	T2与PR2匹配		T1
108:              	PIR1 = 0; // 外设中断请求寄存器
  0350    1283    CLRB	0x3,5
  0351    1303    CLRB	0x3,6
  0352    018C    CLR	0xC
109:              
110:              	// 7			6			5			4			3			2			1			0
111:              	//--		TKIF		RACIF		EEIF		--			--			--			CCP2IF
112:              	// NC		触摸检测结束 PA变化		 EEP写完成	  NC		  NC		  NC		  CCP2中断
113:              	PIR2 = 0; // 外设中断请求寄存器
  0353    018D    CLR	0xD
114:              
115:              	// 7			6			5			4			3			2			1			0
116:              	//--		--			--			--			--			--			--			SWDTEN
117:              	// NC		NC			NC			NC			NC			NC			NC			使能
118:              	WDTCON = 0x01; // 看门狗
  0354    3001    LDIA	0x1
  0355    1703    SETB	0x3,6
  0356    0085    LD	0x5,A
119:              
120:              	// 7				6			5			4			3			2			1		0
121:              	// RBPU			INTEDG			T0CS		T0SE		PSA			PS2			PS1		PS0
122:              	// PB上拉使能	中断边沿选择  	T0时钟源	  T0边沿选择	预分配		预分配参数
123:              	OPTION_REG = 0b00001110; // 开启PORTB上来使能，看门狗复位时间=18*分频系数 (规格书 2.6/2.8.1)
  0357    300E    LDIA	0xE
  0358    1683    SETB	0x3,5
  0359    1303    CLRB	0x3,6
  035A    0081    LD	0x1,A
124:              
125:              	// 7			6			5			4			3			2			1			0
126:              	//--		IRCF2		IRCF1		IRCF0		--			--			--			--
127:              	// NC		内振分频							NC			NC			NC			NC
128:              	OSCCON = 0x71; // 振荡器控制
  035B    3071    LDIA	0x71
  035C    008F    LD	0xF,A
129:              
130:              	// 7			6			5			4			3			2			1				0
131:              	//--		ADIE		RCIE		TXIE		--			CCP1IE		TMR2IE			TMR1IE
132:              	// NC		AD转换允许	UART接收允许 UART发送允许 NC		  CCP1允许	  T2与PR2匹配允许	T1溢出允许
133:              	PIE1 = 0; // 外设中断允许
  035D    018C    CLR	0xC
134:              
135:              	//
136:              	//--	TKIE				RACIE			EEIE			--		--		--		CCP2IE
137:              	// NC	触摸检测结束允许	PA变化允许			EEP写允许		NC		NC		NC		CCP2中断允许
138:              	PIE2 = 0; // 外设中断允许
  035E    018D    CLR	0xD
  035F    0008    RET
139:              }
140:              
141:              /************************************************************
142:              函数名称：Init_TIMER1()
143:              函数功能：定时器1初始化函数
144:              入口参数：
145:              出口参数：
146:              备注：	  定时时间计算方法
147:              		  定时时间T = {1/[(Fosc)*预分频比)]}*(65535-[TMR1H:TMR1L])
148:              		  本程序计算示例：
149:              		  T = {1/[(8)*(1/1)]}*(65536 - 63936)
150:              			= 125 us
151:              ************************************************************/
152:              void Init_TIMER1(void)
153:              {
154:              	// TMR1L = 0xC0; //赋初值
155:              	// TMR1H = 0xF9;
156:              	TMR1 = TIMER1_TIME;
  037D    30E0    LDIA	0xE0
  037E    008F    LD	0xF,A
  037F    30C0    LDIA	0xC0
  0380    008E    LD	0xE,A
157:              	TMR1IF = 0;	  // 清中断标志位
  0381    100C    CLRB	0xC,0
158:              	TMR1IE = 1;	  // 允许Timer1中断
  0382    1683    SETB	0x3,5
  0383    140C    SETB	0xC,0
159:              	T1CON = 0x01; // 开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  0384    3001    LDIA	0x1
  0385    1283    CLRB	0x3,5
  0386    0090    LD	0x10,A
  0387    0008    RET
160:              }
161:              
162:              /************************************************************
163:              函数名称：Init_TIMER2()
164:              函数功能：定时器2初始化函数
165:              入口参数：
166:              出口参数：
167:              备注：	  定时时间计算方法
168:              		  时钟输入为系统指令时钟（即为Fosc/4）
169:              		  定时时间T = {1/[(Fosc/4)*预分频比*后分频比]}*(PR2+1)
170:              		  本程序计算示例：
171:              		  T = {1/[(8/4)*(1/4)*1]}*50 = 100 us
172:              
173:              ************************************************************/
174:              void Init_TIMER2(void)
175:              {
176:              	PR2 = 24;	// 8M下将TMR2设置为50us中断?
  0372    3018    LDIA	0x18
  0373    1683    SETB	0x3,5
  0374    0092    LD	0x12,A
177:              	TMR2IF = 0; // 清中断标志位
  0375    1283    CLRB	0x3,5
  0376    108C    CLRB	0xC,1
178:              	TMR2IE = 1; // 允许Timer2中断
  0377    1683    SETB	0x3,5
  0378    148C    SETB	0xC,1
179:              	T2CON = 5;	// 开启Timer2，预分频值为4，后分频比为1:1
  0379    3005    LDIA	0x5
  037A    1283    CLRB	0x3,5
  037B    0092    LD	0x12,A
  037C    0008    RET
180:              }
181:              
182:              /* 遥控器接收数据时钟，50μs */
183:              // void Init_TIMER2_Remo(void)
184:              //{
185:              //	PR2 = 24;		//16M下将TMR2设置为50μs中断
186:              //	TMR2IF = 0; 	//清中断标志位
187:              //	TMR2IE = 1; 	//允许Timer2中断
188:              //	T2CON = 5;		//开启Timer2，预分频值为4，后分频比为1:1
189:              // }
190:              
191:              /***********************************************
192:              函数名称：Set_CCP_PWM
193:              函数功能：CCP PWM模式初始化
194:              入口参数：无
195:              出口参数：无
196:              备注：
197:              	   周期 = (PWMxCYC+1)*4/Fosc*PWMxCNT预分频值
198:              	  占空比 = (CCPRxL:CCPCON<5:4>)/(4*(PWMxCYC + 1))
199:              	  由于CCPx 引脚与端口数据锁存器复用，必须清零相应的TRIS 位才能使能CCPx 引脚的输出驱动器。
200:              ************************************************/
201:              void Set_CCP_PWM()
202:              {
203:              //	PWMCON = 0B00000001; // PWM1设置为16分频，使能PWM1
204:              
205:              	// // PWM1 周期设置为500us，占空比50%
206:              	// CCP1CON = 0B00001100; // PWM模式,10位占空比数据低2位为0；
207:              	// PWM1CYC = 124;		  // PWM1周期为：(249+1)* （4/8） * 4 =500uS
208:              	// CCPR1L = 62;		  // 低2位为0,(CCPRxL:CCPCON<5:4>)=CCPR1L*4
209:              	// CYC1EN = 1;			  /* PWM1的周期计数器使能位,1使能，0禁止 */
210:              	// PWMTL = 0x8f;					//PWM0~3共周期，周期低位
211:              	PWMT4L = 0x7C;					//PWM4独立周期，周期低位,0x7C,(124+1)* （4/8） * 4 =250μs
212:              	PWMTH = 0B00011101;				//周期高两位及PWM4占空比高两位	
213:              	/* PWMTH: bit5~bit4- PWM4占空比高2位，bit3~bit2-PWM周期高2位，bit1~bit0-PWM0~PWM3周期高2位 */
214:              	
215:              	//PWM0~3周期为：(0B110001111+1)*(1/16)*2 =50uS
216:              	//PWM4周期为：(0B1110001111+1)*(1/16)*2 =114uS
217:              	/* PWM4 0B00001100 */
218:              	
219:              	// PWMD01H = 0x00;					//高位改变后不能立即生效，需要给占空比的低位寄存器后才能加载
220:              	// //PWM0 占空比设置为20%
221:              	// PWMD0L = 0x4f;					//(79+1)/(399+1) = 20%
222:              	// //PWM1 占空比设置为40%
223:              	// PWMD1L = 0x9f;					//(159+1)/(399+1) = 40%
224:              
225:              	// PWMD23H = 0x10;
226:              	// //PWM2 占空比设置为60%
227:              	// PWMD2L = 0xef;					//(239+1)/(399+1) = 60%
228:              	// //PWM3 占空比设置为80%
229:              	// PWMD3L = 0x3f;					//(319+1)/(399+1) = 80%
230:              
231:              	//PWM4 占空比设置为25%
232:              	PWMD4L = 0xC7;					//(227+1)/(911+1) = 25% ()
233:              	/* 50% 0x01C7, (455+1)/(911+1) */
234:              	
235:              	// PWM01DT = 0x3F;					//死区时间，低6位有效位=(0B00111111+1)*(1/16)*1 =4uS
236:              	// PWM23DT = 0;
237:              	
238:              	PWMCON2 = 0B00000000;			//正常输出
239:              	PWMCON1 = 0B00000000;			//PWM01位置选择为RB5/RB4;禁止死区；可使能PWM0/1互补，PWM2/3互补
240:              	PWMCON0 = 0B00110000;			//PWM分频Fosc/2，使能PWM4
241:              }
242:              
243:              /***********************************************
244:              函数名称：Memory_Write
245:              函数功能：写数据
246:              入口参数：Addr - 写入地址
247:              		  Value - 写入数值
248:              出口参数：返回值 0 - 写操作错误 1 - 写完毕
249:              备注：
250:              写程序EE过程中需要暂时关闭中断，以保证写EE时序中的写55H和写AAH能够连续进行，否则将有可能写错，并且写EE的可靠工作电压范围为3V以上。
251:              ************************************************/
252:              unsigned char Memory_Write(unsigned char Addr, unsigned char Value)
253:              {
254:              
255:              	volatile unsigned char i = 0;
256:              	// 将要写入的地址放入EEADDR寄存器
257:              	EEADR = Addr;
258:              	EEDAT = Value; // 将要写入的数据给EEPROM的数据寄存器
259:              	EECON1 = 0;
260:              	EEPGD = 0;		 // 访问数据存储器
261:              	EECON1 | = 0x10; // 烧写时间10ms（0x30）,时间非固定精准,用户可自定义(最长烧写等待时间2.5ms, 0x10)
262:              	asm("clrwdt");
263:              
264:              	WREN = 1; // 允许写周期
265:              	GIE = 0;  // 关闭中断
266:              	GIE = 0;
267:              	GIE = 0;
268:              	while (GIE)
269:              	{
270:              		GIE = 0; // 确保中断已关闭
271:              		if (0 == --i)
272:              		{
273:              			// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
274:              			GIE = 1; // 总中断GIE置1
275:              			return 0;
276:              		}
277:              	}
278:              	asm("clrwdt");
279:              
280:              	EECON2 = 0x55; // 给EECON2写入0x55
281:              	EECON2 = 0xaa; // 给EECON2写入0xaa
282:              	WR = 1;		   // 启动写周期
283:              	asm("nop");
284:              	asm("nop");
285:              	asm("clrwdt");
286:              	WREN = 0; // 禁止写入
287:              	// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
288:              	GIE = 1; // 总中断GIE置1
289:              
290:              	if (WRERR)
291:              		return 0; // 写操作错误
292:              	else
293:              		return 1; // 写完毕
294:              }
295:              
296:              void Flash_Write(unsigned char Addr, unsigned char Value)
297:              {
298:              	uint8_t bufAddress;
299:              	uint8_t bufValue;
300:              	bufAddress = Addr;
301:              	bufValue = Value;
302:              	templ = 10; //错误计数，用户可自定义
303:              	do
304:              	{
305:              		asm("clrwdt");
306:              		asm("clrwdt");
307:              	} while ((0 == Memory_Write(bufAddress, bufValue)) && (templ--)); //调用写函数：地址0x00处写入数据0x5a
308:              }
309:              
310:              /***********************************************
311:              函数名称：Memory_Read
312:              函数功能：读数据
313:              入口参数：Addr - 读取地址
314:              出口参数：返回读取地址相应数值
315:              备注：
316:              ************************************************/
317:              unsigned char Memory_Read(unsigned char Addr)
318:              {
319:              
320:              	EEADR = Addr;
321:              	EEPGD = 0; // 访问数据存储器
322:              
323:              	RD = 1; // 允许读操作
324:              	asm("nop");
325:              	asm("nop");
326:              
327:              	return (EEDAT);
328:              }
329:              
330:              /************************************************************
331:              函数名称：AD_Testing()
332:              函数功能：AD采样函数
333:              入口参数：ad_fd - 分频 00Fosc/8; 01Fosc/16; 10Fosc/32; 11Frc;
334:              		  ad_ch - AD通道选择1~15，15通道为内部基准1.2V固定输入值
335:              		  ad_lr - 左/右对齐，输入0或1，0为左对齐，1为右对齐
336:              
337:              出口参数：AdResult - AD结果
338:              备    注：BUFmotor_ad = AD_Testing(0, 10, 0); //8分频，AN10通道，右对齐	规格书11.2.4，8M主频最快8分频
339:              ************************************************************/
340:              unsigned int AD_Testing(unsigned char ad_fd, unsigned char ad_ch, unsigned char ad_lr)
341:              {
342:              	// static volatile unsigned char adtimes;
343:              	// static volatile unsigned int admin, admax, adsum;
344:              	volatile unsigned int data;
345:              	volatile unsigned char i = 0;
346:              
347:              	if (!ad_lr)
348:              		ADCON1 = 0; // 左对齐,出12位
349:              	else
350:              		ADCON1 = 0x80; // 右对齐,出10位
351:              
352:              	if (ad_ch & 0x10) // 设置CHS4，此位在ADCON1寄存器中
353:              		ADCON1 |= 0x40;
354:              
355:              	ADCON0 = 0;
356:              	ad_ch &= 0x0f;
357:              	ADCON0 |= (unsigned char)(ad_fd << 6); // 不同的VDD或参考电压需要配置合理的分频
358:              	ADCON0 |= (unsigned char)(ad_ch << 2); // 设置通道
359:              	ADCON0 |= 0x01;						   // 使能ADC
360:              
361:              	asm("nop");
362:              	asm("nop");
363:              	GODONE = 1; // 开始转换
364:              
365:              	while (GODONE)
366:              	{
367:              		asm("nop");
368:              		asm("nop");
369:              		if ((--i) == 0) // ad等待限时，防止出现死循环，但要考虑转换时间不能长于此时间
370:              			return 0;
371:              	}
372:              
373:              	if (!ad_lr) // 左对齐
374:              	{
375:              		data = (unsigned int)(ADRESH << 4);
376:              		data |= (unsigned int)(ADRESL >> 4);
377:              	}
378:              	else // 右对齐
379:              	{
380:              		data = (unsigned int)(ADRESH << 8);
381:              		data |= (unsigned int)ADRESL;
382:              	}
383:              
384:              	return data;
385:              }
386:              
387:              /***********************************************
388:              函数名称：Set_Usart_Async
389:              函数功能：Usart状态设置（异步）
390:              入口参数：无
391:              出口参数：无
392:              备注：
393:              1、串口通讯，设置波特率寄存器时，应控制在19200及以下，实际应用时应考虑到芯片内振的电压及温度特性。
394:              2、SYNC = 0;目标波特率 = Fosc/(16*(SPBRG+1))
395:              ************************************************/
396:              void Set_Usart_Async()
397:              {
398:              	BRGHEN1 = 1;
399:              	BRG16EN1 = 0; //设置BRG是一个8位定时器
400:              
401:              	SPBRGH1 = 0;
402:              	SPBRG1 = 51; //设置波特率为9600 bps (8M/(16*52))
403:              
404:              //	SPBRG = 25; /* 19200bps, 8M/(16*26) */
405:              
406:              	SYNC1 = 0; // 0为异步模式，1为同步模式
407:              	SCKP1 = 0; // 直接将数据字符发送到TX/CK引脚
408:              
409:              	SPEN1 = 1;  // 允许串口操作
410:              	RC1IE = 1;  // 接收中断  //暂时关闭
411:              	TX1IE = 0;  // 发送中断
412:              	RX9EN1 = 0; // 0为8位接收，1为9位接收
413:              	TX9EN1 = 0; // 0为8位发送，1为9位发送
414:              	CREN1 = 1;  // 0为禁止接收，1为使能接收 //暂时关闭
415:              	TXEN1 = 1;  // 0为禁止发送，1为使能发送
416:              }
417:              
418:              /************************************************************
419:              函数名称：Uart_Send_NByte()
420:              函数功能：串口多字节发送函数
421:              入口参数：n 待发送字节数量
422:              		  nSendByte 待发送数组
423:              出口参数：
424:              备    注：
425:              ************************************************************/
426:              // void Uart_Send_NByte(uint8_t n, uint8_t *nSendByte)
427:              // {
428:              // 	uint8_t i;
429:              // 	for(i = 0; i < n; i++)
430:              // 	{
431:              // 		TX_Buf[i] = nSendByte[i];
432:              // 	}
433:              // 	tx_index = n;
434:              // 	TXIE = 1;
435:              // }
436:              
437:              /************************************************************
438:              函数名称：Init_PA_Isr()
439:              函数功能：PA中断初始化函数
440:              入口参数：
441:              出口参数：
442:              备    注：
443:              ************************************************************/
444:              // void Init_PA_Isr()
445:              // {
446:              // 	IOCA = 0B01100110; // 允许RA1的IO口电平变化中断
447:              // 	RACIE = 1;		   // 使能PORTA电平变化中断
448:              // 	PORTA;			   // 读取PORTA并锁存
449:              // }
450:              
451:              /************************************************************
452:              函数名称：Init_PB_Isr()
453:              函数功能：PB中断初始化函数
454:              入口参数：
455:              出口参数：
456:              备    注：
457:              ************************************************************/
458:              // void Init_PB_Isr()
459:              // {
460:              // 	IOCB = 0B00000001; // 允许RB0的IO口电平变化中断
461:              // 	RBIE = 1;		   // 使能PORTB电平变化中断
462:              // 	// INTCON = 0x88;			//允许所有未被屏蔽的中断、禁止外设中断，使能PORTB电平变化中断
463:              // 	PORTB;			   // 读取PORTB并锁存
464:              // }
465:              
466:              /************************************************************
467:              函数名称：mainr()
468:              函数功能：主循环
469:              入口参数：
470:              出口参数：
471:              备    注：
472:              ************************************************************/
473:              void main(void)
  020A    0000    NOP
  020B    0064    CLRWDT
474:              {
475:              	/******************************************************************/
476:              	asm("nop");
477:              	asm("clrwdt");
478:              	INTCON = 0;		 //禁止中断
  020C    018B    CLR	0xB
479:              
480:              	Init_GPIO();	// 初始化GPIO
  020D    120A    CLRB	0xA,4
  020E    118A    CLRB	0xA,3
  020F    2360    CALL	0x360
481:              	Init_IC();		// 相关寄存器初始化
  0212    120A    CLRB	0xA,4
  0213    118A    CLRB	0xA,3
  0214    234E    CALL	0x34E
482:              	Delay_nms(200); // 上电延时200ms 非精准延时
  0217    30C8    LDIA	0xC8
  0218    00F4    LD	0x74,A
  0219    01F5    CLR	0x75
  021A    120A    CLRB	0xA,4
  021B    118A    CLRB	0xA,3
  021C    22DC    CALL	0x2DC
483:              	Init_TIMER1();	// 定时器1初始化
  021F    120A    CLRB	0xA,4
  0220    118A    CLRB	0xA,3
  0221    237D    CALL	0x37D
484:              	Init_TIMER2();	// 定时器2初始化
  0224    120A    CLRB	0xA,4
  0225    118A    CLRB	0xA,3
  0226    2372    CALL	0x372
485:              //	Init_PA_Isr();		 //PA中断初始化函数
486:              //	Init_PB_Isr();		 //PB中断初始化函数
487:              // #if FCT
488:              // 	/* FCT串口不初始化，TX、RX作为普通端口使用 */
489:              // #else
490:              // 	Set_Usart_Async(); // 串口初始化
491:              // #endif
492:              
493:              	//	Set_CCP_PWM();		 //PWM初始化
494:              
495:              	INTCON = 0XC0;	   // 允许所有未被屏蔽的中断、外设中断
  0229    30C0    LDIA	0xC0
  022A    008B    LD	0xB,A
496:              
497:              	// RemoFlash_Read();  /* 读取存储的数值 */
498:              	while (1)
499:              	{
500:              		/*主循环10ms*/
501:              		if (F1ms == SET)
  022B    1CC5    SNZB	0x45,1
  022C    2A2B    JP	0x22B
  022D    0064    CLRWDT
502:              		{
503:              			CLRWDT(); /*清看门狗*/
504:              			F1ms = CLR;
  022E    1283    CLRB	0x3,5
  022F    1303    CLRB	0x3,6
  0230    10C5    CLRB	0x45,1
505:              			switch (SEQmain)
  0231    2A50    JP	0x250
506:              			{
507:              				case 0:
508:              					FCTloop();
  0232    120A    CLRB	0xA,4
  0233    118A    CLRB	0xA,3
  0234    2279    CALL	0x279
509:              					break;
  0237    2A70    JP	0x270
510:              				case 1:
511:              					if(FfctTest == CLR)
  0238    1879    SZB	0x79,0
  0239    2A70    JP	0x270
512:              					{
513:              						GsensorLoop();
  023A    120A    CLRB	0xA,4
  023B    118A    CLRB	0xA,3
  023C    201F    CALL	0x1F
  023F    2A70    JP	0x270
514:              					}
515:              					break;
516:              				case 2:
517:              
518:              					break;
519:              				case 3:
520:              
521:              					break;
522:              				case 4:
523:              					if(FfctTest == CLR)
  0240    1879    SZB	0x79,0
  0241    2A70    JP	0x270
524:              					{
525:              						GflushLoop();
  0242    120A    CLRB	0xA,4
  0243    118A    CLRB	0xA,3
  0244    2115    CALL	0x115
  0247    2A70    JP	0x270
526:              					}
527:              					break;
528:              				case 5:
529:              
530:              					break;
531:              				case 6:
532:              
533:              					break;
534:              				case 7:
535:              
536:              					break;
537:              				case 8:
538:              					if(FfctTest == CLR)
  0248    1879    SZB	0x79,0
  0249    2A70    JP	0x270
539:              					{
540:              						GledLoop();
  024A    120A    CLRB	0xA,4
  024B    118A    CLRB	0xA,3
  024C    232E    CALL	0x32E
  024F    2A70    JP	0x270
  0250    083F    LD	A,0x3F
  0251    3A00    XORIA	0x0
  0252    1903    SZB	0x3,2
  0253    2A32    JP	0x232
  0254    3A01    XORIA	0x1
  0255    1903    SZB	0x3,2
  0256    2A38    JP	0x238
  0257    3A03    XORIA	0x3
  0258    1903    SZB	0x3,2
  0259    2A70    JP	0x270
  025A    3A01    XORIA	0x1
  025B    1903    SZB	0x3,2
  025C    2A70    JP	0x270
  025D    3A07    XORIA	0x7
  025E    1903    SZB	0x3,2
  025F    2A40    JP	0x240
  0260    3A01    XORIA	0x1
  0261    1903    SZB	0x3,2
  0262    2A70    JP	0x270
  0263    3A03    XORIA	0x3
  0264    1903    SZB	0x3,2
  0265    2A70    JP	0x270
  0266    3A01    XORIA	0x1
  0267    1903    SZB	0x3,2
  0268    2A70    JP	0x270
  0269    3A0F    XORIA	0xF
  026A    1903    SZB	0x3,2
  026B    2A48    JP	0x248
  026C    3A01    XORIA	0x1
  026D    1903    SZB	0x3,2
  026E    2A70    JP	0x270
  026F    2A70    JP	0x270
541:              					}
542:              				break;
543:              				case 9:
544:              
545:              					break;
546:              				default:
547:              					// SEQmain = 0;
548:              					break;
549:              			}
550:              			if (++SEQmain >= 10)
  0270    300A    LDIA	0xA
  0271    1283    CLRB	0x3,5
  0272    1303    CLRB	0x3,6
  0273    0ABF    INCR	0x3F
  0274    023F    SUBA	0x3F
  0275    1C03    SNZB	0x3,0
  0276    2A2B    JP	0x22B
551:              			{
552:              				SEQmain = 0;
  0277    01BF    CLR	0x3F
  0278    2A2B    JP	0x22B
553:              			}
554:              		}
555:              	}
556:              }
557:              
558:              // /***********************************************************************
559:              // 函数功能：中断入口函数
560:              // RISC内核无中断优先级，不可嵌套
561:              // ***********************************************************************/
562:              void interrupt Int_ALL(void)
563:              {
564:              	// 1ms定时器中断服务函数
565:              	if (TMR1IF)
  030A    1283    CLRB	0x3,5
  030B    1303    CLRB	0x3,6
  030C    1C0C    SNZB	0xC,0
  030D    2B22    JP	0x322
566:              	{
567:              		// ---------------------------------------
568:              		// TMR1L += 0xC0;
569:              		// TMR1H += 0xF9; //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
570:              		// 在进入中断等过程中其实Time是一直在计数的
571:              		// ---------------------------------------
572:              		TMR1 = TIMER1_TIME;
  030E    30E0    LDIA	0xE0
  030F    008F    LD	0xF,A
  0310    30C0    LDIA	0xC0
  0311    008E    LD	0xE,A
573:              		TMR1IF = 0; // 清中断标志位
  0312    100C    CLRB	0xC,0
574:              
575:              		/* 主循环1ms标志位 */
576:              		F1ms = 1;
  0313    14C5    SETB	0x45,1
577:              
578:              		/* 1s标志位 */
579:              		if (++MainTime_1s >= 1000)
  0314    0AAE    INCR	0x2E
  0315    1903    SZB	0x3,2
  0316    0AAF    INCR	0x2F
  0317    3003    LDIA	0x3
  0318    022F    SUBA	0x2F
  0319    30E8    LDIA	0xE8
  031A    1903    SZB	0x3,2
  031B    022E    SUBA	0x2E
  031C    1C03    SNZB	0x3,0
  031D    2B22    JP	0x322
580:              		{
581:              			MainTime_1s = 0;
  031E    01AE    CLR	0x2E
  031F    01AF    CLR	0x2F
582:              			Fsys1s.byte = 0xFF; /* 1s' flag */
  0320    30FF    LDIA	0xFF
  0321    00C4    LD	0x44,A
583:              // #if (VER_2510M || VER_2510U)
584:              // 			if (++MainTime_1min >= 60) /* 1min标识位 */
585:              // 			{
586:              // 				MainTime_1min = 0;
587:              // 				Fsys1m.byte = 0xFF; /* 1min' flag */
588:              // 			}
589:              // #endif
590:              		}
591:              	}
592:              
593:              	// 50us定时器中断服务函数
594:              	if (TMR2IF)
  0322    1C8C    SNZB	0xC,1
  0323    2B26    JP	0x326
595:              	{
596:              		TMR2IF = 0; /*	8位，自重载，无需二次配置	*/
  0324    108C    CLRB	0xC,1
597:              		INT_LED_SHOW(); /* 氛围灯中断函数 */
  0325    232D    CALL	0x32D
  0326    0871    LD	A,0x71
  0327    008A    LD	0xA,A
  0328    0E70    SWAPA	0x70
  0329    0083    LD	0x3,A
  032A    0EFE    SWAPR	0x7E
  032B    0E7E    SWAPA	0x7E
  032C    0009    RETI
598:              	}
599:              
600:              // #if FCT
601:              // 	/* FCT停止uart通讯中断服务 */
602:              // #else
603:              // 	// 串口接收中断服务函数
604:              // 	if (RC1IF)
605:              // 	{
606:              // 		//-------------------------------------------
607:              // 		// 接收控制，如果接收标志位为1，说明有数据接收完毕
608:              // 		// RCIF在寄存器被读出后自动清零
609:              // 		if (FERR1)
610:              // 		{
611:              // 			RCREG1; // 帧错误
612:              // 			return;
613:              // 		}
614:              
615:              // 		RX_Buf = RCREG1; // 将接收缓冲区内容读出
616:              
617:              // 		Uart_ReceiveLogic(); /* UART*/
618:              
619:              // 		if (OERR1) // 如果有溢出错误
620:              // 		{
621:              // 			CREN1 = 0; // 清零CREN1位可将OERR位清零
622:              // 			CREN1 = 1; // 再次将CREN1置一，以允许继续接收
623:              // 		}
624:              // 	}
625:              
626:              // 	// 串口发送中断服务函数
627:              // 	if (TX1IF && TX1IE)
628:              // 	{
629:              // 		// 发送控制
630:              // 		if (TRMT1)
631:              // 		{
632:              // 			Uart_SendLogic();
633:              // 			// TXREG = TX_Buf[tx_cnt];
634:              // 			// tx_cnt++;
635:              // 			// if(tx_cnt >= tx_index)
636:              // 			// {
637:              // 			// 	tx_cnt = 0;
638:              // 			// 	TXIE = 0;
639:              // 			// }
640:              // 		}
641:              // 	}
642:              // #endif
643:              	// PA中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
644:              	// if(RACIF)
645:              	// {
646:              	// 	PORTA;		 //读取PORTA状态
647:              	// 	RACIF = 0; //清中断标志
648:              	// }
649:              
650:              	// PB中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
651:              	// if(RBIF)
652:              	// {
653:              	// 	PORTB;		//读取PORTB状态
654:              	// 	RBIF = 0; //清中断标志
655:              	// }
656:              }
---- D:\mywork.wqs\ARROW\ABM007_79F133\ABM007_79F133\source\sensor.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fbodysensor;
5:                
6:                v_uint8 u8stsBodySensor = 0;
7:                v_uint8 SEQbody = 0;
8:                v_uint16 CNTbody_h = 0;         /* 感应高电平计时 */
9:                v_uint16 CNTbody_l = 0;         /* 感应低电平计时 */
10:               v_uint16 BufCntAdd = 0;         /* 感应计时 */
11:               v_uint16 CNTbodyInTime = 0;     /* 感应到人计时 */
12:               v_uint16 CNTbodyExitTime = 0;   /* 感应到人离开计时 */
13:               
14:               void SensorKey(void);
15:               void SensorTime(void);
16:               void SensorJudge(void);
17:               void SensorControl(void);
18:               
19:               void GsensorLoop(void)
20:               {
21:                   SensorKey();
  001F    2029    CALL	0x29
  0020    120A    CLRB	0xA,4
  0021    118A    CLRB	0xA,3
22:                   SensorTime();
  0022    202A    CALL	0x2A
  0023    120A    CLRB	0xA,4
  0024    118A    CLRB	0xA,3
23:                   SensorJudge();
  0025    207D    CALL	0x7D
  0026    120A    CLRB	0xA,4
  0027    118A    CLRB	0xA,3
24:                   SensorControl();
  0028    2862    JP	0x62
25:               }
26:               
27:               void SensorKey(void)
  0029    0008    RET
28:               {
29:               
30:               }
31:               
32:               /* 人体感应计时函数 */
33:               void SensorTime(void)
34:               {
35:                   if(Fbody == SET)
  002A    1C7A    SNZB	0x7A,0
  002B    284E    JP	0x4E
36:                   {
37:                       FbodyEx5s = CLR;
  002C    12FA    CLRB	0x7A,5
38:                       CNTbodyExitTime = 0;
  002D    01A2    CLR	0x22
  002E    01A3    CLR	0x23
39:                       if(FlightLeave == CLR)  /* 检测到人有效时间 */
  002F    1942    SZB	0x42,2
  0030    2849    JP	0x49
40:                       {
41:                           if(++CNTbodyInTime >= BODY_ENTER_KEEP_60S)	/* 60s */
  0031    0AA4    INCR	0x24
  0032    1903    SZB	0x3,2
  0033    0AA5    INCR	0x25
  0034    3017    LDIA	0x17
  0035    0225    SUBA	0x25
  0036    3070    LDIA	0x70
  0037    1903    SZB	0x3,2
  0038    0224    SUBA	0x24
  0039    1C03    SNZB	0x3,0
  003A    2841    JP	0x41
42:                           {
43:                               CNTbodyInTime = BODY_ENTER_KEEP_60S;
  003B    3070    LDIA	0x70
  003C    00A4    LD	0x24,A
  003D    3017    LDIA	0x17
  003E    00A5    LD	0x25,A
44:                               FbodyIn60s = SET;
  003F    15FA    SETB	0x7A,3
45:                           }
  0040    0008    RET
46:                           else if(CNTbodyInTime >= BODY_ENTER_KEEP_5S)		/* 5s */
  0041    3001    LDIA	0x1
  0042    0225    SUBA	0x25
  0043    30F4    LDIA	0xF4
  0044    1903    SZB	0x3,2
  0045    0224    SUBA	0x24
  0046    1803    SZB	0x3,0
47:                           {
48:                               FbodyIn5s = SET;
  0047    167A    SETB	0x7A,4
  0048    0008    RET
49:                           }
50:                       }
51:                       else
52:                       {
53:                           if(FbodyIn5s == CLR)    /* 未待满5s，时间清零 */
  0049    1A7A    SZB	0x7A,4
  004A    0008    RET
54:                           {
55:                               CNTbodyInTime = 0;
  004B    01A4    CLR	0x24
  004C    01A5    CLR	0x25
56:                           }
57:                       }
58:                   }
  004D    0008    RET
59:                   else
60:                   {
61:                       CNTbodyInTime = 0;
  004E    01A4    CLR	0x24
  004F    01A5    CLR	0x25
62:                       FbodyIn5s = CLR;
  0050    127A    CLRB	0x7A,4
63:                       FbodyIn60s = CLR;
  0051    11FA    CLRB	0x7A,3
64:                       if(++CNTbodyExitTime >= BODY_EXIT_KEEP_5S)
  0052    0AA2    INCR	0x22
  0053    1903    SZB	0x3,2
  0054    0AA3    INCR	0x23
  0055    3001    LDIA	0x1
  0056    0223    SUBA	0x23
  0057    30F4    LDIA	0xF4
  0058    1903    SZB	0x3,2
  0059    0222    SUBA	0x22
  005A    1C03    SNZB	0x3,0
  005B    0008    RET
65:                       {
66:                           CNTbodyExitTime = BODY_EXIT_KEEP_5S;
  005C    30F4    LDIA	0xF4
  005D    00A2    LD	0x22,A
  005E    3001    LDIA	0x1
  005F    00A3    LD	0x23,A
67:                           FbodyEx5s = SET;        /* 人离开5秒 */
  0060    16FA    SETB	0x7A,5
  0061    0008    RET
68:                       }
69:                   }
70:               }
71:               
72:               /* 人体感应判定函数 */
73:               void SensorJudge(void)
74:               {
75:                   switch (SEQbody)
  007D    28FA    JP	0xFA
76:                   {
77:                       case 0:
78:                           Fbody = CLR;
  007E    107A    CLRB	0x7A,0
79:                           FlightLeave = CLR;
  007F    1142    CLRB	0x42,2
80:                           SEQbody = 1;
  008F    3001    LDIA	0x1
  0090    00BB    LD	0x3B,A
81:                           break;
  0091    0008    RET
82:               
83:                       /* 人离开确认 */
84:                       case 1:
85:                           Fbody = CLR;
  0092    107A    CLRB	0x7A,0
86:                           FlightLeave = CLR;
  0093    1142    CLRB	0x42,2
87:                           if(PIsensor == LOW)
  0094    1886    SZB	0x6,1
  0095    28A7    JP	0xA7
88:                           {
89:                               if(++CNTbody_h >= SENSOR_TRG)
  0096    0AAA    INCR	0x2A
  0097    1903    SZB	0x3,2
  0098    0AAB    INCR	0x2B
  0099    3000    LDIA	0x0
  009A    022B    SUBA	0x2B
  009B    3003    LDIA	0x3
  009C    1903    SZB	0x3,2
  009D    022A    SUBA	0x2A
  009E    1C03    SNZB	0x3,0
  009F    0008    RET
90:                               {
91:                                   CNTbody_h = 0;
  00A0    01AA    CLR	0x2A
  00A1    01AB    CLR	0x2B
92:               					CNTbody_l = 0;
  00A2    01A8    CLR	0x28
  00A3    01A9    CLR	0x29
93:               					SEQbody = 2;
  00A4    3002    LDIA	0x2
  00A5    00BB    LD	0x3B,A
94:               					break;
  00A6    0008    RET
95:                               }
96:                           }
97:                           else
98:                           {
99:                               CNTbody_h = 0;
  00A7    01AA    CLR	0x2A
  00A8    01AB    CLR	0x2B
  00A9    0008    RET
100:                          }
101:                          break;
102:              
103:                      /* 感应到人判定开始 */
104:                      case 2:
105:                          Fbody = CLR;
  00AA    107A    CLRB	0x7A,0
106:                          FlightLeave = CLR;
  00AB    1142    CLRB	0x42,2
107:                          if(PIsensor == LOW)
  00AC    1886    SZB	0x6,1
  00AD    2881    JP	0x81
108:                          {
109:                              ++CNTbody_h;
  00AE    0AAA    INCR	0x2A
  00AF    1903    SZB	0x3,2
  00B0    0AAB    INCR	0x2B
110:                          }
  0080    288F    JP	0x8F
111:                          else
112:                          {
113:                              if(++CNTbody_l >= SENSOR_ERROR)
  0081    0AA8    INCR	0x28
  0082    1903    SZB	0x3,2
  0083    0AA9    INCR	0x29
  0084    3000    LDIA	0x0
  0085    0229    SUBA	0x29
  0086    3006    LDIA	0x6
  0087    1903    SZB	0x3,2
  0088    0228    SUBA	0x28
  0089    1C03    SNZB	0x3,0
  008A    28B1    JP	0xB1
114:                              {
115:                                  CNTbody_h = 0;
  008B    01AA    CLR	0x2A
  008C    01AB    CLR	0x2B
116:                                  CNTbody_l = 0;
  008D    01A8    CLR	0x28
  008E    01A9    CLR	0x29
117:                                  SEQbody = 1;
118:                                  break;
119:                              }
120:                          }
121:                          BufCntAdd = CNTbody_h +CNTbody_l;
  00B1    210C    CALL	0x10C
  00B2    120A    CLRB	0xA,4
  00B3    118A    CLRB	0xA,3
122:                          if(BufCntAdd >= SENSOR_BODY_ENTER_X_0S)
  00B4    3000    LDIA	0x0
  00B5    0227    SUBA	0x27
  00B6    301E    LDIA	0x1E
  00B7    1903    SZB	0x3,2
  00B8    0226    SUBA	0x26
  00B9    1C03    SNZB	0x3,0
  00BA    0008    RET
123:                          {
124:                              SEQbody = 3;
  00BB    3003    LDIA	0x3
  00BC    00BB    LD	0x3B,A
125:                              break;
  00BD    0008    RET
126:                          }
127:                          break;
128:                      /* 感应到人确认 */
129:                      case 3:
130:                          Fbody = SET;
  00BE    147A    SETB	0x7A,0
131:                          FlightLeave = CLR;
  00BF    1142    CLRB	0x42,2
132:                          if(PIsensor == HIGH)
  00C0    1C86    SNZB	0x6,1
  00C1    28D3    JP	0xD3
133:                          {
134:                              if(++CNTbody_l >= SENSOR_TRG)
  00C2    0AA8    INCR	0x28
  00C3    1903    SZB	0x3,2
  00C4    0AA9    INCR	0x29
  00C5    3000    LDIA	0x0
  00C6    0229    SUBA	0x29
  00C7    3003    LDIA	0x3
  00C8    1903    SZB	0x3,2
  00C9    0228    SUBA	0x28
  00CA    1C03    SNZB	0x3,0
  00CB    0008    RET
135:                              {
136:                                  CNTbody_h = 0;
  00CC    01AA    CLR	0x2A
  00CD    01AB    CLR	0x2B
137:                                  CNTbody_l = 0;
  00CE    01A8    CLR	0x28
  00CF    01A9    CLR	0x29
138:                                  SEQbody = 4;
  00D0    3004    LDIA	0x4
  00D1    00BB    LD	0x3B,A
139:                                  break;
  00D2    0008    RET
140:                              }
141:                          }
142:                          else
143:                          {
144:                              CNTbody_l = 0;
  00D3    01A8    CLR	0x28
  00D4    01A9    CLR	0x29
  00D5    0008    RET
145:                          }
146:                          break;
147:                      /* 人离开判定开始 */
148:                      case 4:
149:                          Fbody = SET;
  00D6    147A    SETB	0x7A,0
150:                          FlightLeave = SET;
  00D7    1542    SETB	0x42,2
151:                          if(PIsensor == LOW)
  00D8    1886    SZB	0x6,1
  00D9    28E9    JP	0xE9
152:                          {
153:                              if(++CNTbody_h >= SENSOR_ERROR)
  00DA    0AAA    INCR	0x2A
  00DB    1903    SZB	0x3,2
  00DC    0AAB    INCR	0x2B
  00DD    3000    LDIA	0x0
  00DE    022B    SUBA	0x2B
  00DF    3006    LDIA	0x6
  00E0    1903    SZB	0x3,2
  00E1    022A    SUBA	0x2A
  00E2    1C03    SNZB	0x3,0
  00E3    28EC    JP	0xEC
154:                              {
155:                                  CNTbody_h = 0;
  00E4    01AA    CLR	0x2A
  00E5    01AB    CLR	0x2B
156:                                  CNTbody_l = 0;
  00E6    01A8    CLR	0x28
  00E7    01A9    CLR	0x29
  00E8    28BB    JP	0xBB
157:                                  SEQbody = 3;
158:                                  break;
159:                              }
160:                          }
161:                          else
162:                          {
163:                              ++CNTbody_l;
  00E9    0AA8    INCR	0x28
  00EA    1903    SZB	0x3,2
  00EB    0AA9    INCR	0x29
164:                          }
165:                          BufCntAdd = CNTbody_h +CNTbody_l;
  00EC    210C    CALL	0x10C
  00ED    120A    CLRB	0xA,4
  00EE    118A    CLRB	0xA,3
166:                          if(BufCntAdd >= SENSOR_BODY_EXIT_X_0S)      /* 暂改为5s */
  00EF    3001    LDIA	0x1
  00F0    0227    SUBA	0x27
  00F1    30F4    LDIA	0xF4
  00F2    1903    SZB	0x3,2
  00F3    0226    SUBA	0x26
  00F4    1C03    SNZB	0x3,0
  00F5    0008    RET
  00F6    288F    JP	0x8F
167:                          {
168:                              SEQbody = 1;
169:                              break;
170:                          }
171:                          break;
172:                      default:
173:                          SEQbody = 0;
  00F7    01BB    CLR	0x3B
174:                          FlightLeave = CLR;
  00F8    1142    CLRB	0x42,2
175:                          break;
  00F9    0008    RET
  00FA    083B    LD	A,0x3B
  00FB    3A00    XORIA	0x0
  00FC    1903    SZB	0x3,2
  00FD    287E    JP	0x7E
  00FE    3A01    XORIA	0x1
  00FF    1903    SZB	0x3,2
  0100    2892    JP	0x92
  0101    3A03    XORIA	0x3
  0102    1903    SZB	0x3,2
  0103    28AA    JP	0xAA
  0104    3A01    XORIA	0x1
  0105    1903    SZB	0x3,2
  0106    28BE    JP	0xBE
  0107    3A07    XORIA	0x7
  0108    1903    SZB	0x3,2
  0109    28D6    JP	0xD6
  010A    28F7    JP	0xF7
  010B    0008    RET
176:                  }
177:              }
178:              
179:              void SensorControl(void)
180:              {
181:                  FbodyEnter = CLR;
  0062    10FA    CLRB	0x7A,1
182:                  FbodyExit = CLR;
  0063    117A    CLRB	0x7A,2
183:                  if(Fbufbody != Fbody)
  0064    1C7A    SNZB	0x7A,0
  0065    2868    JP	0x68
  0066    3001    LDIA	0x1
  0067    2869    JP	0x69
  0068    3000    LDIA	0x0
  0069    00F2    LD	0x72,A
  006A    1F7A    SNZB	0x7A,6
  006B    286E    JP	0x6E
  006C    3001    LDIA	0x1
  006D    286F    JP	0x6F
  006E    3000    LDIA	0x0
  006F    0672    XORA	0x72
  0070    1903    SZB	0x3,2
  0071    0008    RET
184:                  {
185:                      if(Fbody == SET)
  0072    1C7A    SNZB	0x7A,0
  0073    2876    JP	0x76
186:                      {
187:                          FbodyEnter = SET;   /* 感应到人瞬间 */
  0074    14FA    SETB	0x7A,1
188:                      }
  0075    2877    JP	0x77
189:                      else
190:                      {
191:                          FbodyExit = SET;    /* 人离开瞬间 */
  0076    157A    SETB	0x7A,2
192:                      }
193:                      Fbufbody = Fbody;
  0077    1C7A    SNZB	0x7A,0
  0078    287B    JP	0x7B
  0079    177A    SETB	0x7A,6
  007A    0008    RET
  007B    137A    CLRB	0x7A,6
  007C    0008    RET
194:                  }
195:              }
196:              
---- D:\mywork.wqs\ARROW\ABM007_79F133\ABM007_79F133\source\light.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE FledBits01;
5:                
6:                v_uint16 CNTbreath_Led;
7:                v_uint16 CNTbreath_Led1;
8:                v_uint16 CNTbreath_Led2;
9:                v_uint16 CNTbreath_Led3;
10:               
11:               void LED_Key(void);
12:               void LED_Judge(void);
13:               void LED_Con(void);
14:               void LED_Time(void);
15:               
16:               void GledLoop(void)
17:               {
18:               	LED_Time();
  032E    2339    CALL	0x339
  032F    120A    CLRB	0xA,4
  0330    118A    CLRB	0xA,3
19:               	LED_Key();
  0331    2338    CALL	0x338
  0332    120A    CLRB	0xA,4
  0333    118A    CLRB	0xA,3
20:               	LED_Judge();
  0334    2346    CALL	0x346
  0335    120A    CLRB	0xA,4
  0336    118A    CLRB	0xA,3
21:               	LED_Con();
  0337    2B3C    JP	0x33C
22:               }
23:               
24:               void LED_Key(void)
  0338    0008    RET
25:               {
26:               	// switch(SiCon_SETkey)
27:               	// {	
28:               	// 	case KEY_LIGHT:
29:               	// 		Flight = ~Flight;
30:               	// 		if(Flight == SET)
31:               	// 		{
32:               	// 			GbuzOutSet(2);
33:               	// 		}
34:               	// 		else
35:               	// 		{
36:               	// 			GbuzOutSet(1);
37:               	// 		}
38:               	// 		break;
39:               	// 	default:
40:               			
41:               	// 		break;
42:               	// }
43:               }
44:               
45:               void LED_Time(void)
46:               {
47:               	if(F1min_lgt == SET)
  0339    1843    SZB	0x43,0
48:               	{
49:               		F1min_lgt = CLR;
  033A    1043    CLRB	0x43,0
  033B    0008    RET
50:               	}
51:               }
52:               
53:               void LED_Judge(void)
54:               {
55:               	if(Fbody == SET)	/* 感应到人开启 */
  0346    1C7A    SNZB	0x7A,0
  0347    2B4C    JP	0x34C
56:               	{
57:               		Flight = SET;
  0348    1442    SETB	0x42,0
58:               		if(FbodyIn5s == CLR)	/* 检测到人5秒之内 */
  0349    1E7A    SNZB	0x7A,4
59:               		{
60:               			if(FlightLeave == SET)	/* 离开状态，熄灭指示灯 */
  034A    1D42    SNZB	0x42,2
  034B    0008    RET
61:               			{
62:               				Flight = CLR;
  034C    1042    CLRB	0x42,0
  034D    0008    RET
63:               			}
64:               		}
65:               	}
66:               	else
67:               	{
68:               		// if(Fbuflight == SET)
69:               		// {
70:               		// 	Flight = SET;	/* 离开5s内 */
71:               		// 	if(FbodyEx5s == SET)
72:               		// 	{
73:               		// 		Flight = CLR;
74:               		// 		Fbuflight = CLR;
75:               		// 	}
76:               		// }
77:               		// else
78:               		// {
79:               			Flight = CLR;
80:               		// }
81:               	}
82:               }
83:               
84:               void LED_Con(void)
85:               {
86:               	POlight	= Flight;
  033C    1C42    SNZB	0x42,0
  033D    2B42    JP	0x342
  033E    1283    CLRB	0x3,5
  033F    1303    CLRB	0x3,6
  0340    1685    SETB	0x5,5
  0341    0008    RET
  0342    1283    CLRB	0x3,5
  0343    1303    CLRB	0x3,6
  0344    1285    CLRB	0x5,5
  0345    0008    RET
87:               	/* 呼吸灯频率 */
88:               	// if (Flight == SET)
89:               	// {
90:               	// 	if (FbreathDir == CLR)
91:               	// 	{
92:               	// 		if (CNTbreath_Led2 >= 80)	/* 亮度降低 */
93:               	// 		{
94:               	// 			CNTbreath_Led2 = 80;
95:               	// 			if (++CNTbreath_Led3 > 10)	/* 100ms，min */
96:               	// 			{
97:               	// 				FbreathDir = SET;
98:               	// 				CNTbreath_Led3 = 0;
99:               	// 			}
100:              	// 		}
101:              	// 		else if (CNTbreath_Led2 > 45)	/* 35*4*10=1050ms */
102:              	// 		{
103:              	// 			if (++CNTbreath_Led1 >= 3)
104:              	// 			{
105:              	// 				CNTbreath_Led1 = 0;
106:              	// 				CNTbreath_Led2++;
107:              	// 			}
108:              	// 		}
109:              	// 		else if (CNTbreath_Led2 > 30)	/* 15*8*10 = 1200ms */
110:              	// 		{
111:              	// 			if (++CNTbreath_Led1 >= 8)
112:              	// 			{
113:              	// 				CNTbreath_Led1 = 0;
114:              	// 				CNTbreath_Led2++;
115:              	// 			}
116:              	// 		}
117:              	// 		else if (CNTbreath_Led2 > 10)	/* 1000ms */
118:              	// 		{
119:              	// 			if (++CNTbreath_Led1 >= 5)
120:              	// 			{
121:              	// 				CNTbreath_Led1 = 0;
122:              	// 				CNTbreath_Led2++;
123:              	// 			}
124:              	// 		}
125:              	// 		else
126:              	// 		{
127:              	// 			if (++CNTbreath_Led1 >= 11)	/* (11-5)*10=600ms，max */
128:              	// 			{
129:              	// 				CNTbreath_Led1 = 0;
130:              	// 				CNTbreath_Led2++;
131:              	// 			}
132:              	// 		}
133:              	// 	}
134:              	// 	else
135:              	// 	{
136:              	// 		if (CNTbreath_Led2 < 5)	/* max */
137:              	// 		{
138:              	// 			CNTbreath_Led2 = 5;
139:              	// 			FbreathDir = CLR;
140:              	// 		}
141:              	// 		else if (CNTbreath_Led2 < 10)
142:              	// 		{
143:              	// 			if (++CNTbreath_Led1 >= 6)	/* 600ms */
144:              	// 			{
145:              	// 				CNTbreath_Led1 = 0;
146:              	// 				CNTbreath_Led2--;
147:              	// 			}
148:              	// 		}
149:              	// 		else if (CNTbreath_Led2 < 30)
150:              	// 		{
151:              	// 			if (++CNTbreath_Led1 >= 6)	/* 1200ms */
152:              	// 			{
153:              	// 				CNTbreath_Led1 = 0;
154:              	// 				CNTbreath_Led2--;
155:              	// 			}
156:              	// 		}
157:              	// 		else if (CNTbreath_Led2 < 40)
158:              	// 		{
159:              	// 			if (++CNTbreath_Led1 >= 8)	/* 800ms */
160:              	// 			{
161:              	// 				CNTbreath_Led1 = 0;
162:              	// 				CNTbreath_Led2--;
163:              	// 			}
164:              	// 		}
165:              	// 		else if (CNTbreath_Led2 < 60)
166:              	// 		{
167:              	// 			if (++CNTbreath_Led1 >= 4)	/* 800ms */
168:              	// 			{
169:              	// 				CNTbreath_Led1 = 0;
170:              	// 				CNTbreath_Led2--;
171:              	// 			}
172:              	// 		}
173:              	// 		else
174:              	// 		{
175:              	// 			if (++CNTbreath_Led1 >= 3)	/* 600ms，min */
176:              	// 			{
177:              	// 				CNTbreath_Led1 = 0;
178:              	// 				CNTbreath_Led2--;
179:              	// 			}
180:              	// 		}
181:              	// 	}
182:              	// }
183:              	// else
184:              	// {
185:              	// 	CNTbreath_Led1 = 0;
186:              	// 	CNTbreath_Led2 = 0;
187:              	// 	CNTbreath_Led3 = 0;
188:              	// 	FbreathDir = CLR;
189:              	// 	POlight = OFF;
190:              	// }
191:              }
192:              
193:              void INT_LED_SHOW(void)
  032D    0008    RET
194:              {
195:              	// if((Flight == SET) && (FfctTest == CLR))
196:              	// {
197:              	// 	if (++CNTbreath_Led == 80)
198:              	// 	{
199:              	// 		CNTbreath_Led = 0;
200:              	// 		POlight = OFF;
201:              	// 	}
202:              	// 	if (CNTbreath_Led >= CNTbreath_Led2)
203:              	// 	{
204:              	// 		POlight = ON;
205:              	// 	}
206:              	// 	else
207:              	// 	{
208:              	// 		POlight = OFF;
209:              	// 	}
210:              	// }
211:              }
---- D:\mywork.wqs\ARROW\ABM007_79F133\ABM007_79F133\source\flush.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fflush1;
5:                
6:                enum{
7:                    FLUSH_INIT_0 = 0,
8:                    FLUSH_INIT_1,
9:                    FLUSH_INIT_2,
10:                   FLUSH_BIG_0,
11:                   FLUSH_BIG_1,
12:                   FLUSH_BIG_2,
13:                   FLUSH_SML_0,
14:                   FLUSH_SML_1,
15:                   FLUSH_SML_2,
16:                   FLUSH_END_0,
17:                   FLUSH_END_1,
18:                   FLUSH_END_2,
19:               };
20:               
21:               v_uint8 SEQflsuh = 0;
22:               v_uint16 CNTflush = 0;  /* 冲水计时 */
23:               
24:               void FlushTime(void);
25:               void FlushJudge(void);
26:               void FlushCon(void);
27:               
28:               void GflushLoop(void)
29:               {
30:                   FlushTime();
  0115    211C    CALL	0x11C
  0116    120A    CLRB	0xA,4
  0117    118A    CLRB	0xA,3
31:                   FlushJudge();
  0118    21DD    CALL	0x1DD
  0119    120A    CLRB	0xA,4
  011A    118A    CLRB	0xA,3
32:                   FlushCon();
  011B    291D    JP	0x11D
33:               }
34:               
35:               void FlushTime(void)
  011C    0008    RET
36:               {
37:               
38:               }
39:               void FlushJudge(void)
40:               {
41:                   /* 请求判定 */
42:               #if DUBLE_FLUSH_MODE
43:                   if(FbodyIn60s == SET)   /* 感应到60秒以上，大冲请求置位 */
44:                   {
45:                       YKfls_Big = SET;
46:                       YKfls_Sml = CLR;
47:                   }
48:                   else if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
49:                   {
50:                       YKfls_Sml = SET;
51:                       YKfls_Big = CLR;
52:                   }
53:                   else
54:                   {
55:                       YKfls_Sml = CLR;
56:                       YKfls_Big = CLR;
57:                   }
58:               #else
59:                   if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
  01DD    1E7A    SNZB	0x7A,4
  01DE    29E2    JP	0x1E2
60:                   {
61:                       // YKfls_Sml = SET;
62:                       // YKfls_Big = CLR;
63:                       YKfls_Sml = CLR;
  01DF    1178    CLRB	0x78,2
64:                       YKfls_Big = SET;
  01E0    1478    SETB	0x78,0
65:                   }
  01E1    29E4    JP	0x1E4
66:                   else
67:                   {
68:                       YKfls_Sml = CLR;
  01E2    1178    CLRB	0x78,2
69:                       YKfls_Big = CLR;
  01E3    1078    CLRB	0x78,0
70:                   }
71:               #endif
72:                   /*********************************************/
73:               	/*	自动冲水判断	*/
74:               	if (FbodyExit == SET)	/* 离开冲水 */
  01E4    197A    SZB	0x7A,2
75:               	{
76:                       Flush_AutoLeaveWait = SET;
  01E5    17F8    SETB	0x78,7
77:               	}
78:               	if (Flush_AutoLeaveWait == SET) /*	离开自动冲水	*/
  01E6    1FF8    SNZB	0x78,7
  01E7    0008    RET
79:               	{
80:               		if (f_STSflush == SET)
  01E8    1F78    SNZB	0x78,6
  01E9    29ED    JP	0x1ED
81:               		{
82:                           YKfls_Sml = CLR;
  01EA    1178    CLRB	0x78,2
83:                           YKfls_Big = CLR;    /* 正在冲水，请求清除 */
  01EB    1078    CLRB	0x78,0
84:               			return;
  01EC    0008    RET
85:               		}
86:               		Flush_AutoLeaveWait = CLR;
  01ED    13F8    CLRB	0x78,7
87:                       if(YKfls_Big == SET)
  01EE    1C78    SNZB	0x78,0
  01EF    29F3    JP	0x1F3
88:                       {
89:                           YKfls_Big = CLR;
  01F0    1078    CLRB	0x78,0
90:                           OKfls_Big = SET;
  01F1    14F8    SETB	0x78,1
91:                           return;
  01F2    0008    RET
92:                       }
93:               		if(YKfls_Sml == SET)
  01F3    1D78    SNZB	0x78,2
  01F4    0008    RET
94:                       {
95:                           YKfls_Sml = CLR;
  01F5    1178    CLRB	0x78,2
96:                           OKfls_Sml = SET;
  01F6    15F8    SETB	0x78,3
  01F7    0008    RET
97:                       }
98:               		return;
99:               	}
100:              	/*	自动冲水判断	*/
101:              	/******************************************/
102:              }
103:              
104:              /* 主阀气泵控制函数 */
105:              void FlushCon(void)
106:              {
107:                  switch (SEQflsuh)
  011D    29B9    JP	0x1B9
108:                  {
109:                      case FLUSH_INIT_0:
110:                          f_STSflush = CLR;
  011E    1378    CLRB	0x78,6
111:                          POairPump = OFF;
  011F    1105    CLRB	0x5,2
112:                          POmainValue = OFF;
  0120    1205    CLRB	0x5,4
113:                          if((OKfls_Big == SET) || (OKfls_Sml == SET))
  0121    18F8    SZB	0x78,1
  0122    2925    JP	0x125
  0123    1DF8    SNZB	0x78,3
  0124    0008    RET
114:                          {
115:                              SEQflsuh = FLUSH_INIT_1;
  0125    3001    LDIA	0x1
  0126    2928    JP	0x128
116:                              CNTflush = 0;
  0129    01F6    CLR	0x76
  012A    01F7    CLR	0x77
  012B    0008    RET
117:                          }
118:                          break;
119:                      case FLUSH_INIT_1:
120:                          f_STSflush = SET;
  012C    1778    SETB	0x78,6
121:                          POairPump = OFF;
  012D    1105    CLRB	0x5,2
122:                          POmainValue = OFF;
  012E    1205    CLRB	0x5,4
123:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  012F    187A    SZB	0x7A,0
  0130    2927    JP	0x127
124:                          {
125:                              SEQflsuh = FLUSH_END_0;
  0127    3009    LDIA	0x9
  0128    00BD    LD	0x3D,A
126:                              CNTflush = 0;
127:                              break;
128:                          }
129:                          if(++CNTflush >= 5)
  0131    0AF6    INCR	0x76
  0132    1903    SZB	0x3,2
  0133    0AF7    INCR	0x77
  0134    3000    LDIA	0x0
  0135    0277    SUBA	0x77
  0136    3005    LDIA	0x5
  0137    1903    SZB	0x3,2
  0138    0276    SUBA	0x76
  0139    1C03    SNZB	0x3,0
  013A    0008    RET
130:                          {
131:                              CNTflush = 0;
  013B    01F6    CLR	0x76
  013C    01F7    CLR	0x77
132:                              SEQflsuh = FLUSH_INIT_2;
  013D    3002    LDIA	0x2
  013E    00BD    LD	0x3D,A
  013F    0008    RET
133:                          }
134:                          break;
135:                      case FLUSH_INIT_2:
136:                          f_STSflush = SET;
  0140    1778    SETB	0x78,6
137:                          POairPump = OFF;        /* 冲水关闭 */
  0141    1105    CLRB	0x5,2
138:                          POmainValue = OFF;      /* 冲水通道1 */
  0142    1205    CLRB	0x5,4
139:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  0143    187A    SZB	0x7A,0
  0144    2927    JP	0x127
140:                          {
141:                              SEQflsuh = FLUSH_END_0;
142:                              CNTflush = 0;
143:                              break;
144:                          }
145:              
146:                          if(OKfls_Big == SET)
  0145    1CF8    SNZB	0x78,1
  0146    294A    JP	0x14A
147:                          {
148:                              SEQflsuh = FLUSH_BIG_0;
  0147    3003    LDIA	0x3
  0148    00BD    LD	0x3D,A
149:                          }
  0149    0008    RET
150:                          else if(OKfls_Sml == SET)
  014A    1DF8    SNZB	0x78,3
  014B    0008    RET
151:                          {
152:                              SEQflsuh = FLUSH_SML_0;
  014C    3006    LDIA	0x6
  014D    00BD    LD	0x3D,A
  014E    0008    RET
153:                          }
154:                          break;
155:                      case FLUSH_BIG_0:   /* 大冲阶段 */
156:                          f_STSflush = SET;
157:                          POairPump = OFF;        /* 大冲先开电磁阀换大冲，后开气泵冲水 */
158:                          POmainValue = ON;       /* 切换通道2 */     /* 冲水通道2 */
159:                          if(++CNTflush >= 10)    /* 延迟100ms后打开气泵冲水 */
  014F    2201    CALL	0x201
  0150    120A    CLRB	0xA,4
  0151    118A    CLRB	0xA,3
  0152    1903    SZB	0x3,2
  0153    0276    SUBA	0x76
  0154    1C03    SNZB	0x3,0
  0155    0008    RET
160:                          {
161:                              CNTflush = 0;
  0156    01F6    CLR	0x76
  0157    01F7    CLR	0x77
162:                              SEQflsuh = FLUSH_BIG_1;
  0158    3004    LDIA	0x4
  0159    00BD    LD	0x3D,A
  015A    0008    RET
163:                          }
164:                          break;
165:                      case FLUSH_BIG_1:
166:                          f_STSflush = SET;
  015B    1778    SETB	0x78,6
167:                          POairPump = ON;
  015C    1505    SETB	0x5,2
168:                          POmainValue = ON;
  015D    1605    SETB	0x5,4
169:              #if ABM007_FLUSH_2
170:                          if(++CNTflush >= 100)   /* 冲水1s */
  015E    0AF6    INCR	0x76
  015F    1903    SZB	0x3,2
  0160    0AF7    INCR	0x77
  0161    3000    LDIA	0x0
  0162    0277    SUBA	0x77
  0163    3064    LDIA	0x64
  0164    1903    SZB	0x3,2
  0165    0276    SUBA	0x76
  0166    1C03    SNZB	0x3,0
  0167    0008    RET
171:                          {
172:                              CNTflush = 0;
  0168    01F6    CLR	0x76
  0169    01F7    CLR	0x77
173:                              SEQflsuh = FLUSH_BIG_2;
  016A    3005    LDIA	0x5
  016B    00BD    LD	0x3D,A
  016C    0008    RET
174:                          }
175:              #else
176:                          if(++CNTflush >= 200)   /* 冲水2s */
177:                          {
178:                              CNTflush = 0;
179:                              SEQflsuh = FLUSH_BIG_2;
180:                          }
181:              #endif
182:                          break;
183:                      case FLUSH_BIG_2:
184:                          f_STSflush = SET;
185:                          POairPump = OFF;        /* 关气泵，停止冲水 */
186:                          POmainValue = SET;      /* 大冲先关气泵停止冲水，后关主阀 */    /* 冲水通道2 */
187:                          if(++CNTflush >= 10)
  016D    2201    CALL	0x201
  016E    120A    CLRB	0xA,4
  016F    118A    CLRB	0xA,3
  0170    1903    SZB	0x3,2
  0171    0276    SUBA	0x76
  0172    1C03    SNZB	0x3,0
  0173    0008    RET
188:                          {
189:                              CNTflush = 0;
  0174    01F6    CLR	0x76
  0175    01F7    CLR	0x77
190:                              SEQflsuh = FLUSH_END_0;
  0176    3009    LDIA	0x9
  0177    00BD    LD	0x3D,A
  0178    0008    RET
191:                          }
192:                          break;
193:              
194:                      case FLUSH_SML_0:           /* 小冲阶段 */
195:                          f_STSflush = SET;
196:                          POairPump = OFF;        /* 小冲关闭电磁阀 */
197:                          POmainValue = OFF;      /* 冲水通道1 */
198:                          if(++CNTflush >= 5)
  0179    21F8    CALL	0x1F8
  017A    120A    CLRB	0xA,4
  017B    118A    CLRB	0xA,3
  017C    1903    SZB	0x3,2
  017D    0276    SUBA	0x76
  017E    1C03    SNZB	0x3,0
  017F    0008    RET
199:                          {
200:                              CNTflush = 0;
  0180    01F6    CLR	0x76
  0181    01F7    CLR	0x77
201:                              SEQflsuh = FLUSH_SML_1;
  0182    3007    LDIA	0x7
  0183    00BD    LD	0x3D,A
  0184    0008    RET
202:                          }
203:                          break;
204:                      case FLUSH_SML_1:
205:                          f_STSflush = SET;
  0185    1778    SETB	0x78,6
206:                          POairPump = ON;         /* 冲水 */
  0186    1505    SETB	0x5,2
207:                          POmainValue = OFF;      /* 冲水通道1 */
  0187    1205    CLRB	0x5,4
208:                          if(++CNTflush >= 200)
  0188    0AF6    INCR	0x76
  0189    1903    SZB	0x3,2
  018A    0AF7    INCR	0x77
  018B    3000    LDIA	0x0
  018C    0277    SUBA	0x77
  018D    30C8    LDIA	0xC8
  018E    1903    SZB	0x3,2
  018F    0276    SUBA	0x76
  0190    1C03    SNZB	0x3,0
  0191    0008    RET
209:                          {
210:                              CNTflush = 0;
  0192    01F6    CLR	0x76
  0193    01F7    CLR	0x77
211:                              SEQflsuh = FLUSH_SML_2;
  0194    3008    LDIA	0x8
  0195    00BD    LD	0x3D,A
  0196    0008    RET
212:                          }
213:                          break;
214:                      case FLUSH_SML_2:
215:                          f_STSflush = SET;
216:                          POairPump = OFF;        /* 关气泵，停止冲水 */
217:                          POmainValue = OFF;      /* 冲水通道1 */
218:                          if(++CNTflush >= 5)
  0197    21F8    CALL	0x1F8
  0198    120A    CLRB	0xA,4
  0199    118A    CLRB	0xA,3
  019A    2970    JP	0x170
219:                          {
220:                              CNTflush = 0;
221:                              SEQflsuh = FLUSH_END_0;
222:                          }
223:                          break;
224:              
225:                      case FLUSH_END_0:
226:                          f_STSflush = SET;
227:                          POairPump = OFF;        /* 停止冲水 */
228:                          POmainValue = OFF;      /* 返回通道1 */
229:                          if(++CNTflush >= 5)
  019B    21F8    CALL	0x1F8
  019C    120A    CLRB	0xA,4
  019D    118A    CLRB	0xA,3
  019E    1903    SZB	0x3,2
  019F    0276    SUBA	0x76
  01A0    1C03    SNZB	0x3,0
  01A1    0008    RET
230:                          {
231:                              CNTflush = 0;
  01A2    01F6    CLR	0x76
  01A3    01F7    CLR	0x77
232:                              SEQflsuh = FLUSH_END_1;
  01A4    300A    LDIA	0xA
  01A5    00BD    LD	0x3D,A
  01A6    0008    RET
233:                          }
234:                          break;
235:                      case FLUSH_END_1:
236:                          f_STSflush = CLR;
  01A7    1378    CLRB	0x78,6
237:                          POairPump = OFF;
  01A8    1105    CLRB	0x5,2
238:                          POmainValue = OFF;
  01A9    1205    CLRB	0x5,4
239:                          SEQflsuh = FLUSH_INIT_0;
  01AA    01BD    CLR	0x3D
240:                          CNTflush = 0;
  01AB    01F6    CLR	0x76
  01AC    01F7    CLR	0x77
241:                          OKfls_Big = CLR;
  01AD    10F8    CLRB	0x78,1
242:                          OKfls_Sml = CLR;
  01AE    11F8    CLRB	0x78,3
243:                          break;
  01AF    0008    RET
244:                      default:
245:                          f_STSflush = CLR;
  01B0    1378    CLRB	0x78,6
246:                          POairPump = OFF;
  01B1    1105    CLRB	0x5,2
247:                          POmainValue = OFF;
  01B2    1205    CLRB	0x5,4
248:                          OKfls_Big = CLR;
  01B3    10F8    CLRB	0x78,1
249:                          OKfls_Sml = CLR;
  01B4    11F8    CLRB	0x78,3
250:                          SEQflsuh = FLUSH_INIT_0;
  01B5    01BD    CLR	0x3D
251:                          CNTflush = 0;
  01B6    01F6    CLR	0x76
  01B7    01F7    CLR	0x77
252:                          break;
  01B8    0008    RET
  01B9    083D    LD	A,0x3D
  01BA    3A00    XORIA	0x0
  01BB    1903    SZB	0x3,2
  01BC    291E    JP	0x11E
  01BD    3A01    XORIA	0x1
  01BE    1903    SZB	0x3,2
  01BF    292C    JP	0x12C
  01C0    3A03    XORIA	0x3
  01C1    1903    SZB	0x3,2
  01C2    2940    JP	0x140
  01C3    3A01    XORIA	0x1
  01C4    1903    SZB	0x3,2
  01C5    294F    JP	0x14F
  01C6    3A07    XORIA	0x7
  01C7    1903    SZB	0x3,2
  01C8    295B    JP	0x15B
  01C9    3A01    XORIA	0x1
  01CA    1903    SZB	0x3,2
  01CB    296D    JP	0x16D
  01CC    3A03    XORIA	0x3
  01CD    1903    SZB	0x3,2
  01CE    2979    JP	0x179
  01CF    3A01    XORIA	0x1
  01D0    1903    SZB	0x3,2
  01D1    2985    JP	0x185
  01D2    3A0F    XORIA	0xF
  01D3    1903    SZB	0x3,2
  01D4    2997    JP	0x197
  01D5    3A01    XORIA	0x1
  01D6    1903    SZB	0x3,2
  01D7    299B    JP	0x19B
  01D8    3A03    XORIA	0x3
  01D9    1903    SZB	0x3,2
  01DA    29A7    JP	0x1A7
  01DB    29B0    JP	0x1B0
  01DC    0008    RET
253:                  }
254:              }
255:              
256:              
---- D:\mywork.wqs\ARROW\ABM007_79F133\ABM007_79F133\source\fct.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE fctBits001;
5:                
6:                // #define FfctTest fctBits001.bits.bit_0
7:                
8:                volatile unsigned char CNTfctStart;
9:                volatile unsigned char CNTfctSensior;
10:               volatile unsigned char CNTfctFlashLed;
11:               volatile unsigned int CNTfct;
12:               
13:               void FCTkey(void);
14:               void FCTjudge(void);
15:               
16:               void FCTloop(void)
17:               {
18:                   FCTkey();
  0279    22CE    CALL	0x2CE
  027A    120A    CLRB	0xA,4
  027B    118A    CLRB	0xA,3
19:                   FCTjudge();
  027C    2A7D    JP	0x27D
20:               }
21:               
22:               void FCTkey(void)
23:               {
24:                   if(PItest == HIGH)
  02CE    1C06    SNZB	0x6,0
  02CF    2AD9    JP	0x2D9
25:                   {
26:                       if(++CNTfctStart >= 50)
  02D0    3032    LDIA	0x32
  02D1    0ABA    INCR	0x3A
  02D2    023A    SUBA	0x3A
  02D3    1C03    SNZB	0x3,0
  02D4    0008    RET
27:                       {
28:                           CNTfctStart = 50;
  02D5    3032    LDIA	0x32
  02D6    00BA    LD	0x3A,A
29:                           FfctTest = SET;
  02D7    1479    SETB	0x79,0
  02D8    0008    RET
30:                       }
31:                   }
32:                   else
33:                   {
34:                       FfctTest = CLR;
  02D9    1079    CLRB	0x79,0
35:                       CNTfctStart = 0;
  02DA    01BA    CLR	0x3A
  02DB    0008    RET
36:                   }
37:               }
38:               
39:               void FCTjudge(void)
40:               {
41:                   if(FfctTest == SET)
  027D    1C79    SNZB	0x79,0
  027E    2ACA    JP	0x2CA
42:                   {
43:                       if(PIsensor == LOW)
  027F    1886    SZB	0x6,1
  0280    2A9E    JP	0x29E
44:                       {
45:                           if(++CNTfctSensior >= 50)
  0281    3032    LDIA	0x32
  0282    0AB9    INCR	0x39
  0283    0239    SUBA	0x39
  0284    1C03    SNZB	0x3,0
  0285    0008    RET
46:                           {
47:                               CNTfct = 0;
  0286    01A0    CLR	0x20
  0287    01A1    CLR	0x21
48:                               CNTfctSensior = 50;
  0288    3032    LDIA	0x32
  0289    00B9    LD	0x39,A
49:                               if(++CNTfctFlashLed >= 50)
  028A    0AB8    INCR	0x38
  028B    0238    SUBA	0x38
  028C    1C03    SNZB	0x3,0
  028D    2A90    JP	0x290
50:                               {
51:                                   CNTfctFlashLed = 0;
  028E    01B8    CLR	0x38
52:                               }
  028F    0008    RET
53:                               else if(CNTfctFlashLed == 25)
  0290    3019    LDIA	0x19
  0291    0638    XORA	0x38
  0292    1D03    SNZB	0x3,2
  0293    2A98    JP	0x298
54:                               {
55:                                   POlight = HIGH;
  0294    1685    SETB	0x5,5
56:                                   POairPump = HIGH;
  0295    1505    SETB	0x5,2
57:                                   POmainValue = HIGH;
  0296    1605    SETB	0x5,4
58:                               }
  0297    0008    RET
59:                               else if(CNTfctFlashLed == 1)
  0298    0B38    SZDECA	0x38
  0299    0008    RET
60:                               {
61:                                   POlight = LOW;
  029A    1285    CLRB	0x5,5
62:                                   POairPump = LOW;
  029B    1105    CLRB	0x5,2
63:                                   POmainValue = LOW;
  029C    1205    CLRB	0x5,4
64:                               }
65:                           }
66:                       }
  029D    0008    RET
67:                       else
68:                       {
69:                           CNTfctSensior = 0;
  029E    01B9    CLR	0x39
70:                           if(++CNTfct >= 100)
  029F    0AA0    INCR	0x20
  02A0    1903    SZB	0x3,2
  02A1    0AA1    INCR	0x21
  02A2    3000    LDIA	0x0
  02A3    0221    SUBA	0x21
  02A4    3064    LDIA	0x64
  02A5    1903    SZB	0x3,2
  02A6    0220    SUBA	0x20
  02A7    1C03    SNZB	0x3,0
  02A8    2AAF    JP	0x2AF
71:                           {
72:                               CNTfct = 0;
  02A9    01A0    CLR	0x20
  02AA    01A1    CLR	0x21
73:                               // FfctTest = CLR;
74:                               POlight = LOW;
  02AB    1285    CLRB	0x5,5
75:                               POairPump = LOW;
  02AC    1105    CLRB	0x5,2
76:                               POmainValue = LOW;
  02AD    1205    CLRB	0x5,4
77:                           }
  02AE    0008    RET
78:                           else if(CNTfct == 75)
  02AF    304B    LDIA	0x4B
  02B0    0620    XORA	0x20
  02B1    0421    ORA	0x21
  02B2    1D03    SNZB	0x3,2
  02B3    2AB8    JP	0x2B8
79:                           {
80:                               POlight = HIGH;
  02B4    1685    SETB	0x5,5
81:                               POairPump = LOW;
  02B5    1105    CLRB	0x5,2
82:                               POmainValue = LOW;
  02B6    1205    CLRB	0x5,4
83:                           }
  02B7    0008    RET
84:                           else if(CNTfct == 50)
  02B8    3032    LDIA	0x32
  02B9    0620    XORA	0x20
  02BA    0421    ORA	0x21
  02BB    1D03    SNZB	0x3,2
  02BC    2AC1    JP	0x2C1
85:                           {
86:                               POlight = LOW;
  02BD    1285    CLRB	0x5,5
87:                               POairPump = HIGH;
  02BE    1505    SETB	0x5,2
88:                               POmainValue = LOW;
  02BF    1205    CLRB	0x5,4
89:                           }
  02C0    0008    RET
90:                           else if(CNTfct == 25)
  02C1    3019    LDIA	0x19
  02C2    0620    XORA	0x20
  02C3    0421    ORA	0x21
  02C4    1D03    SNZB	0x3,2
  02C5    0008    RET
91:                           {
92:                               POlight = LOW;
  02C6    1285    CLRB	0x5,5
93:                               POairPump = LOW;
  02C7    1105    CLRB	0x5,2
94:                               POmainValue = HIGH;
  02C8    1605    SETB	0x5,4
  02C9    0008    RET
95:                           }
96:                       }
97:                   }
98:                   else
99:                   {
100:                      CNTfctSensior = 0;
  02CA    01B9    CLR	0x39
101:                      CNTfct = 0;
  02CB    01A0    CLR	0x20
  02CC    01A1    CLR	0x21
  02CD    0008    RET
102:                  }
103:              }
104:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    3020    LDIA	0x20
  0010    01F6    CLR	0x76
  0011    01F7    CLR	0x77
  0012    01F8    CLR	0x78
  0013    01F9    CLR	0x79
  0014    01FA    CLR	0x7A
  0015    1383    CLRB	0x3,7
  0016    0084    LD	0x4,A
  0017    3046    LDIA	0x46
  0018    120A    CLRB	0xA,4
  0019    118A    CLRB	0xA,3
  001A    2388    CALL	0x388
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    2B0A    JP	0x30A
---- common_function ------------------------------------------------------------------
  001B    0183    CLR	0x3
  001C    120A    CLRB	0xA,4
  001D    118A    CLRB	0xA,3
  001E    2A0A    JP	0x20A
  010C    0828    LD	A,0x28
  010D    072A    ADDA	0x2A
  010E    00A6    LD	0x26,A
  010F    0829    LD	A,0x29
  0110    1803    SZB	0x3,0
  0111    0A29    INCA	0x29
  0112    072B    ADDA	0x2B
  0113    00A7    LD	0x27,A
  0114    0008    RET
  01F8    1778    SETB	0x78,6
  01F9    1105    CLRB	0x5,2
  01FA    1205    CLRB	0x5,4
  01FB    0AF6    INCR	0x76
  01FC    1903    SZB	0x3,2
  01FD    0AF7    INCR	0x77
  01FE    3000    LDIA	0x0
  01FF    0277    SUBA	0x77
  0200    3405    RET	0x5
  0201    1778    SETB	0x78,6
  0202    1105    CLRB	0x5,2
  0203    1605    SETB	0x5,4
  0204    0AF6    INCR	0x76
  0205    1903    SZB	0x3,2
  0206    0AF7    INCR	0x77
  0207    3000    LDIA	0x0
  0208    0277    SUBA	0x77
  0209    340A    RET	0xA
  0388    0064    CLRWDT
  0389    0180    CLR	0x0
  038A    0A84    INCR	0x4
  038B    0604    XORA	0x4
  038C    1903    SZB	0x3,2
  038D    3400    RET	0x0
  038E    0604    XORA	0x4
  038F    2B89    JP	0x389
