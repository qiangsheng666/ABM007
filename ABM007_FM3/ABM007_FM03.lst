---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\main.c ----------------------------------------------------------------------
1:                // #include <cms.h>	//芯片头文件，会根据工程选项自动寻找对应型号头文件
2:                #include "cfg_user.h"
3:                #include "cfg_case.h"
4:                #include "math.h"
5:                #include "string.h"
6:                
7:                volatile unsigned int TMR1 @0x000E;
8:                #define TIMER1_TIME 0xE0C0
9:                
10:               /**********************************************************************/
11:               /*全局变量声明*/
12:               /**********************************************************************/
13:               
14:               /*变量*/
15:               v_uint8 RX_Buf;
16:               v_uint8 templ = 0;
17:               v_uint8 SEQmain = 0;
18:               v_uint8 MainTime_1min = 0;	/* 定时1min计数 */
19:               v_uint16 MainTime_1s = 0;	/* 定时1s计数 */
20:               v_uint16 AD_Result = 0;
21:               
22:               extern  void INT_LED_SHOW(void);
23:               
24:               /***********************************************************************
25:               函数功能：延时子函数，13个指令周期1循环
26:               ***********************************************************************/
27:               void Delay(unsigned int dtemp)
28:               {
29:               	while (dtemp--)
  039B    3001    LDIA	0x1
  039C    02F2    SUBR	0x72
  039D    3000    LDIA	0x0
  039E    1C03    SNZB	0x3,0
  039F    03F3    DECR	0x73
  03A0    02F3    SUBR	0x73
  03A1    0F72    SZINCA	0x72
  03A2    2B9B    JP	0x39B
  03A3    0A73    INCA	0x73
  03A4    1903    SZB	0x3,2
  03A5    0008    RET
  03A6    2B9B    JP	0x39B
30:               		;
31:               }
32:               /***********************************************************************
33:               子函数功能：延时templ  ms，有中断则不准
34:               ***********************************************************************/
35:               void Delay_nms(unsigned int inittempl)
36:               {
37:               	unsigned int i;
38:               	unsigned char gtemp;
39:               	/******************************************************************/
40:               	gtemp = 0;
  037C    01F8    CLR	0x78
41:               	if (GIE == 1)
  037D    1F8B    SNZB	0xB,7
  037E    2B82    JP	0x382
42:               	{
43:               		gtemp = 1;
  037F    01F8    CLR	0x78
  0380    0AF8    INCR	0x78
44:               		GIE = 0;
  0381    138B    CLRB	0xB,7
45:               	}
46:               	for (i = 0; i < inittempl; i++)
  0382    01F6    CLR	0x76
  0383    01F7    CLR	0x77
  0384    0875    LD	A,0x75
  0385    0277    SUBA	0x77
  0386    1D03    SNZB	0x3,2
  0387    2B8A    JP	0x38A
  0388    0874    LD	A,0x74
  0389    0276    SUBA	0x76
  038A    1803    SZB	0x3,0
  038B    2B97    JP	0x397
47:               	{
48:               		Delay(154);
  038C    309A    LDIA	0x9A
  038D    00F2    LD	0x72,A
  038E    01F3    CLR	0x73
  038F    239B    CALL	0x39B
  0390    120A    CLRB	0xA,4
  0391    118A    CLRB	0xA,3
  0392    0064    CLRWDT
  0393    0AF6    INCR	0x76
  0394    1903    SZB	0x3,2
  0395    0AF7    INCR	0x77
  0396    2B84    JP	0x384
49:               		asm("clrwdt");
50:               	}
51:               	if (gtemp == 1)
  0397    0B78    SZDECA	0x78
  0398    0008    RET
52:               		GIE = 1;
  0399    178B    SETB	0xB,7
  039A    0008    RET
53:               }
54:               
55:               /************************************************************
56:               函数名称：Init_GPIO()
57:               函数功能：初始化IO端口
58:               入口参数：
59:               出口参数：
60:               备注：
61:               ************************************************************/
62:               void Init_GPIO(void)
63:               {
64:               
65:               	/*引脚数据*/
66:               	PORTA = 0B01000000;
  0473    3040    LDIA	0x40
  0474    1283    CLRB	0x3,5
  0475    1303    CLRB	0x3,6
  0476    0085    LD	0x5,A
67:               	PORTB = 0B00000001;
  0477    3001    LDIA	0x1
  0478    0086    LD	0x6,A
68:               	PORTC = 0B00000000;
  0479    0187    CLR	0x7
69:               
70:               	/* 全部配置成输入状态，1: 输入，0: 输出 */
71:               	TRISA = 0B01000000; /*RA1直流阀 RA2-气泵	RA4-主阀  RA5-氛围灯 RA6按键1*/
  047A    3040    LDIA	0x40
  047B    1683    SETB	0x3,5
  047C    0085    LD	0x5,A
72:               	TRISB = 0B00000111; /* RB0按键2	RB1-龙头感应，RB0测试点 */
  047D    3007    LDIA	0x7
  047E    0086    LD	0x6,A
73:               	TRISC = 0B00000000;
  047F    0187    CLR	0x7
74:               
75:               	/*内部上拉关闭, 1: 开启, 0: 关闭 */
76:               	WPUA = 0B00000000; /* RA1直流阀		RA2-气泵	RA4-主阀 RA5-氛围灯 */
  0480    1703    SETB	0x3,6
  0481    018E    CLR	0xE
77:               	WPUB = 0B00000010; /* RB1-龙头感应<置1则不插为有人状态，RB1低有效>，RB0-测试点，硬件下拉 */
  0482    3002    LDIA	0x2
  0483    1303    CLRB	0x3,6
  0484    0095    LD	0x15,A
78:               	WPUC = 0B00000000;
  0485    1703    SETB	0x3,6
  0486    018F    CLR	0xF
  0487    0008    RET
79:               
80:               	/* 内部下拉 */
81:               	// WPDB =  0B00000000; /* RB1-龙头感应<1不插为无人状态，RB1高有效> */
82:               
83:               	/*模拟通道选择*/
84:               //	ANSEL0 = 0B00000000; // AN7 - AN0
85:               //	ANSEL1 = 0B00000000; // AN15 - AN8
86:               //	ANSEL2 = 0B00000000; //------AN17 AN16
87:               }
88:               
89:               /************************************************************
90:               函数名称：Init_IC()
91:               函数功能：上电初始化系统寄存器
92:               入口参数：
93:               出口参数：
94:               备注：
95:               ************************************************************/
96:               void Init_IC(void)
  0488    0064    CLRWDT
97:               {
98:               	asm("clrwdt");
99:               
100:              	// 7			6			5			4			3			2			1			0
101:              	// GIE		PEIE		TOIE		INTE		RBIE		TOIF		INTF		RBIF
102:              	// 全局允许	外设允许	T0允许		INT允许		PB允许		T0标志		INT标志		PB标志
103:              	INTCON = 0x00; // 中断控制寄存器
  0489    018B    CLR	0xB
104:              
105:              	// 7			6			5			4			3			2			1			0
106:              	//--		ADIF		RCIF		TXIF		--			CCP1IF		TMR2IF		TMR1IF
107:              	// NC		AD转换完成	UART接收满	UART发送满		NC		CCP1中断	T2与PR2匹配		T1
108:              	PIR1 = 0; // 外设中断请求寄存器
  048A    1283    CLRB	0x3,5
  048B    1303    CLRB	0x3,6
  048C    018C    CLR	0xC
109:              
110:              	// 7			6			5			4			3			2			1			0
111:              	//--		TKIF		RACIF		EEIF		--			--			--			CCP2IF
112:              	// NC		触摸检测结束 PA变化		 EEP写完成	  NC		  NC		  NC		  CCP2中断
113:              	PIR2 = 0; // 外设中断请求寄存器
  048D    018D    CLR	0xD
114:              
115:              	// 7			6			5			4			3			2			1			0
116:              	//--		--			--			--			--			--			--			SWDTEN
117:              	// NC		NC			NC			NC			NC			NC			NC			使能
118:              	WDTCON = 0x01; // 看门狗
  048E    3001    LDIA	0x1
  048F    1703    SETB	0x3,6
  0490    0085    LD	0x5,A
119:              
120:              	// 7				6			5			4			3			2			1		0
121:              	// RBPU			INTEDG			T0CS		T0SE		PSA			PS2			PS1		PS0
122:              	// PB上拉使能	中断边沿选择  	T0时钟源	  T0边沿选择	预分配		预分配参数
123:              	OPTION_REG = 0b00001110; // 开启PORTB上来使能，看门狗复位时间=18*分频系数 (规格书 2.6/2.8.1)
  0491    300E    LDIA	0xE
  0492    1683    SETB	0x3,5
  0493    1303    CLRB	0x3,6
  0494    0081    LD	0x1,A
124:              
125:              	// 7			6			5			4			3			2			1			0
126:              	//--		IRCF2		IRCF1		IRCF0		--			--			--			--
127:              	// NC		内振分频							NC			NC			NC			NC
128:              	OSCCON = 0x71; // 振荡器控制
  0495    3071    LDIA	0x71
  0496    008F    LD	0xF,A
129:              
130:              	// 7			6			5			4			3			2			1				0
131:              	//--		ADIE		RCIE		TXIE		--			CCP1IE		TMR2IE			TMR1IE
132:              	// NC		AD转换允许	UART接收允许 UART发送允许 NC		  CCP1允许	  T2与PR2匹配允许	T1溢出允许
133:              	PIE1 = 0; // 外设中断允许
  0497    018C    CLR	0xC
134:              
135:              	//
136:              	//--	TKIE				RACIE			EEIE			--		--		--		CCP2IE
137:              	// NC	触摸检测结束允许	PA变化允许			EEP写允许		NC		NC		NC		CCP2中断允许
138:              	PIE2 = 0; // 外设中断允许
  0498    018D    CLR	0xD
  0499    0008    RET
139:              }
140:              
141:              /************************************************************
142:              函数名称：Init_TIMER1()
143:              函数功能：定时器1初始化函数
144:              入口参数：
145:              出口参数：
146:              备注：	  定时时间计算方法
147:              		  定时时间T = {1/[(Fosc)*预分频比)]}*(65535-[TMR1H:TMR1L])
148:              		  本程序计算示例：
149:              		  T = {1/[(8)*(1/1)]}*(65536 - 63936)
150:              			= 125 us
151:              ************************************************************/
152:              void Init_TIMER1(void)
153:              {
154:              	// TMR1L = 0xC0; //赋初值
155:              	// TMR1H = 0xF9;
156:              	TMR1 = TIMER1_TIME;
  049A    30E0    LDIA	0xE0
  049B    1283    CLRB	0x3,5
  049C    1303    CLRB	0x3,6
  049D    008F    LD	0xF,A
  049E    30C0    LDIA	0xC0
  049F    008E    LD	0xE,A
157:              	TMR1IF = 0;	  // 清中断标志位
  04A0    100C    CLRB	0xC,0
158:              	TMR1IE = 1;	  // 允许Timer1中断
  04A1    1683    SETB	0x3,5
  04A2    140C    SETB	0xC,0
159:              	T1CON = 0x01; // 开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  04A3    3001    LDIA	0x1
  04A4    1283    CLRB	0x3,5
  04A5    0090    LD	0x10,A
  04A6    0008    RET
160:              }
161:              
162:              /************************************************************
163:              函数名称：Init_TIMER2()
164:              函数功能：定时器2初始化函数
165:              入口参数：
166:              出口参数：
167:              备注：	  定时时间计算方法
168:              		  时钟输入为系统指令时钟（即为Fosc/4）
169:              		  定时时间T = {1/[(Fosc/4)*预分频比*后分频比]}*(PR2+1)
170:              		  本程序计算示例：
171:              		  T = {1/[(8/4)*(1/4)*1]}*50 = 100 us
172:              
173:              ************************************************************/
174:              void Init_TIMER2(void)
175:              {
176:              	PR2 = 24;	// 8M下将TMR2设置为50us中断?
  04A7    3018    LDIA	0x18
  04A8    1683    SETB	0x3,5
  04A9    0092    LD	0x12,A
177:              	TMR2IF = 0; // 清中断标志位
  04AA    1283    CLRB	0x3,5
  04AB    108C    CLRB	0xC,1
178:              	TMR2IE = 1; // 允许Timer2中断
  04AC    1683    SETB	0x3,5
  04AD    148C    SETB	0xC,1
179:              	T2CON = 5;	// 开启Timer2，预分频值为4，后分频比为1:1
  04AE    3005    LDIA	0x5
  04AF    1283    CLRB	0x3,5
  04B0    0092    LD	0x12,A
  04B1    0008    RET
180:              }
181:              
182:              /* 遥控器接收数据时钟，50μs */
183:              // void Init_TIMER2_Remo(void)
184:              //{
185:              //	PR2 = 24;		//16M下将TMR2设置为50μs中断
186:              //	TMR2IF = 0; 	//清中断标志位
187:              //	TMR2IE = 1; 	//允许Timer2中断
188:              //	T2CON = 5;		//开启Timer2，预分频值为4，后分频比为1:1
189:              // }
190:              
191:              /***********************************************
192:              函数名称：Set_CCP_PWM
193:              函数功能：CCP PWM模式初始化
194:              入口参数：无
195:              出口参数：无
196:              备注：
197:              	   周期 = (PWMxCYC+1)*4/Fosc*PWMxCNT预分频值
198:              	  占空比 = (CCPRxL:CCPCON<5:4>)/(4*(PWMxCYC + 1))
199:              	  由于CCPx 引脚与端口数据锁存器复用，必须清零相应的TRIS 位才能使能CCPx 引脚的输出驱动器。
200:              ************************************************/
201:              void Set_CCP_PWM()
202:              {
203:              //	PWMCON = 0B00000001; // PWM1设置为16分频，使能PWM1
204:              
205:              	// // PWM1 周期设置为500us，占空比50%
206:              	// CCP1CON = 0B00001100; // PWM模式,10位占空比数据低2位为0；
207:              	// PWM1CYC = 124;		  // PWM1周期为：(249+1)* （4/8） * 4 =500uS
208:              	// CCPR1L = 62;		  // 低2位为0,(CCPRxL:CCPCON<5:4>)=CCPR1L*4
209:              	// CYC1EN = 1;			  /* PWM1的周期计数器使能位,1使能，0禁止 */
210:              	// PWMTL = 0x8f;					//PWM0~3共周期，周期低位
211:              	PWMT4L = 0x7C;					//PWM4独立周期，周期低位,0x7C,(124+1)* （4/8） * 4 =250μs
212:              	PWMTH = 0B00011101;				//周期高两位及PWM4占空比高两位	
213:              	/* PWMTH: bit5~bit4- PWM4占空比高2位，bit3~bit2-PWM周期高2位，bit1~bit0-PWM0~PWM3周期高2位 */
214:              	
215:              	//PWM0~3周期为：(0B110001111+1)*(1/16)*2 =50uS
216:              	//PWM4周期为：(0B1110001111+1)*(1/16)*2 =114uS
217:              	/* PWM4 0B00001100 */
218:              	
219:              	// PWMD01H = 0x00;					//高位改变后不能立即生效，需要给占空比的低位寄存器后才能加载
220:              	// //PWM0 占空比设置为20%
221:              	// PWMD0L = 0x4f;					//(79+1)/(399+1) = 20%
222:              	// //PWM1 占空比设置为40%
223:              	// PWMD1L = 0x9f;					//(159+1)/(399+1) = 40%
224:              
225:              	// PWMD23H = 0x10;
226:              	// //PWM2 占空比设置为60%
227:              	// PWMD2L = 0xef;					//(239+1)/(399+1) = 60%
228:              	// //PWM3 占空比设置为80%
229:              	// PWMD3L = 0x3f;					//(319+1)/(399+1) = 80%
230:              
231:              	//PWM4 占空比设置为25%
232:              	PWMD4L = 0xC7;					//(227+1)/(911+1) = 25% ()
233:              	/* 50% 0x01C7, (455+1)/(911+1) */
234:              	
235:              	// PWM01DT = 0x3F;					//死区时间，低6位有效位=(0B00111111+1)*(1/16)*1 =4uS
236:              	// PWM23DT = 0;
237:              	
238:              	PWMCON2 = 0B00000000;			//正常输出
239:              	PWMCON1 = 0B00000000;			//PWM01位置选择为RB5/RB4;禁止死区；可使能PWM0/1互补，PWM2/3互补
240:              	PWMCON0 = 0B00110000;			//PWM分频Fosc/2，使能PWM4
241:              }
242:              
243:              /***********************************************
244:              函数名称：Memory_Write
245:              函数功能：写数据
246:              入口参数：Addr - 写入地址
247:              		  Value - 写入数值
248:              出口参数：返回值 0 - 写操作错误 1 - 写完毕
249:              备注：
250:              写程序EE过程中需要暂时关闭中断，以保证写EE时序中的写55H和写AAH能够连续进行，否则将有可能写错，并且写EE的可靠工作电压范围为3V以上。
251:              ************************************************/
252:              unsigned char Memory_Write(unsigned char Addr, unsigned char Value)
253:              {
254:              
255:              	volatile unsigned char i = 0;
256:              	// 将要写入的地址放入EEADDR寄存器
257:              	EEADR = Addr;
258:              	EEDAT = Value; // 将要写入的数据给EEPROM的数据寄存器
259:              	EECON1 = 0;
260:              	EEPGD = 0;		 // 访问数据存储器
261:              	EECON1 | = 0x10; // 烧写时间10ms（0x30）,时间非固定精准,用户可自定义(最长烧写等待时间2.5ms, 0x10)
262:              	asm("clrwdt");
263:              
264:              	WREN = 1; // 允许写周期
265:              	GIE = 0;  // 关闭中断
266:              	GIE = 0;
267:              	GIE = 0;
268:              	while (GIE)
269:              	{
270:              		GIE = 0; // 确保中断已关闭
271:              		if (0 == --i)
272:              		{
273:              			// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
274:              			GIE = 1; // 总中断GIE置1
275:              			return 0;
276:              		}
277:              	}
278:              	asm("clrwdt");
279:              
280:              	EECON2 = 0x55; // 给EECON2写入0x55
281:              	EECON2 = 0xaa; // 给EECON2写入0xaa
282:              	WR = 1;		   // 启动写周期
283:              	asm("nop");
284:              	asm("nop");
285:              	asm("clrwdt");
286:              	WREN = 0; // 禁止写入
287:              	// 注：程序使用了中断需执行GIE = 1，否则需屏蔽此条语句
288:              	GIE = 1; // 总中断GIE置1
289:              
290:              	if (WRERR)
291:              		return 0; // 写操作错误
292:              	else
293:              		return 1; // 写完毕
294:              }
295:              
296:              void Flash_Write(unsigned char Addr, unsigned char Value)
297:              {
298:              	uint8_t bufAddress;
299:              	uint8_t bufValue;
300:              	bufAddress = Addr;
301:              	bufValue = Value;
302:              	templ = 10; //错误计数，用户可自定义
303:              	do
304:              	{
305:              		asm("clrwdt");
306:              		asm("clrwdt");
307:              	} while ((0 == Memory_Write(bufAddress, bufValue)) && (templ--)); //调用写函数：地址0x00处写入数据0x5a
308:              }
309:              
310:              /***********************************************
311:              函数名称：Memory_Read
312:              函数功能：读数据
313:              入口参数：Addr - 读取地址
314:              出口参数：返回读取地址相应数值
315:              备注：
316:              ************************************************/
317:              unsigned char Memory_Read(unsigned char Addr)
318:              {
319:              
320:              	EEADR = Addr;
321:              	EEPGD = 0; // 访问数据存储器
322:              
323:              	RD = 1; // 允许读操作
324:              	asm("nop");
325:              	asm("nop");
326:              
327:              	return (EEDAT);
328:              }
329:              
330:              /************************************************************
331:              函数名称：AD_Testing()
332:              函数功能：AD采样函数
333:              入口参数：ad_fd - 分频 00Fosc/8; 01Fosc/16; 10Fosc/32; 11Frc;
334:              		  ad_ch - AD通道选择1~15，15通道为内部基准1.2V固定输入值
335:              		  ad_lr - 左/右对齐，输入0或1，0为左对齐，1为右对齐
336:              
337:              出口参数：AdResult - AD结果
338:              备    注：BUFmotor_ad = AD_Testing(0, 10, 0); //8分频，AN10通道，右对齐	规格书11.2.4，8M主频最快8分频
339:              ************************************************************/
340:              unsigned int AD_Testing(unsigned char ad_fd, unsigned char ad_ch, unsigned char ad_lr)
341:              {
342:              	// static volatile unsigned char adtimes;
343:              	// static volatile unsigned int admin, admax, adsum;
344:              	volatile unsigned int data;
345:              	volatile unsigned char i = 0;
346:              
347:              	if (!ad_lr)
348:              		ADCON1 = 0; // 左对齐,出12位
349:              	else
350:              		ADCON1 = 0x80; // 右对齐,出10位
351:              
352:              	if (ad_ch & 0x10) // 设置CHS4，此位在ADCON1寄存器中
353:              		ADCON1 |= 0x40;
354:              
355:              	ADCON0 = 0;
356:              	ad_ch &= 0x0f;
357:              	ADCON0 |= (unsigned char)(ad_fd << 6); // 不同的VDD或参考电压需要配置合理的分频
358:              	ADCON0 |= (unsigned char)(ad_ch << 2); // 设置通道
359:              	ADCON0 |= 0x01;						   // 使能ADC
360:              
361:              	asm("nop");
362:              	asm("nop");
363:              	GODONE = 1; // 开始转换
364:              
365:              	while (GODONE)
366:              	{
367:              		asm("nop");
368:              		asm("nop");
369:              		if ((--i) == 0) // ad等待限时，防止出现死循环，但要考虑转换时间不能长于此时间
370:              			return 0;
371:              	}
372:              
373:              	if (!ad_lr) // 左对齐
374:              	{
375:              		data = (unsigned int)(ADRESH << 4);
376:              		data |= (unsigned int)(ADRESL >> 4);
377:              	}
378:              	else // 右对齐
379:              	{
380:              		data = (unsigned int)(ADRESH << 8);
381:              		data |= (unsigned int)ADRESL;
382:              	}
383:              
384:              	return data;
385:              }
386:              
387:              /***********************************************
388:              函数名称：Set_Usart_Async
389:              函数功能：Usart状态设置（异步）
390:              入口参数：无
391:              出口参数：无
392:              备注：
393:              1、串口通讯，设置波特率寄存器时，应控制在19200及以下，实际应用时应考虑到芯片内振的电压及温度特性。
394:              2、SYNC = 0;目标波特率 = Fosc/(16*(SPBRG+1))
395:              ************************************************/
396:              void Set_Usart_Async()
397:              {
398:              	BRGHEN1 = 1;
399:              	BRG16EN1 = 0; //设置BRG是一个8位定时器
400:              
401:              	SPBRGH1 = 0;
402:              	SPBRG1 = 51; //设置波特率为9600 bps (8M/(16*52))
403:              
404:              //	SPBRG = 25; /* 19200bps, 8M/(16*26) */
405:              
406:              	SYNC1 = 0; // 0为异步模式，1为同步模式
407:              	SCKP1 = 0; // 直接将数据字符发送到TX/CK引脚
408:              
409:              	SPEN1 = 1;  // 允许串口操作
410:              	RC1IE = 1;  // 接收中断  //暂时关闭
411:              	TX1IE = 0;  // 发送中断
412:              	RX9EN1 = 0; // 0为8位接收，1为9位接收
413:              	TX9EN1 = 0; // 0为8位发送，1为9位发送
414:              	CREN1 = 1;  // 0为禁止接收，1为使能接收 //暂时关闭
415:              	TXEN1 = 1;  // 0为禁止发送，1为使能发送
416:              }
417:              
418:              /************************************************************
419:              函数名称：Uart_Send_NByte()
420:              函数功能：串口多字节发送函数
421:              入口参数：n 待发送字节数量
422:              		  nSendByte 待发送数组
423:              出口参数：
424:              备    注：
425:              ************************************************************/
426:              // void Uart_Send_NByte(uint8_t n, uint8_t *nSendByte)
427:              // {
428:              // 	uint8_t i;
429:              // 	for(i = 0; i < n; i++)
430:              // 	{
431:              // 		TX_Buf[i] = nSendByte[i];
432:              // 	}
433:              // 	tx_index = n;
434:              // 	TXIE = 1;
435:              // }
436:              
437:              /************************************************************
438:              函数名称：Init_PA_Isr()
439:              函数功能：PA中断初始化函数
440:              入口参数：
441:              出口参数：
442:              备    注：
443:              ************************************************************/
444:              // void Init_PA_Isr()
445:              // {
446:              // 	IOCA = 0B01100110; // 允许RA1的IO口电平变化中断
447:              // 	RACIE = 1;		   // 使能PORTA电平变化中断
448:              // 	PORTA;			   // 读取PORTA并锁存
449:              // }
450:              
451:              /************************************************************
452:              函数名称：Init_PB_Isr()
453:              函数功能：PB中断初始化函数
454:              入口参数：
455:              出口参数：
456:              备    注：
457:              ************************************************************/
458:              // void Init_PB_Isr()
459:              // {
460:              // 	IOCB = 0B00000001; // 允许RB0的IO口电平变化中断
461:              // 	RBIE = 1;		   // 使能PORTB电平变化中断
462:              // 	// INTCON = 0x88;			//允许所有未被屏蔽的中断、禁止外设中断，使能PORTB电平变化中断
463:              // 	PORTB;			   // 读取PORTB并锁存
464:              // }
465:              
466:              /************************************************************
467:              函数名称：mainr()
468:              函数功能：主循环
469:              入口参数：
470:              出口参数：
471:              备    注：
472:              ************************************************************/
473:              void main(void)
  03A7    0000    NOP
  03A8    0064    CLRWDT
474:              {
475:              	/******************************************************************/
476:              	asm("nop");
477:              	asm("clrwdt");
478:              	INTCON = 0;		 //禁止中断
  03A9    018B    CLR	0xB
479:              
480:              	Init_GPIO();	// 初始化GPIO
  03AA    120A    CLRB	0xA,4
  03AB    118A    CLRB	0xA,3
  03AC    2473    CALL	0x473
481:              	Init_IC();		// 相关寄存器初始化
  03AF    120A    CLRB	0xA,4
  03B0    118A    CLRB	0xA,3
  03B1    2488    CALL	0x488
482:              	Delay_nms(200); // 上电延时200ms 非精准延时
  03B4    30C8    LDIA	0xC8
  03B5    00F4    LD	0x74,A
  03B6    01F5    CLR	0x75
  03B7    120A    CLRB	0xA,4
  03B8    118A    CLRB	0xA,3
  03B9    237C    CALL	0x37C
483:              	Init_TIMER1();	// 定时器1初始化
  03BC    120A    CLRB	0xA,4
  03BD    118A    CLRB	0xA,3
  03BE    249A    CALL	0x49A
484:              	Init_TIMER2();	// 定时器2初始化
  03C1    120A    CLRB	0xA,4
  03C2    118A    CLRB	0xA,3
  03C3    24A7    CALL	0x4A7
485:              //	Init_PA_Isr();		 //PA中断初始化函数
486:              //	Init_PB_Isr();		 //PB中断初始化函数
487:              // #if FCT
488:              // 	/* FCT串口不初始化，TX、RX作为普通端口使用 */
489:              // #else
490:              // 	Set_Usart_Async(); // 串口初始化
491:              // #endif
492:              
493:              	//	Set_CCP_PWM();		 //PWM初始化
494:              
495:              	INTCON = 0XC0;	   // 允许所有未被屏蔽的中断、外设中断
  03C6    30C0    LDIA	0xC0
  03C7    008B    LD	0xB,A
496:              
497:              	// RemoFlash_Read();  /* 读取存储的数值 */
498:              	while (1)
499:              	{
500:              		/*主循环10ms*/
501:              		if (F1ms == SET)
  03C8    1CD0    SNZB	0x50,1
  03C9    2BC8    JP	0x3C8
  03CA    0064    CLRWDT
502:              		{
503:              			CLRWDT(); /*清看门狗*/
504:              			// ScanIO();
505:              			F1ms = CLR;
  03CB    1283    CLRB	0x3,5
  03CC    1303    CLRB	0x3,6
  03CD    10D0    CLRB	0x50,1
506:              			switch (SEQmain)
  03CE    2BED    JP	0x3ED
507:              			{
508:              				case 0:
509:              					FCTloop();
  03CF    120A    CLRB	0xA,4
  03D0    118A    CLRB	0xA,3
  03D1    2326    CALL	0x326
510:              					break;
  03D4    2C0D    JP	0x40D
511:              				case 1:
512:              					if(FfctTest == CLR)
  03D5    1851    SZB	0x51,0
  03D6    2C0D    JP	0x40D
513:              					{
514:              						GsensorLoop();
  03D7    120A    CLRB	0xA,4
  03D8    118A    CLRB	0xA,3
  03D9    2230    CALL	0x230
  03DC    2C0D    JP	0x40D
515:              					}
516:              					break;
517:              				case 2:
518:              						// GkeyLoop();
519:              					break;
520:              				case 3:
521:              
522:              					break;
523:              				case 4:
524:              					if(FfctTest == CLR)
  03DD    1851    SZB	0x51,0
  03DE    2C0D    JP	0x40D
525:              					{
526:              						GflushLoop();
  03DF    120A    CLRB	0xA,4
  03E0    118A    CLRB	0xA,3
  03E1    201C    CALL	0x1C
  03E4    2C0D    JP	0x40D
527:              					}
528:              					break;
529:              				case 5:
530:              
531:              					break;
532:              				case 6:
533:              
534:              					break;
535:              				case 7:
536:              
537:              					break;
538:              				case 8:
539:              					if(FfctTest == CLR)
  03E5    1851    SZB	0x51,0
  03E6    2C0D    JP	0x40D
540:              					{
541:              						GledLoop();
  03E7    120A    CLRB	0xA,4
  03E8    118A    CLRB	0xA,3
  03E9    2453    CALL	0x453
  03EC    2C0D    JP	0x40D
  03ED    084A    LD	A,0x4A
  03EE    3A00    XORIA	0x0
  03EF    1903    SZB	0x3,2
  03F0    2BCF    JP	0x3CF
  03F1    3A01    XORIA	0x1
  03F2    1903    SZB	0x3,2
  03F3    2BD5    JP	0x3D5
  03F4    3A03    XORIA	0x3
  03F5    1903    SZB	0x3,2
  03F6    2C0D    JP	0x40D
  03F7    3A01    XORIA	0x1
  03F8    1903    SZB	0x3,2
  03F9    2C0D    JP	0x40D
  03FA    3A07    XORIA	0x7
  03FB    1903    SZB	0x3,2
  03FC    2BDD    JP	0x3DD
  03FD    3A01    XORIA	0x1
  03FE    1903    SZB	0x3,2
  03FF    2C0D    JP	0x40D
  0400    3A03    XORIA	0x3
  0401    1903    SZB	0x3,2
  0402    2C0D    JP	0x40D
  0403    3A01    XORIA	0x1
  0404    1903    SZB	0x3,2
  0405    2C0D    JP	0x40D
  0406    3A0F    XORIA	0xF
  0407    1903    SZB	0x3,2
  0408    2BE5    JP	0x3E5
  0409    3A01    XORIA	0x1
  040A    1903    SZB	0x3,2
  040B    2C0D    JP	0x40D
  040C    2C0D    JP	0x40D
542:              					}
543:              				break;
544:              				case 9:
545:              
546:              					break;
547:              				default:
548:              					// SEQmain = 0;
549:              					break;
550:              			}
551:              			if (++SEQmain >= 10)
  040D    300A    LDIA	0xA
  040E    1283    CLRB	0x3,5
  040F    1303    CLRB	0x3,6
  0410    0ACA    INCR	0x4A
  0411    024A    SUBA	0x4A
  0412    1C03    SNZB	0x3,0
  0413    2BC8    JP	0x3C8
552:              			{
553:              				SEQmain = 0;
  0414    01CA    CLR	0x4A
  0415    2BC8    JP	0x3C8
554:              			}
555:              		}
556:              	}
557:              }
558:              
559:              // /***********************************************************************
560:              // 函数功能：中断入口函数
561:              // RISC内核无中断优先级，不可嵌套
562:              // ***********************************************************************/
563:              void interrupt Int_ALL(void)
564:              {
565:              	// 1ms定时器中断服务函数
566:              	if (TMR1IF)
  0416    1283    CLRB	0x3,5
  0417    1303    CLRB	0x3,6
  0418    1C0C    SNZB	0xC,0
  0419    2C2E    JP	0x42E
567:              	{
568:              		// ---------------------------------------
569:              		// TMR1L += 0xC0;
570:              		// TMR1H += 0xF9; //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
571:              		// 在进入中断等过程中其实Time是一直在计数的
572:              		// ---------------------------------------
573:              		TMR1 = TIMER1_TIME;
  041A    30E0    LDIA	0xE0
  041B    008F    LD	0xF,A
  041C    30C0    LDIA	0xC0
  041D    008E    LD	0xE,A
574:              		TMR1IF = 0; // 清中断标志位
  041E    100C    CLRB	0xC,0
575:              
576:              		/* 主循环1ms标志位 */
577:              		F1ms = 1;
  041F    14D0    SETB	0x50,1
578:              
579:              		/* 1s标志位 */
580:              		if (++MainTime_1s >= 1000)
  0420    0AB8    INCR	0x38
  0421    1903    SZB	0x3,2
  0422    0AB9    INCR	0x39
  0423    3003    LDIA	0x3
  0424    0239    SUBA	0x39
  0425    30E8    LDIA	0xE8
  0426    1903    SZB	0x3,2
  0427    0238    SUBA	0x38
  0428    1C03    SNZB	0x3,0
  0429    2C2E    JP	0x42E
581:              		{
582:              			MainTime_1s = 0;
  042A    01B8    CLR	0x38
  042B    01B9    CLR	0x39
583:              			Fsys1s.byte = 0xFF; /* 1s' flag */
  042C    30FF    LDIA	0xFF
  042D    00CF    LD	0x4F,A
584:              // #if (VER_2510M || VER_2510U)
585:              // 			if (++MainTime_1min >= 60) /* 1min标识位 */
586:              // 			{
587:              // 				MainTime_1min = 0;
588:              // 				Fsys1m.byte = 0xFF; /* 1min' flag */
589:              // 			}
590:              // #endif
591:              		}
592:              	}
593:              
594:              	// 50us定时器中断服务函数
595:              	if (TMR2IF)
  042E    1C8C    SNZB	0xC,1
  042F    2C32    JP	0x432
596:              	{
597:              		TMR2IF = 0; /*	8位，自重载，无需二次配置	*/
  0430    108C    CLRB	0xC,1
598:              		INT_LED_SHOW(); /* 氛围灯中断函数 */
  0431    2439    CALL	0x439
  0432    0871    LD	A,0x71
  0433    008A    LD	0xA,A
  0434    0E70    SWAPA	0x70
  0435    0083    LD	0x3,A
  0436    0EFE    SWAPR	0x7E
  0437    0E7E    SWAPA	0x7E
  0438    0009    RETI
599:              	}
600:              
601:              // #if FCT
602:              // 	/* FCT停止uart通讯中断服务 */
603:              // #else
604:              // 	// 串口接收中断服务函数
605:              // 	if (RC1IF)
606:              // 	{
607:              // 		//-------------------------------------------
608:              // 		// 接收控制，如果接收标志位为1，说明有数据接收完毕
609:              // 		// RCIF在寄存器被读出后自动清零
610:              // 		if (FERR1)
611:              // 		{
612:              // 			RCREG1; // 帧错误
613:              // 			return;
614:              // 		}
615:              
616:              // 		RX_Buf = RCREG1; // 将接收缓冲区内容读出
617:              
618:              // 		Uart_ReceiveLogic(); /* UART*/
619:              
620:              // 		if (OERR1) // 如果有溢出错误
621:              // 		{
622:              // 			CREN1 = 0; // 清零CREN1位可将OERR位清零
623:              // 			CREN1 = 1; // 再次将CREN1置一，以允许继续接收
624:              // 		}
625:              // 	}
626:              
627:              // 	// 串口发送中断服务函数
628:              // 	if (TX1IF && TX1IE)
629:              // 	{
630:              // 		// 发送控制
631:              // 		if (TRMT1)
632:              // 		{
633:              // 			Uart_SendLogic();
634:              // 			// TXREG = TX_Buf[tx_cnt];
635:              // 			// tx_cnt++;
636:              // 			// if(tx_cnt >= tx_index)
637:              // 			// {
638:              // 			// 	tx_cnt = 0;
639:              // 			// 	TXIE = 0;
640:              // 			// }
641:              // 		}
642:              // 	}
643:              // #endif
644:              	// PA中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
645:              	// if(RACIF)
646:              	// {
647:              	// 	PORTA;		 //读取PORTA状态
648:              	// 	RACIF = 0; //清中断标志
649:              	// }
650:              
651:              	// PB中断服务函数，IO口电平变化就会进入中断，上升或下降沿类型需要自行进行应用判断
652:              	// if(RBIF)
653:              	// {
654:              	// 	PORTB;		//读取PORTB状态
655:              	// 	RBIF = 0; //清中断标志
656:              	// }
657:              }
---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\sensor.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fbodysensor;
5:                
6:                v_uint8 u8stsBodySensor = 0;
7:                v_uint8 SEQbody = 0;
8:                v_uint16 CNTbody_h = 0;         /* 感应高电平计时 */
9:                v_uint16 CNTbody_l = 0;         /* 感应低电平计时 */
10:               v_uint16 BufCntAdd = 0;         /* 感应计时 */
11:               v_uint16 CNTbodyInTime = 0;     /* 感应到人计时 */
12:               v_uint16 CNTbodyExitTime = 0;   /* 感应到人离开计时 */
13:               
14:               void SensorKey(void);
15:               void SensorTime(void);
16:               void SensorJudge(void);
17:               void SensorControl(void);
18:               
19:               void GsensorLoop(void)
20:               {
21:                   SensorKey();
  0230    223A    CALL	0x23A
  0231    120A    CLRB	0xA,4
  0232    118A    CLRB	0xA,3
22:                   SensorTime();
  0233    223B    CALL	0x23B
  0234    120A    CLRB	0xA,4
  0235    118A    CLRB	0xA,3
23:                   SensorJudge();
  0236    228E    CALL	0x28E
  0237    120A    CLRB	0xA,4
  0238    118A    CLRB	0xA,3
24:                   SensorControl();
  0239    2A73    JP	0x273
25:               }
26:               
27:               void SensorKey(void)
  023A    0008    RET
28:               {
29:               
30:               }
31:               
32:               /* 人体感应计时函数 */
33:               void SensorTime(void)
34:               {
35:                   if(Fbody == SET)
  023B    1C7A    SNZB	0x7A,0
  023C    2A5F    JP	0x25F
36:                   {
37:                       FbodyEx5s = CLR;
  023D    12FA    CLRB	0x7A,5
38:                       CNTbodyExitTime = 0;
  023E    01AA    CLR	0x2A
  023F    01AB    CLR	0x2B
39:                       if(FlightLeave == CLR)  /* 检测到人有效时间 */
  0240    194D    SZB	0x4D,2
  0241    2A5A    JP	0x25A
40:                       {
41:                           if(++CNTbodyInTime >= BODY_ENTER_KEEP_60S)	/* 60s */
  0242    0AAC    INCR	0x2C
  0243    1903    SZB	0x3,2
  0244    0AAD    INCR	0x2D
  0245    3017    LDIA	0x17
  0246    022D    SUBA	0x2D
  0247    3070    LDIA	0x70
  0248    1903    SZB	0x3,2
  0249    022C    SUBA	0x2C
  024A    1C03    SNZB	0x3,0
  024B    2A52    JP	0x252
42:                           {
43:                               CNTbodyInTime = BODY_ENTER_KEEP_60S;
  024C    3070    LDIA	0x70
  024D    00AC    LD	0x2C,A
  024E    3017    LDIA	0x17
  024F    00AD    LD	0x2D,A
44:                               FbodyIn60s = SET;
  0250    15FA    SETB	0x7A,3
45:                           }
  0251    0008    RET
46:                           else if(CNTbodyInTime >= BODY_ENTER_KEEP_5S)		/* 5s */
  0252    3001    LDIA	0x1
  0253    022D    SUBA	0x2D
  0254    30F4    LDIA	0xF4
  0255    1903    SZB	0x3,2
  0256    022C    SUBA	0x2C
  0257    1803    SZB	0x3,0
47:                           {
48:                               FbodyIn5s = SET;
  0258    167A    SETB	0x7A,4
  0259    0008    RET
49:                           }
50:                       }
51:                       else
52:                       {
53:                           if(FbodyIn5s == CLR)    /* 未待满5s，时间清零 */
  025A    1A7A    SZB	0x7A,4
  025B    0008    RET
54:                           {
55:                               CNTbodyInTime = 0;
  025C    01AC    CLR	0x2C
  025D    01AD    CLR	0x2D
56:                           }
57:                       }
58:                   }
  025E    0008    RET
59:                   else
60:                   {
61:                       CNTbodyInTime = 0;
  025F    01AC    CLR	0x2C
  0260    01AD    CLR	0x2D
62:                       FbodyIn5s = CLR;
  0261    127A    CLRB	0x7A,4
63:                       FbodyIn60s = CLR;
  0262    11FA    CLRB	0x7A,3
64:                       if(++CNTbodyExitTime >= BODY_EXIT_KEEP_5S)
  0263    0AAA    INCR	0x2A
  0264    1903    SZB	0x3,2
  0265    0AAB    INCR	0x2B
  0266    3001    LDIA	0x1
  0267    022B    SUBA	0x2B
  0268    30F4    LDIA	0xF4
  0269    1903    SZB	0x3,2
  026A    022A    SUBA	0x2A
  026B    1C03    SNZB	0x3,0
  026C    0008    RET
65:                       {
66:                           CNTbodyExitTime = BODY_EXIT_KEEP_5S;
  026D    30F4    LDIA	0xF4
  026E    00AA    LD	0x2A,A
  026F    3001    LDIA	0x1
  0270    00AB    LD	0x2B,A
67:                           FbodyEx5s = SET;        /* 人离开5秒 */
  0271    16FA    SETB	0x7A,5
  0272    0008    RET
68:                       }
69:                   }
70:               }
71:               
72:               /* 人体感应判定函数 */
73:               void SensorJudge(void)
74:               {
75:                   switch (SEQbody)
  028E    2B0B    JP	0x30B
76:                   {
77:                       case 0:
78:                           Fbody = CLR;
  028F    107A    CLRB	0x7A,0
79:                           FlightLeave = CLR;
  0290    114D    CLRB	0x4D,2
80:                           SEQbody = 1;
  02A0    3001    LDIA	0x1
  02A1    00C5    LD	0x45,A
81:                           break;
  02A2    0008    RET
82:               
83:                       /* 人离开确认 */
84:                       case 1:
85:                           Fbody = CLR;
  02A3    107A    CLRB	0x7A,0
86:                           FlightLeave = CLR;
  02A4    114D    CLRB	0x4D,2
87:                           if(PIsensor == LOW)
  02A5    1886    SZB	0x6,1
  02A6    2AB8    JP	0x2B8
88:                           {
89:                               if(++CNTbody_h >= SENSOR_TRG)
  02A7    0AB2    INCR	0x32
  02A8    1903    SZB	0x3,2
  02A9    0AB3    INCR	0x33
  02AA    3000    LDIA	0x0
  02AB    0233    SUBA	0x33
  02AC    3003    LDIA	0x3
  02AD    1903    SZB	0x3,2
  02AE    0232    SUBA	0x32
  02AF    1C03    SNZB	0x3,0
  02B0    0008    RET
90:                               {
91:                                   CNTbody_h = 0;
  02B1    01B2    CLR	0x32
  02B2    01B3    CLR	0x33
92:               					CNTbody_l = 0;
  02B3    01B0    CLR	0x30
  02B4    01B1    CLR	0x31
93:               					SEQbody = 2;
  02B5    3002    LDIA	0x2
  02B6    00C5    LD	0x45,A
94:               					break;
  02B7    0008    RET
95:                               }
96:                           }
97:                           else
98:                           {
99:                               CNTbody_h = 0;
  02B8    01B2    CLR	0x32
  02B9    01B3    CLR	0x33
  02BA    0008    RET
100:                          }
101:                          break;
102:              
103:                      /* 感应到人判定开始 */
104:                      case 2:
105:                          Fbody = CLR;
  02BB    107A    CLRB	0x7A,0
106:                          FlightLeave = CLR;
  02BC    114D    CLRB	0x4D,2
107:                          if(PIsensor == LOW)
  02BD    1886    SZB	0x6,1
  02BE    2A92    JP	0x292
108:                          {
109:                              ++CNTbody_h;
  02BF    0AB2    INCR	0x32
  02C0    1903    SZB	0x3,2
  02C1    0AB3    INCR	0x33
110:                          }
  0291    2AA0    JP	0x2A0
111:                          else
112:                          {
113:                              if(++CNTbody_l >= SENSOR_ERROR)
  0292    0AB0    INCR	0x30
  0293    1903    SZB	0x3,2
  0294    0AB1    INCR	0x31
  0295    3000    LDIA	0x0
  0296    0231    SUBA	0x31
  0297    3006    LDIA	0x6
  0298    1903    SZB	0x3,2
  0299    0230    SUBA	0x30
  029A    1C03    SNZB	0x3,0
  029B    2AC2    JP	0x2C2
114:                              {
115:                                  CNTbody_h = 0;
  029C    01B2    CLR	0x32
  029D    01B3    CLR	0x33
116:                                  CNTbody_l = 0;
  029E    01B0    CLR	0x30
  029F    01B1    CLR	0x31
117:                                  SEQbody = 1;
118:                                  break;
119:                              }
120:                          }
121:                          BufCntAdd = CNTbody_h +CNTbody_l;
  02C2    231D    CALL	0x31D
  02C3    120A    CLRB	0xA,4
  02C4    118A    CLRB	0xA,3
122:                          if(BufCntAdd >= SENSOR_BODY_ENTER_X_0S)
  02C5    3000    LDIA	0x0
  02C6    022F    SUBA	0x2F
  02C7    301E    LDIA	0x1E
  02C8    1903    SZB	0x3,2
  02C9    022E    SUBA	0x2E
  02CA    1C03    SNZB	0x3,0
  02CB    0008    RET
123:                          {
124:                              SEQbody = 3;
  02CC    3003    LDIA	0x3
  02CD    00C5    LD	0x45,A
125:                              break;
  02CE    0008    RET
126:                          }
127:                          break;
128:                      /* 感应到人确认 */
129:                      case 3:
130:                          Fbody = SET;
  02CF    147A    SETB	0x7A,0
131:                          FlightLeave = CLR;
  02D0    114D    CLRB	0x4D,2
132:                          if(PIsensor == HIGH)
  02D1    1C86    SNZB	0x6,1
  02D2    2AE4    JP	0x2E4
133:                          {
134:                              if(++CNTbody_l >= SENSOR_TRG)
  02D3    0AB0    INCR	0x30
  02D4    1903    SZB	0x3,2
  02D5    0AB1    INCR	0x31
  02D6    3000    LDIA	0x0
  02D7    0231    SUBA	0x31
  02D8    3003    LDIA	0x3
  02D9    1903    SZB	0x3,2
  02DA    0230    SUBA	0x30
  02DB    1C03    SNZB	0x3,0
  02DC    0008    RET
135:                              {
136:                                  CNTbody_h = 0;
  02DD    01B2    CLR	0x32
  02DE    01B3    CLR	0x33
137:                                  CNTbody_l = 0;
  02DF    01B0    CLR	0x30
  02E0    01B1    CLR	0x31
138:                                  SEQbody = 4;
  02E1    3004    LDIA	0x4
  02E2    00C5    LD	0x45,A
139:                                  break;
  02E3    0008    RET
140:                              }
141:                          }
142:                          else
143:                          {
144:                              CNTbody_l = 0;
  02E4    01B0    CLR	0x30
  02E5    01B1    CLR	0x31
  02E6    0008    RET
145:                          }
146:                          break;
147:                      /* 人离开判定开始 */
148:                      case 4:
149:                          Fbody = SET;
  02E7    147A    SETB	0x7A,0
150:                          FlightLeave = SET;
  02E8    154D    SETB	0x4D,2
151:                          if(PIsensor == LOW)
  02E9    1886    SZB	0x6,1
  02EA    2AFA    JP	0x2FA
152:                          {
153:                              if(++CNTbody_h >= SENSOR_ERROR)
  02EB    0AB2    INCR	0x32
  02EC    1903    SZB	0x3,2
  02ED    0AB3    INCR	0x33
  02EE    3000    LDIA	0x0
  02EF    0233    SUBA	0x33
  02F0    3006    LDIA	0x6
  02F1    1903    SZB	0x3,2
  02F2    0232    SUBA	0x32
  02F3    1C03    SNZB	0x3,0
  02F4    2AFD    JP	0x2FD
154:                              {
155:                                  CNTbody_h = 0;
  02F5    01B2    CLR	0x32
  02F6    01B3    CLR	0x33
156:                                  CNTbody_l = 0;
  02F7    01B0    CLR	0x30
  02F8    01B1    CLR	0x31
  02F9    2ACC    JP	0x2CC
157:                                  SEQbody = 3;
158:                                  break;
159:                              }
160:                          }
161:                          else
162:                          {
163:                              ++CNTbody_l;
  02FA    0AB0    INCR	0x30
  02FB    1903    SZB	0x3,2
  02FC    0AB1    INCR	0x31
164:                          }
165:                          BufCntAdd = CNTbody_h +CNTbody_l;
  02FD    231D    CALL	0x31D
  02FE    120A    CLRB	0xA,4
  02FF    118A    CLRB	0xA,3
166:                          if(BufCntAdd >= SENSOR_BODY_EXIT_X_0S)      /* 暂改为5s */
  0300    3001    LDIA	0x1
  0301    022F    SUBA	0x2F
  0302    30F4    LDIA	0xF4
  0303    1903    SZB	0x3,2
  0304    022E    SUBA	0x2E
  0305    1C03    SNZB	0x3,0
  0306    0008    RET
  0307    2AA0    JP	0x2A0
167:                          {
168:                              SEQbody = 1;
169:                              break;
170:                          }
171:                          break;
172:                      default:
173:                          SEQbody = 0;
  0308    01C5    CLR	0x45
174:                          FlightLeave = CLR;
  0309    114D    CLRB	0x4D,2
175:                          break;
  030A    0008    RET
  030B    0845    LD	A,0x45
  030C    3A00    XORIA	0x0
  030D    1903    SZB	0x3,2
  030E    2A8F    JP	0x28F
  030F    3A01    XORIA	0x1
  0310    1903    SZB	0x3,2
  0311    2AA3    JP	0x2A3
  0312    3A03    XORIA	0x3
  0313    1903    SZB	0x3,2
  0314    2ABB    JP	0x2BB
  0315    3A01    XORIA	0x1
  0316    1903    SZB	0x3,2
  0317    2ACF    JP	0x2CF
  0318    3A07    XORIA	0x7
  0319    1903    SZB	0x3,2
  031A    2AE7    JP	0x2E7
  031B    2B08    JP	0x308
  031C    0008    RET
176:                  }
177:              }
178:              
179:              void SensorControl(void)
180:              {
181:                  FbodyEnter = CLR;
  0273    10FA    CLRB	0x7A,1
182:                  FbodyExit = CLR;
  0274    117A    CLRB	0x7A,2
183:                  if(Fbufbody != Fbody)
  0275    1C7A    SNZB	0x7A,0
  0276    2A79    JP	0x279
  0277    3001    LDIA	0x1
  0278    2A7A    JP	0x27A
  0279    3000    LDIA	0x0
  027A    00F2    LD	0x72,A
  027B    1F7A    SNZB	0x7A,6
  027C    2A7F    JP	0x27F
  027D    3001    LDIA	0x1
  027E    2A80    JP	0x280
  027F    3000    LDIA	0x0
  0280    0672    XORA	0x72
  0281    1903    SZB	0x3,2
  0282    0008    RET
184:                  {
185:                      if(Fbody == SET)
  0283    1C7A    SNZB	0x7A,0
  0284    2A87    JP	0x287
186:                      {
187:                          FbodyEnter = SET;   /* 感应到人瞬间 */
  0285    14FA    SETB	0x7A,1
188:                      }
  0286    2A88    JP	0x288
189:                      else
190:                      {
191:                          FbodyExit = SET;    /* 人离开瞬间 */
  0287    157A    SETB	0x7A,2
192:                      }
193:                      Fbufbody = Fbody;
  0288    1C7A    SNZB	0x7A,0
  0289    2A8C    JP	0x28C
  028A    177A    SETB	0x7A,6
  028B    0008    RET
  028C    137A    CLRB	0x7A,6
  028D    0008    RET
194:                  }
195:              }
196:              
197:              
198:              // void ScanIO(void){
199:              // 	for (SeletedLine = 0; SeletedLine < 2; SeletedLine++)
200:              // 	{
201:              // 		judgeIO();
202:              // 	}
203:              
204:              // }
205:              // uint8_t ScanSignal(uint8_t i)
206:              // {
207:              // 	current_IO_Trgging[(unsigned char)i] = CurrentIO ^ last_IO_value[(unsigned char)i];
208:              
209:              // 	if(current_IO_Trgging[(unsigned char)i])
210:              // 	{
211:              // 		if(last_IO_value[(unsigned char)i])
212:              // 		{
213:              // 			last_IO_value[(unsigned char)i] = CLR;
214:              // 			return TRUE;
215:              // 		}
216:              // 		else
217:              // 		{
218:              // 			last_IO_value[(unsigned char)i] = SET;
219:              // 			IrIrqCnt_H[(unsigned char)i] = CLR;
220:              // 		}
221:              // 	}else if(last_IO_value[(unsigned char)i])	{
222:              // 		if(IrIrqCnt_H[(unsigned char)i] < UINT16_MAX){
223:              // 			IrIrqCnt_H[(unsigned char)i]++;
224:              // 		}
225:              // 	}
226:              // 	else {
227:              // 		if(IrIrqCnt_L[(unsigned char)i] < UINT16_MAX){
228:              // 			IrIrqCnt_L[(unsigned char)i]++;
229:              // 		}
230:              // 	} 
231:              // 	return FALSE;
232:              // }
233:              
234:              // void judgeIO(void)
235:              // {
236:              //     switch (SeletedLine)
237:              // 	{
238:              // 	case PortA:
239:              // 		CurrentIO = PIKey1;
240:              // 		break;
241:              // 	case PortB:
242:              // 		CurrentIO = PIKey2;
243:              // 		break;
244:              // 	default:
245:              // 		break;
246:              // 	}
247:              
248:              //     if(ScanSignal(SeletedLine))
249:              //     {
250:              //         key_flag = SET;
251:              //         switch (SeletedLine)
252:              //         {
253:              //         case PortA:
254:              //         POairPump = SET;
255:              //         POmainValue = SET;
256:              //         POdirectValue = CLR;
257:              //             break;
258:              //         case PortB:
259:              //         POdirectValue= SET;
260:              //         POairPump =SET;
261:              //         POmainValue = CLR;
262:              //             break;
263:              //         default:
264:              //         POdirectValue= CLR;
265:              //         POairPump =CLR;
266:              //         POmainValue = CLR;
267:              //             break;
268:              //         }
269:                       
270:              
271:              //     }
272:              //     else
273:              //     {
274:              //         if(key_flag)
275:              //         {
276:              //              switch (SeletedLine)
277:              //             {
278:              //             case PortA:
279:              //             POairPump = CLR;
280:              //             POmainValue = CLR;
281:              //             POdirectValue = CLR;
282:              //                 break;
283:              //             case PortB:
284:              //             POdirectValue= CLR;
285:              //             POairPump =CLR;
286:              //             POmainValue = CLR;
287:              //                 break;
288:              //             default:
289:              //             POdirectValue= CLR;
290:              //             POairPump =CLR;
291:              //             POmainValue = CLR;
292:              //                 break;
293:              //             }
294:              //             key_flag = CLR;
295:              //         }
296:              //     }
297:                 
298:               
299:              
300:              
301:              // }
302:              
303:              
---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\light.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE FledBits01;
5:                
6:                v_uint16 CNTbreath_Led;
7:                v_uint16 CNTbreath_Led1;
8:                v_uint16 CNTbreath_Led2;
9:                v_uint16 CNTbreath_Led3;
10:               
11:               void LED_Key(void);
12:               void LED_Judge(void);
13:               void LED_Con(void);
14:               void LED_Time(void);
15:               
16:               void GledLoop(void)
17:               {
18:               	LED_Time();
  0453    245E    CALL	0x45E
  0454    120A    CLRB	0xA,4
  0455    118A    CLRB	0xA,3
19:               	LED_Key();
  0456    245D    CALL	0x45D
  0457    120A    CLRB	0xA,4
  0458    118A    CLRB	0xA,3
20:               	LED_Judge();
  0459    246B    CALL	0x46B
  045A    120A    CLRB	0xA,4
  045B    118A    CLRB	0xA,3
21:               	LED_Con();
  045C    2C61    JP	0x461
22:               }
23:               
24:               void LED_Key(void)
  045D    0008    RET
25:               {
26:               	// switch(SiCon_SETkey)
27:               	// {	
28:               	// 	case KEY_LIGHT:
29:               	// 		Flight = ~Flight;
30:               	// 		if(Flight == SET)
31:               	// 		{
32:               	// 			GbuzOutSet(2);
33:               	// 		}
34:               	// 		else
35:               	// 		{
36:               	// 			GbuzOutSet(1);
37:               	// 		}
38:               	// 		break;
39:               	// 	default:
40:               			
41:               	// 		break;
42:               	// }
43:               }
44:               
45:               void LED_Time(void)
46:               {
47:               	if(F1min_lgt == SET)
  045E    184E    SZB	0x4E,0
48:               	{
49:               		F1min_lgt = CLR;
  045F    104E    CLRB	0x4E,0
  0460    0008    RET
50:               	}
51:               }
52:               
53:               void LED_Judge(void)
54:               {
55:               	if(Fbody == SET)	/* 感应到人开启 */
  046B    1C7A    SNZB	0x7A,0
  046C    2C71    JP	0x471
56:               	{
57:               		Flight = SET;
  046D    144D    SETB	0x4D,0
58:               		if(FbodyIn5s == CLR)	/* 检测到人5秒之内 */
  046E    1E7A    SNZB	0x7A,4
59:               		{
60:               			if(FlightLeave == SET)	/* 离开状态，熄灭指示灯 */
  046F    1D4D    SNZB	0x4D,2
  0470    0008    RET
61:               			{
62:               				Flight = CLR;
  0471    104D    CLRB	0x4D,0
  0472    0008    RET
63:               			}
64:               		}
65:               	}
66:               	else
67:               	{
68:               		// if(Fbuflight == SET)
69:               		// {
70:               		// 	Flight = SET;	/* 离开5s内 */
71:               		// 	if(FbodyEx5s == SET)
72:               		// 	{
73:               		// 		Flight = CLR;
74:               		// 		Fbuflight = CLR;
75:               		// 	}
76:               		// }
77:               		// else
78:               		// {
79:               			Flight = CLR;
80:               		// }
81:               	}
82:               }
83:               
84:               void LED_Con(void)
85:               {
86:               	POlight	= Flight;
  0461    1C4D    SNZB	0x4D,0
  0462    2C67    JP	0x467
  0463    1283    CLRB	0x3,5
  0464    1303    CLRB	0x3,6
  0465    1685    SETB	0x5,5
  0466    0008    RET
  0467    1283    CLRB	0x3,5
  0468    1303    CLRB	0x3,6
  0469    1285    CLRB	0x5,5
  046A    0008    RET
87:               	/* 呼吸灯频率 */
88:               	// if (Flight == SET)
89:               	// {
90:               	// 	if (FbreathDir == CLR)
91:               	// 	{
92:               	// 		if (CNTbreath_Led2 >= 80)	/* 亮度降低 */
93:               	// 		{
94:               	// 			CNTbreath_Led2 = 80;
95:               	// 			if (++CNTbreath_Led3 > 10)	/* 100ms，min */
96:               	// 			{
97:               	// 				FbreathDir = SET;
98:               	// 				CNTbreath_Led3 = 0;
99:               	// 			}
100:              	// 		}
101:              	// 		else if (CNTbreath_Led2 > 45)	/* 35*4*10=1050ms */
102:              	// 		{
103:              	// 			if (++CNTbreath_Led1 >= 3)
104:              	// 			{
105:              	// 				CNTbreath_Led1 = 0;
106:              	// 				CNTbreath_Led2++;
107:              	// 			}
108:              	// 		}
109:              	// 		else if (CNTbreath_Led2 > 30)	/* 15*8*10 = 1200ms */
110:              	// 		{
111:              	// 			if (++CNTbreath_Led1 >= 8)
112:              	// 			{
113:              	// 				CNTbreath_Led1 = 0;
114:              	// 				CNTbreath_Led2++;
115:              	// 			}
116:              	// 		}
117:              	// 		else if (CNTbreath_Led2 > 10)	/* 1000ms */
118:              	// 		{
119:              	// 			if (++CNTbreath_Led1 >= 5)
120:              	// 			{
121:              	// 				CNTbreath_Led1 = 0;
122:              	// 				CNTbreath_Led2++;
123:              	// 			}
124:              	// 		}
125:              	// 		else
126:              	// 		{
127:              	// 			if (++CNTbreath_Led1 >= 11)	/* (11-5)*10=600ms，max */
128:              	// 			{
129:              	// 				CNTbreath_Led1 = 0;
130:              	// 				CNTbreath_Led2++;
131:              	// 			}
132:              	// 		}
133:              	// 	}
134:              	// 	else
135:              	// 	{
136:              	// 		if (CNTbreath_Led2 < 5)	/* max */
137:              	// 		{
138:              	// 			CNTbreath_Led2 = 5;
139:              	// 			FbreathDir = CLR;
140:              	// 		}
141:              	// 		else if (CNTbreath_Led2 < 10)
142:              	// 		{
143:              	// 			if (++CNTbreath_Led1 >= 6)	/* 600ms */
144:              	// 			{
145:              	// 				CNTbreath_Led1 = 0;
146:              	// 				CNTbreath_Led2--;
147:              	// 			}
148:              	// 		}
149:              	// 		else if (CNTbreath_Led2 < 30)
150:              	// 		{
151:              	// 			if (++CNTbreath_Led1 >= 6)	/* 1200ms */
152:              	// 			{
153:              	// 				CNTbreath_Led1 = 0;
154:              	// 				CNTbreath_Led2--;
155:              	// 			}
156:              	// 		}
157:              	// 		else if (CNTbreath_Led2 < 40)
158:              	// 		{
159:              	// 			if (++CNTbreath_Led1 >= 8)	/* 800ms */
160:              	// 			{
161:              	// 				CNTbreath_Led1 = 0;
162:              	// 				CNTbreath_Led2--;
163:              	// 			}
164:              	// 		}
165:              	// 		else if (CNTbreath_Led2 < 60)
166:              	// 		{
167:              	// 			if (++CNTbreath_Led1 >= 4)	/* 800ms */
168:              	// 			{
169:              	// 				CNTbreath_Led1 = 0;
170:              	// 				CNTbreath_Led2--;
171:              	// 			}
172:              	// 		}
173:              	// 		else
174:              	// 		{
175:              	// 			if (++CNTbreath_Led1 >= 3)	/* 600ms，min */
176:              	// 			{
177:              	// 				CNTbreath_Led1 = 0;
178:              	// 				CNTbreath_Led2--;
179:              	// 			}
180:              	// 		}
181:              	// 	}
182:              	// }
183:              	// else
184:              	// {
185:              	// 	CNTbreath_Led1 = 0;
186:              	// 	CNTbreath_Led2 = 0;
187:              	// 	CNTbreath_Led3 = 0;
188:              	// 	FbreathDir = CLR;
189:              	// 	POlight = OFF;
190:              	// }
191:              }
192:              
193:              void INT_LED_SHOW(void)
194:              {
195:              	// if((Flight == SET) && (FfctTest == CLR))
196:              	if((Flight == SET) && (FfctTest == CLR))
  0439    184D    SZB	0x4D,0
  043A    1851    SZB	0x51,0
  043B    0008    RET
197:              	{
198:              		if (++CNTbreath_Led == 80)
  043C    0AC0    INCR	0x40
  043D    1903    SZB	0x3,2
  043E    0AC1    INCR	0x41
  043F    3050    LDIA	0x50
  0440    0640    XORA	0x40
  0441    0441    ORA	0x41
  0442    1D03    SNZB	0x3,2
  0443    2C47    JP	0x447
199:              		{
200:              			CNTbreath_Led = 0;
  0444    01C0    CLR	0x40
  0445    01C1    CLR	0x41
201:              			POlight = OFF;
  0446    1285    CLRB	0x5,5
202:              		}
203:              		if (CNTbreath_Led >= CNTbreath_Led2)
  0447    083D    LD	A,0x3D
  0448    0241    SUBA	0x41
  0449    1D03    SNZB	0x3,2
  044A    2C4D    JP	0x44D
  044B    083C    LD	A,0x3C
  044C    0240    SUBA	0x40
  044D    1C03    SNZB	0x3,0
  044E    2C51    JP	0x451
204:              		{
205:              			POlight = ON;
  044F    1685    SETB	0x5,5
206:              		}
  0450    0008    RET
207:              		else
208:              		{
209:              			POlight = OFF;
  0451    1285    CLRB	0x5,5
  0452    0008    RET
210:              		}
211:              	}
212:              }
---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\flush.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE Fflush1;
5:                
6:                
7:                
8:                v_uint8 SEQflsuh = 0;
9:                v_uint16 CNTflush = 0;  /* 冲水计时 */
10:               
11:               void FlushTime(void);
12:               void FlushJudge(void);
13:               void FlushCon(void);
14:               
15:               void GflushLoop(void)
16:               {
17:                   FlushTime();
  001C    2023    CALL	0x23
  001D    120A    CLRB	0xA,4
  001E    118A    CLRB	0xA,3
18:                   FlushJudge();
  001F    20EC    CALL	0xEC
  0020    120A    CLRB	0xA,4
  0021    118A    CLRB	0xA,3
19:                   FlushCon();
  0022    2824    JP	0x24
20:               }
21:               
22:               void FlushTime(void)
  0023    0008    RET
23:               {
24:               
25:               }
26:               void FlushJudge(void)
27:               {
28:                   uint8_t Key_Step = 0;
29:                   /* 请求判定 */
30:                   #if DUBLE_FLUSH_MODE
31:                   if(FbodyIn60s == SET)   /* 感应到60秒以上，大冲请求置位 */
  00EC    1DFA    SNZB	0x7A,3
  00ED    28F1    JP	0xF1
32:                   {
33:                       YKfls_Big = SET;
  00EE    1448    SETB	0x48,0
34:                       YKfls_Sml = CLR;
  00EF    1148    CLRB	0x48,2
35:                   }
  00F0    2907    JP	0x107
36:                   else if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
  00F1    1E7A    SNZB	0x7A,4
  00F2    28F5    JP	0xF5
37:                   {
38:                       YKfls_Sml = SET;
  00F3    1548    SETB	0x48,2
  00F4    28F9    JP	0xF9
39:                       YKfls_Big = CLR;
40:                   }
41:                   else if (SEQflsuh)
  00F5    0847    LD	A,0x47
  00F6    1903    SZB	0x3,2
  00F7    28FB    JP	0xFB
42:                   {
43:                       YKfls_Sml = CLR;
  00F8    1148    CLRB	0x48,2
44:                       YKfls_Big = CLR;
  00F9    1048    CLRB	0x48,0
45:                   }
  00FA    2907    JP	0x107
46:                   else
47:                   {
48:                       Key_Step = GkeyLoop();
  00FB    211B    CALL	0x11B
  00FC    120A    CLRB	0xA,4
  00FD    118A    CLRB	0xA,3
  00FE    00F6    LD	0x76,A
49:                       if (Key_Step)
  00FF    0876    LD	A,0x76
  0100    1903    SZB	0x3,2
  0101    28F8    JP	0xF8
50:                       {
51:                           SEQflsuh = Key_Step;
  0102    0876    LD	A,0x76
  0103    00C7    LD	0x47,A
52:                           CNTflush = 0;
  0104    01B4    CLR	0x34
  0105    01B5    CLR	0x35
53:                           Flush_AutoLeaveWait = SET;
  0106    17C8    SETB	0x48,7
54:                       }else
55:                       {
56:                          YKfls_Sml = CLR;
57:                           YKfls_Big = CLR;
58:                       }
59:                   }
60:               #else
61:                   if(FbodyIn5s == SET)   /* 感应到人5秒以上，小冲请求置位 */
62:                   {
63:                       // YKfls_Sml = SET;
64:                       // YKfls_Big = CLR;
65:                       YKfls_Sml = CLR;
66:                       YKfls_Big = SET;
67:                   }
68:                   else
69:                   {
70:                       YKfls_Sml = CLR;
71:                       YKfls_Big = CLR;
72:                   }
73:               #endif
74:                   /*********************************************/
75:               	/*	自动冲水判断	*/
76:               	if (FbodyExit == SET)	/* 离开冲水 */
  0107    197A    SZB	0x7A,2
77:               	{
78:                       Flush_AutoLeaveWait = SET;
  0108    17C8    SETB	0x48,7
79:               	}
80:               	if (Flush_AutoLeaveWait == SET) /*	离开自动冲水	*/
  0109    1FC8    SNZB	0x48,7
  010A    0008    RET
81:               	{
82:               		if (f_STSflush == SET)
  010B    1F48    SNZB	0x48,6
  010C    2910    JP	0x110
83:               		{
84:                           YKfls_Sml = CLR;
  010D    1148    CLRB	0x48,2
85:                           YKfls_Big = CLR;    /* 正在冲水，请求清除 */
  010E    1048    CLRB	0x48,0
86:               			return;
  010F    0008    RET
87:               		}
88:               		Flush_AutoLeaveWait = CLR;
  0110    13C8    CLRB	0x48,7
89:                       if(YKfls_Big == SET)
  0111    1C48    SNZB	0x48,0
  0112    2916    JP	0x116
90:                       {
91:                           YKfls_Big = CLR;
  0113    1048    CLRB	0x48,0
92:                           OKfls_Big = SET;
  0114    14C8    SETB	0x48,1
93:                           return;
  0115    0008    RET
94:                       }
95:               		if(YKfls_Sml == SET)
  0116    1D48    SNZB	0x48,2
  0117    0008    RET
96:                       {
97:                           YKfls_Sml = CLR;
  0118    1148    CLRB	0x48,2
98:                           OKfls_Sml = SET;
  0119    15C8    SETB	0x48,3
  011A    0008    RET
99:                       }
100:              		return;
101:              	}
102:              	/*	自动冲水判断	*/
103:              	/******************************************/
104:              }
105:              
106:              /* 主阀气泵控制函数 */
107:              void FlushCon(void)
108:              {
109:                  switch (SEQflsuh)
  0024    28C8    JP	0xC8
110:                  {
111:                      case FLUSH_INIT_0:
112:                          f_STSflush = CLR;
  0025    1348    CLRB	0x48,6
113:                          POairPump = OFF;
  0026    1105    CLRB	0x5,2
114:                          POmainValue = OFF;
  0027    1205    CLRB	0x5,4
115:                          POdirectValue = OFF;
  0028    1085    CLRB	0x5,1
116:                          if((OKfls_Big == SET) || (OKfls_Sml == SET))
  0029    18C8    SZB	0x48,1
  002A    282D    JP	0x2D
  002B    1DC8    SNZB	0x48,3
  002C    0008    RET
117:                          {
118:                              SEQflsuh = FLUSH_INIT_1;
  002D    3001    LDIA	0x1
  002E    2830    JP	0x30
119:                              CNTflush = 0;
  0031    01B4    CLR	0x34
  0032    01B5    CLR	0x35
  0033    0008    RET
120:                          }
121:                          break;
122:                      case FLUSH_INIT_1:
123:                          f_STSflush = SET;
  0034    1748    SETB	0x48,6
124:                          POairPump = OFF;
  0035    1105    CLRB	0x5,2
125:                          POmainValue = OFF;
  0036    1205    CLRB	0x5,4
126:                          POdirectValue = OFF;
  0037    1085    CLRB	0x5,1
127:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  0038    187A    SZB	0x7A,0
  0039    282F    JP	0x2F
128:                          {
129:                              SEQflsuh = FLUSH_END_0;
  002F    3009    LDIA	0x9
  0030    00C7    LD	0x47,A
130:                              CNTflush = 0;
131:                              break;
132:                          }
133:                          if(++CNTflush >= 5)
  003A    0AB4    INCR	0x34
  003B    1903    SZB	0x3,2
  003C    0AB5    INCR	0x35
  003D    3000    LDIA	0x0
  003E    0235    SUBA	0x35
  003F    3005    LDIA	0x5
  0040    1903    SZB	0x3,2
  0041    0234    SUBA	0x34
  0042    1C03    SNZB	0x3,0
  0043    0008    RET
134:                          {
135:                              CNTflush = 0;
  0044    01B4    CLR	0x34
  0045    01B5    CLR	0x35
136:                              SEQflsuh = FLUSH_INIT_2;
  0046    3002    LDIA	0x2
  0047    00C7    LD	0x47,A
  0048    0008    RET
137:                          }
138:                          break;
139:                      case FLUSH_INIT_2:
140:                          f_STSflush = SET;
  0049    1748    SETB	0x48,6
141:                          POairPump = OFF;        /* 冲水关闭 */
  004A    1105    CLRB	0x5,2
142:                          POmainValue = OFF;      /* 冲水通道1  默认冲水通道,先假设无默认尝试*/ 
  004B    1205    CLRB	0x5,4
143:                          POdirectValue = OFF;
  004C    1085    CLRB	0x5,1
144:                          if(Fbody == SET)        /* 检测到有人，流程跳到结束阶段 */
  004D    187A    SZB	0x7A,0
  004E    282F    JP	0x2F
145:                          {
146:                              SEQflsuh = FLUSH_END_0;
147:                              CNTflush = 0;
148:                              break;
149:                          }
150:              
151:                          if(OKfls_Big == SET)
  004F    1CC8    SNZB	0x48,1
  0050    2854    JP	0x54
152:                          {
153:                              SEQflsuh = FLUSH_BIG_0;
  0051    3003    LDIA	0x3
  0052    00C7    LD	0x47,A
154:                          }
  0053    0008    RET
155:                          else if(OKfls_Sml == SET)
  0054    1DC8    SNZB	0x48,3
  0055    0008    RET
156:                          {
157:                              SEQflsuh = FLUSH_SML_0;
  0056    3006    LDIA	0x6
  0057    00C7    LD	0x47,A
  0058    0008    RET
158:                          }
159:                          break;
160:                      case FLUSH_BIG_0:   /* 大冲阶段 */
161:                          f_STSflush = SET;
162:                          POairPump = OFF;        /* 大冲先开电磁阀换大冲，后开气泵冲水 */
163:                          POmainValue = ON;            /* 大冲*/
164:                          POdirectValue = ON;
165:                          if(++CNTflush >= 10)    /* 延迟100ms后打开气泵冲水 */
  0059    221F    CALL	0x21F
  005A    120A    CLRB	0xA,4
  005B    118A    CLRB	0xA,3
  005C    1903    SZB	0x3,2
  005D    0234    SUBA	0x34
  005E    1C03    SNZB	0x3,0
  005F    0008    RET
166:                          {
167:                              CNTflush = 0;
  0060    01B4    CLR	0x34
  0061    01B5    CLR	0x35
168:                              SEQflsuh = FLUSH_BIG_1;
  0062    3004    LDIA	0x4
  0063    00C7    LD	0x47,A
  0064    0008    RET
169:                          }
170:                          break;
171:                      case FLUSH_BIG_1:
172:                          f_STSflush = SET;
  0065    1748    SETB	0x48,6
173:                          POairPump = ON;
  0066    1505    SETB	0x5,2
174:                          POmainValue = ON;
  0067    1605    SETB	0x5,4
175:                          POdirectValue = ON;
  0068    1485    SETB	0x5,1
176:              #if ABM007_FLUSH_2
177:                          if(++CNTflush >= 100)   /* 冲水1s */
  0069    0AB4    INCR	0x34
  006A    1903    SZB	0x3,2
  006B    0AB5    INCR	0x35
  006C    3000    LDIA	0x0
  006D    0235    SUBA	0x35
  006E    3064    LDIA	0x64
  006F    1903    SZB	0x3,2
  0070    0234    SUBA	0x34
  0071    1C03    SNZB	0x3,0
  0072    0008    RET
178:                          {
179:                              CNTflush = 0;
  0073    01B4    CLR	0x34
  0074    01B5    CLR	0x35
180:                              SEQflsuh = FLUSH_BIG_2;
  0075    3005    LDIA	0x5
  0076    00C7    LD	0x47,A
  0077    0008    RET
181:                          }
182:              #else
183:                          //if(++CNTflush >= 200)   /* 冲水2s */
184:                          if(++CNTflush >= 100)   /* 冲水1s */
185:                          {
186:                              CNTflush = 0;
187:                              SEQflsuh = FLUSH_BIG_2;
188:                          }
189:              #endif
190:                          break;
191:                      case FLUSH_BIG_2:
192:                          f_STSflush = SET;
193:                          POairPump = OFF;        /* 关气泵，停止冲水 */
194:                          POmainValue = SET;      /* 大冲先关气泵停止冲水，后关主阀 */    /* 冲水通道2 */
195:                          POdirectValue = SET;
196:                          if(++CNTflush >= 10)
  0078    221F    CALL	0x21F
  0079    120A    CLRB	0xA,4
  007A    118A    CLRB	0xA,3
  007B    1903    SZB	0x3,2
  007C    0234    SUBA	0x34
  007D    1C03    SNZB	0x3,0
  007E    0008    RET
197:                          {
198:                              CNTflush = 0;
  007F    01B4    CLR	0x34
  0080    01B5    CLR	0x35
199:                              SEQflsuh = FLUSH_END_0;
  0081    3009    LDIA	0x9
  0082    00C7    LD	0x47,A
  0083    0008    RET
200:                          }
201:                          break;
202:              
203:                      case FLUSH_SML_0:           /* 小冲阶段 */
204:                          f_STSflush = SET;
205:                          POairPump = OFF;        /* 小冲先开主阀阀换小冲，后开气泵冲水 */
206:                          POmainValue = ON;      /* 冲水通道1 */
207:                          POdirectValue = OFF;
208:                          if(++CNTflush >= 5)
  0084    2215    CALL	0x215
  0085    120A    CLRB	0xA,4
  0086    118A    CLRB	0xA,3
  0087    1903    SZB	0x3,2
  0088    0234    SUBA	0x34
  0089    1C03    SNZB	0x3,0
  008A    0008    RET
209:                          {
210:                              CNTflush = 0;
  008B    01B4    CLR	0x34
  008C    01B5    CLR	0x35
211:                              SEQflsuh = FLUSH_SML_1;
  008D    3007    LDIA	0x7
  008E    00C7    LD	0x47,A
  008F    0008    RET
212:                          }
213:                          break;
214:                      case FLUSH_SML_1:
215:                          f_STSflush = SET;
  0090    1748    SETB	0x48,6
216:                          POairPump = ON;         /* 冲水 */
  0091    1505    SETB	0x5,2
217:                          POmainValue = ON;      /* 冲水通道1 */
  0092    1605    SETB	0x5,4
218:                          POdirectValue = OFF;
219:                          // if(++CNTflush >= 200)
220:                          if(++CNTflush >= 100)
  0093    2229    CALL	0x229
  0094    120A    CLRB	0xA,4
  0095    118A    CLRB	0xA,3
  0096    3064    LDIA	0x64
  0097    1903    SZB	0x3,2
  0098    0234    SUBA	0x34
  0099    1C03    SNZB	0x3,0
  009A    0008    RET
221:                          {
222:                              CNTflush = 0;
  009B    01B4    CLR	0x34
  009C    01B5    CLR	0x35
223:                              SEQflsuh = FLUSH_SML_2;
  009D    3008    LDIA	0x8
  009E    00C7    LD	0x47,A
  009F    0008    RET
224:                          }
225:                          break;
226:                      case FLUSH_SML_2:
227:                          f_STSflush = SET;
228:                          POairPump = OFF;        /* 关气泵，停止冲水 */
229:                          POmainValue = ON;      /* 冲水通道1 */
230:                          POdirectValue = OFF;
231:                          if(++CNTflush >= 5)
  00A0    2215    CALL	0x215
  00A1    120A    CLRB	0xA,4
  00A2    118A    CLRB	0xA,3
  00A3    287B    JP	0x7B
232:                          {
233:                              CNTflush = 0;
234:                              SEQflsuh = FLUSH_END_0;
235:                          }
236:                          break;
237:              
238:                      case FLUSH_END_0:
239:                          f_STSflush = SET;
  00A4    1748    SETB	0x48,6
240:                          POairPump = OFF;        /* 停止冲水 */
  00A5    1105    CLRB	0x5,2
241:                          POmainValue = OFF;      /* 返回通道1 */
  00A6    1205    CLRB	0x5,4
242:                          POdirectValue = OFF;
243:                          if(++CNTflush >= 5)
  00A7    2229    CALL	0x229
  00A8    120A    CLRB	0xA,4
  00A9    118A    CLRB	0xA,3
  00AA    3005    LDIA	0x5
  00AB    1903    SZB	0x3,2
  00AC    0234    SUBA	0x34
  00AD    1C03    SNZB	0x3,0
  00AE    0008    RET
244:                          {
245:                              CNTflush = 0;
  00AF    01B4    CLR	0x34
  00B0    01B5    CLR	0x35
246:                              SEQflsuh = FLUSH_END_1;
  00B1    300A    LDIA	0xA
  00B2    00C7    LD	0x47,A
  00B3    0008    RET
247:                          }
248:                          break;
249:                      case FLUSH_END_1:
250:                          f_STSflush = CLR;
  00B4    1348    CLRB	0x48,6
251:                          POairPump = OFF;
  00B5    1105    CLRB	0x5,2
252:                          POmainValue = OFF;
  00B6    1205    CLRB	0x5,4
253:                          POdirectValue = OFF;
  00B7    1085    CLRB	0x5,1
254:                          SEQflsuh = FLUSH_INIT_0;
  00B8    01C7    CLR	0x47
255:                          CNTflush = 0;
  00B9    01B4    CLR	0x34
  00BA    01B5    CLR	0x35
256:                          OKfls_Big = CLR;
  00BB    10C8    CLRB	0x48,1
257:                          OKfls_Sml = CLR;
  00BC    11C8    CLRB	0x48,3
258:                          break;
  00BD    0008    RET
259:                      default:
260:                          f_STSflush = CLR;
  00BE    1348    CLRB	0x48,6
261:                          POairPump = OFF;
  00BF    1105    CLRB	0x5,2
262:                          POmainValue = OFF;
  00C0    1205    CLRB	0x5,4
263:                          POdirectValue = OFF;
  00C1    1085    CLRB	0x5,1
264:                          OKfls_Big = CLR;
  00C2    10C8    CLRB	0x48,1
265:                          OKfls_Sml = CLR;
  00C3    11C8    CLRB	0x48,3
266:                          SEQflsuh = FLUSH_INIT_0;
  00C4    01C7    CLR	0x47
267:                          CNTflush = 0;
  00C5    01B4    CLR	0x34
  00C6    01B5    CLR	0x35
268:                          break;
  00C7    0008    RET
  00C8    0847    LD	A,0x47
  00C9    3A00    XORIA	0x0
  00CA    1903    SZB	0x3,2
  00CB    2825    JP	0x25
  00CC    3A01    XORIA	0x1
  00CD    1903    SZB	0x3,2
  00CE    2834    JP	0x34
  00CF    3A03    XORIA	0x3
  00D0    1903    SZB	0x3,2
  00D1    2849    JP	0x49
  00D2    3A01    XORIA	0x1
  00D3    1903    SZB	0x3,2
  00D4    2859    JP	0x59
  00D5    3A07    XORIA	0x7
  00D6    1903    SZB	0x3,2
  00D7    2865    JP	0x65
  00D8    3A01    XORIA	0x1
  00D9    1903    SZB	0x3,2
  00DA    2878    JP	0x78
  00DB    3A03    XORIA	0x3
  00DC    1903    SZB	0x3,2
  00DD    2884    JP	0x84
  00DE    3A01    XORIA	0x1
  00DF    1903    SZB	0x3,2
  00E0    2890    JP	0x90
  00E1    3A0F    XORIA	0xF
  00E2    1903    SZB	0x3,2
  00E3    28A0    JP	0xA0
  00E4    3A01    XORIA	0x1
  00E5    1903    SZB	0x3,2
  00E6    28A4    JP	0xA4
  00E7    3A03    XORIA	0x3
  00E8    1903    SZB	0x3,2
  00E9    28B4    JP	0xB4
  00EA    28BE    JP	0xBE
  00EB    0008    RET
269:                  }
270:              }
271:              
272:              
---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\key.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                #include "key_Private.h"
4:                
5:                
6:                
7:                uint8_t GkeyLoop(void)
8:                {
9:                	for ( SeletedLine = 0; SeletedLine < 2; SeletedLine++)
  011B    01F9    CLR	0x79
  011C    3002    LDIA	0x2
  011D    0279    SUBA	0x79
  011E    1803    SZB	0x3,0
  011F    3400    RET	0x0
10:               	{
11:               		KeyLines[SeletedLine].flags.level =ScanKey(SeletedLine);
  0120    0879    LD	A,0x79
  0121    2202    CALL	0x202
  0122    120A    CLRB	0xA,4
  0123    118A    CLRB	0xA,3
  0124    00F4    LD	0x74,A
  0125    0879    LD	A,0x79
  0126    00F5    LD	0x75,A
  0127    3001    LDIA	0x1
  0128    1003    CLRB	0x3,0
  0129    0DF5    RLCR	0x75
  012A    3EFF    ADDIA	0xFF
  012B    1003    CLRB	0x3,0
  012C    1D03    SNZB	0x3,2
  012D    2929    JP	0x129
  012E    0D75    RLCA	0x75
  012F    3E52    ADDIA	0x52
  0130    0084    LD	0x4,A
  0131    0DF4    RLCR	0x74
  0132    0DF4    RLCR	0x74
  0133    1383    CLRB	0x3,7
  0134    0800    LD	A,0x0
  0135    0674    XORA	0x74
  0136    39FB    ANDIA	0xFB
  0137    0674    XORA	0x74
  0138    0080    LD	0x0,A
12:               
13:               		if(KeyLines[SeletedLine].flags.is_forbidden)
  0139    0879    LD	A,0x79
  013A    00F4    LD	0x74,A
  013B    3001    LDIA	0x1
  013C    1003    CLRB	0x3,0
  013D    0DF4    RLCR	0x74
  013E    3EFF    ADDIA	0xFF
  013F    1003    CLRB	0x3,0
  0140    1D03    SNZB	0x3,2
  0141    293D    JP	0x13D
  0142    0D74    RLCA	0x74
  0143    3E52    ADDIA	0x52
  0144    0084    LD	0x4,A
  0145    1C00    SNZB	0x0,0
  0146    2963    JP	0x163
14:               		{
15:               			if (KeyLines[SeletedLine].flags.level)
  0147    0879    LD	A,0x79
  0148    00F4    LD	0x74,A
  0149    3001    LDIA	0x1
  014A    1003    CLRB	0x3,0
  014B    0DF4    RLCR	0x74
  014C    3EFF    ADDIA	0xFF
  014D    1003    CLRB	0x3,0
  014E    1D03    SNZB	0x3,2
  014F    294B    JP	0x14B
  0150    0D74    RLCA	0x74
  0151    3E52    ADDIA	0x52
  0152    0084    LD	0x4,A
  0153    1D00    SNZB	0x0,2
  0154    2983    JP	0x183
16:               			{
17:               				KeyLines[SeletedLine].flags.is_forbidden = CLR;
  0155    0879    LD	A,0x79
  0156    00F4    LD	0x74,A
  0157    3001    LDIA	0x1
  0158    1003    CLRB	0x3,0
  0159    0DF4    RLCR	0x74
  015A    3EFF    ADDIA	0xFF
  015B    1003    CLRB	0x3,0
  015C    1D03    SNZB	0x3,2
  015D    2959    JP	0x159
  015E    0D74    RLCA	0x74
  015F    3E52    ADDIA	0x52
  0160    0084    LD	0x4,A
  0161    1000    CLRB	0x0,0
  0162    2983    JP	0x183
18:               			}
19:               			continue;
20:               		}
21:               		if (KeyControl(&KeyLines[SeletedLine]))
  0163    0879    LD	A,0x79
  0164    00F4    LD	0x74,A
  0165    3001    LDIA	0x1
  0166    1003    CLRB	0x3,0
  0167    0DF4    RLCR	0x74
  0168    3EFF    ADDIA	0xFF
  0169    1003    CLRB	0x3,0
  016A    1D03    SNZB	0x3,2
  016B    2967    JP	0x167
  016C    0D74    RLCA	0x74
  016D    3E52    ADDIA	0x52
  016E    2185    CALL	0x185
  016F    120A    CLRB	0xA,4
  0170    118A    CLRB	0xA,3
  0171    3A00    XORIA	0x0
  0172    1D03    SNZB	0x3,2
  0173    297B    JP	0x17B
  0174    2983    JP	0x183
22:               		{
23:               			switch (SeletedLine)
24:               			{
25:               			case PortA:
26:               				YKfls_Big = SET;
  0175    1448    SETB	0x48,0
27:               				KeyLines[PortB].flags.is_forbidden = SET;
  0176    1456    SETB	0x56,0
28:               				return FLUSH_BIG_0;
  0177    3403    RET	0x3
29:               			case PortB:
30:               				YKfls_Sml = SET;
  0178    1548    SETB	0x48,2
31:               				KeyLines[PortA].flags.is_forbidden = SET;
  0179    1452    SETB	0x52,0
32:               				return FLUSH_SML_0;
  017A    3406    RET	0x6
  017B    0879    LD	A,0x79
  017C    3A00    XORIA	0x0
  017D    1903    SZB	0x3,2
  017E    2975    JP	0x175
  017F    3A01    XORIA	0x1
  0180    1903    SZB	0x3,2
  0181    2978    JP	0x178
  0182    2983    JP	0x183
  0183    0AF9    INCR	0x79
  0184    291C    JP	0x11C
33:               			
34:               			default:
35:               				break;
36:               			}
37:               			
38:               		}
39:               	}
40:               	return FALSE;
41:               	
42:               }
43:               
44:               
45:               uint8_t ScanKey(SignalLines line_num)   /*用于判断按键引脚的状态*/
  0202    00F2    LD	0x72,A
46:               {
47:                   switch (line_num)
  0203    2A0C    JP	0x20C
48:               	{
49:               	case PortA:
50:               		return PIKey1;
  0204    3000    LDIA	0x0
  0205    1B05    SZB	0x5,6
  0206    3001    LDIA	0x1
  0207    0008    RET
51:               	case PortB:
52:               		return PIKey2;
  0208    3000    LDIA	0x0
  0209    1806    SZB	0x6,0
  020A    3001    LDIA	0x1
  020B    0008    RET
  020C    0872    LD	A,0x72
  020D    3A00    XORIA	0x0
  020E    1903    SZB	0x3,2
  020F    2A04    JP	0x204
  0210    3A01    XORIA	0x1
  0211    1903    SZB	0x3,2
  0212    2A08    JP	0x208
  0213    2A14    JP	0x214
  0214    0008    RET
53:               	}
54:               }
55:               
56:               
57:               
58:               uint8_t KeyControl(KEY_PRIVATE* this)/*用于按键的消除抖动处理*/
  0185    00E0    LD	0x60,A
59:               {
60:                   if(!(this->flags.level))  //按键按下有效时间判定
  0186    0084    LD	0x4,A
61:                   {
62:               		if (this->flags.is_pressing)
  0187    0860    LD	A,0x60
  0188    1900    SZB	0x0,2
  0189    29DB    JP	0x1DB
  018A    0084    LD	0x4,A
63:               		{
64:               			this->cnt = CLR;
  018B    0A60    INCA	0x60
  018C    1C80    SNZB	0x0,1
  018D    29C0    JP	0x1C0
  018E    0084    LD	0x4,A
  018F    0180    CLR	0x0
65:               
66:               			if (IncrementJudgeToCLR(this->cnt_timeout,CNTKeyOutTime))
  0190    0860    LD	A,0x60
  0191    3E02    ADDIA	0x2
  0192    0084    LD	0x4,A
  0193    3001    LDIA	0x1
  0194    0780    ADDR	0x0
  0195    0A84    INCR	0x4
  0196    1803    SZB	0x3,0
  0197    0A80    INCR	0x0
  0198    0384    DECR	0x4
  0199    0800    LD	A,0x0
  019A    00F2    LD	0x72,A
  019B    0A84    INCR	0x4
  019C    0800    LD	A,0x0
  019D    00F3    LD	0x73,A
  019E    3002    LDIA	0x2
  019F    0273    SUBA	0x73
  01A0    3059    LDIA	0x59
  01A1    1903    SZB	0x3,2
  01A2    0272    SUBA	0x72
  01A3    1803    SZB	0x3,0
  01A4    29A7    JP	0x1A7
  01A5    01DA    CLR	0x5A
  01A6    29B7    JP	0x1B7
  01A7    0860    LD	A,0x60
  01A8    3E02    ADDIA	0x2
  01A9    0084    LD	0x4,A
  01AA    0180    CLR	0x0
  01AB    0A84    INCR	0x4
  01AC    0180    CLR	0x0
  01AD    01F2    CLR	0x72
  01AE    01F3    CLR	0x73
  01AF    0872    LD	A,0x72
  01B0    0473    ORA	0x73
  01B1    1D03    SNZB	0x3,2
  01B2    29B5    JP	0x1B5
  01B3    3001    LDIA	0x1
  01B4    29B6    JP	0x1B6
  01B5    3000    LDIA	0x0
  01B6    00DA    LD	0x5A,A
  01B7    01DB    CLR	0x5B
  01B8    085A    LD	A,0x5A
  01B9    045B    ORA	0x5B
  01BA    1903    SZB	0x3,2
  01BB    3400    RET	0x0
67:               			{			
68:               				this->flags.is_forbidden = SET;
  01BC    0860    LD	A,0x60
  01BD    0084    LD	0x4,A
  01BE    1400    SETB	0x0,0
  01BF    3400    RET	0x0
69:               			}
70:               
71:               		}else
72:               		{
73:               			if (IncrementJudgeToCLR(this->cnt,CNTKeyTime))
  01C0    0084    LD	0x4,A
  01C1    300B    LDIA	0xB
  01C2    0A80    INCR	0x0
  01C3    0200    SUBA	0x0
  01C4    1803    SZB	0x3,0
  01C5    29C8    JP	0x1C8
  01C6    01DC    CLR	0x5C
  01C7    29D1    JP	0x1D1
  01C8    0A60    INCA	0x60
  01C9    0084    LD	0x4,A
  01CA    0180    CLR	0x0
  01CB    1D03    SNZB	0x3,2
  01CC    29CF    JP	0x1CF
  01CD    3001    LDIA	0x1
  01CE    29D0    JP	0x1D0
  01CF    3000    LDIA	0x0
  01D0    00DC    LD	0x5C,A
  01D1    01DD    CLR	0x5D
  01D2    085C    LD	A,0x5C
  01D3    045D    ORA	0x5D
  01D4    1903    SZB	0x3,2
  01D5    3400    RET	0x0
74:               			{
75:               				this->flags.is_pressing = SET;
  01D6    0860    LD	A,0x60
  01D7    0084    LD	0x4,A
  01D8    3001    LDIA	0x1
  01D9    1480    SETB	0x0,1
76:               				return TRUE;
  01DA    0008    RET
77:               			}
78:               		}	
79:               
80:                   }
81:                    else
82:                   {
83:               		if (this->flags.is_pressing)
  01DB    0084    LD	0x4,A
84:               		{
85:               			if (IncrementJudgeToCLR(this->cnt,CNTKeyTime))
  01DC    0A60    INCA	0x60
  01DD    1C80    SNZB	0x0,1
  01DE    29F9    JP	0x1F9
  01DF    0084    LD	0x4,A
  01E0    300B    LDIA	0xB
  01E1    0A80    INCR	0x0
  01E2    0200    SUBA	0x0
  01E3    1803    SZB	0x3,0
  01E4    29E7    JP	0x1E7
  01E5    01DE    CLR	0x5E
  01E6    29F0    JP	0x1F0
  01E7    0A60    INCA	0x60
  01E8    0084    LD	0x4,A
  01E9    0180    CLR	0x0
  01EA    1D03    SNZB	0x3,2
  01EB    29EE    JP	0x1EE
  01EC    3001    LDIA	0x1
  01ED    29EF    JP	0x1EF
  01EE    3000    LDIA	0x0
  01EF    00DE    LD	0x5E,A
  01F0    01DF    CLR	0x5F
  01F1    085E    LD	A,0x5E
  01F2    045F    ORA	0x5F
  01F3    1903    SZB	0x3,2
  01F4    3400    RET	0x0
86:               			{
87:               				this->flags.is_pressing = CLR;
  01F5    0860    LD	A,0x60
  01F6    0084    LD	0x4,A
  01F7    1080    CLRB	0x0,1
  01F8    3400    RET	0x0
88:               			}
89:               		}else
90:               		{
91:               			this->cnt = CLR;
  01F9    0084    LD	0x4,A
  01FA    0180    CLR	0x0
92:               			this->cnt_timeout = CLR;
  01FB    0860    LD	A,0x60
  01FC    3E02    ADDIA	0x2
  01FD    0084    LD	0x4,A
  01FE    0180    CLR	0x0
  01FF    0A84    INCR	0x4
  0200    0180    CLR	0x0
93:               		}
94:                  
95:                   }
96:               	return FALSE;
  0201    3400    RET	0x0
97:               }
---- C:\Users\汪强升\Desktop\ABM007_79F133_\ABM007_79F133\source\fct.c ----------------------------------------------------------------------
1:                #include "cfg_user.h"
2:                #include "cfg_case.h"
3:                
4:                BYTE fctBits001;
5:                
6:                // #define FfctTest fctBits001.bits.bit_0
7:                
8:                volatile unsigned int CNTfctStart;
9:                volatile unsigned char CNTfctSensior;
10:               volatile unsigned char CNTfctFlashLed;
11:               volatile unsigned int CNTfct;
12:               volatile unsigned int CNTkey1;
13:               volatile unsigned int CNTkey2;
14:               volatile unsigned int flag_time;
15:               
16:               unsigned int Flag_G_Key = 0;
17:               
18:               void FCTkey(void);
19:               void FCTjudge(void);
20:               
21:               void FCTloop(void)
22:               {
23:                   FCTkey();
  0326    2360    CALL	0x360
  0327    120A    CLRB	0xA,4
  0328    118A    CLRB	0xA,3
24:                   FCTjudge();
  0329    2B2A    JP	0x32A
25:               }
26:               
27:               /* void FCTkey(void)
28:               {
29:                   if(PItest == HIGH)
30:                   {
31:                       if(++CNTfctStart >= 100)
32:                       {
33:               //            CNTfctStart = 100;
34:                           FfctTest = 1;
35:               			if(PItest == HIGH)
36:               			{
37:               				if(++CNTfctStart >= 500)
38:               				{
39:               					FfctTest = 0;
40:               					CNTfctStart = 0;
41:               					return;
42:               				}
43:               			}
44:               //			CNTfctStart = 0;
45:               			return;
46:                       }
47:                   }
48:               }
49:               */
50:               void FCTkey(void)
51:               {
52:               	if(FfctTest == 1)
  0360    1851    SZB	0x51,0
53:               	{
54:               		if(PItest == HIGH)
  0361    1D06    SNZB	0x6,2
  0362    2B70    JP	0x370
55:               		{
56:               			Delay_nms(1000);
  0363    30E8    LDIA	0xE8
  0364    00F4    LD	0x74,A
  0365    3003    LDIA	0x3
  0366    00F5    LD	0x75,A
  0367    237C    CALL	0x37C
  0368    120A    CLRB	0xA,4
  0369    118A    CLRB	0xA,3
57:               			if(PItest == HIGH)
  036A    1283    CLRB	0x3,5
  036B    1303    CLRB	0x3,6
  036C    1D06    SNZB	0x6,2
  036D    2B70    JP	0x370
58:               			{
59:               				FfctTest = 0;
  036E    1051    CLRB	0x51,0
60:               				return;
  036F    0008    RET
61:               			}
62:               		}
63:               	}
64:                   if(PItest == HIGH)
  0370    1D06    SNZB	0x6,2
  0371    0008    RET
65:                   {
66:               		Delay_nms(1000);
  0372    30E8    LDIA	0xE8
  0373    00F4    LD	0x74,A
  0374    3003    LDIA	0x3
  0375    00F5    LD	0x75,A
  0376    237C    CALL	0x37C
67:               		if(PItest == HIGH)
  0377    1283    CLRB	0x3,5
  0378    1303    CLRB	0x3,6
  0379    1906    SZB	0x6,2
68:               		{
69:               			FfctTest = 1;
  037A    1451    SETB	0x51,0
70:               			return;
  037B    0008    RET
71:               		}
72:               	}
73:               }
74:               
75:               void G_KEY(void)
76:               {
77:               	POlight = LOW;
  034C    1285    CLRB	0x5,5
78:               	POairPump = LOW;
  034D    1105    CLRB	0x5,2
79:               	POmainValue = HIGH;
  034E    1605    SETB	0x5,4
80:               	POdirectValue = LOW;
  034F    1085    CLRB	0x5,1
  0350    0008    RET
81:               }
82:               
83:               void R_KEY(void)
84:               {
85:               	POlight = LOW;
  0351    1285    CLRB	0x5,5
86:               	POairPump = HIGH;
  0352    1505    SETB	0x5,2
87:               	POmainValue = HIGH;
  0353    1605    SETB	0x5,4
88:               	POdirectValue = LOW;
  0354    1085    CLRB	0x5,1
  0355    0008    RET
89:               }
90:               
91:               void key1(void)
92:               {
93:               	POlight = HIGH;
  0356    1685    SETB	0x5,5
94:               	POairPump = LOW;
  0357    1105    CLRB	0x5,2
95:               	POmainValue = HIGH;
  0358    1605    SETB	0x5,4
96:               	POdirectValue = LOW;
  0359    1085    CLRB	0x5,1
  035A    0008    RET
97:               }
98:               
99:               void key2(void)
100:              {
101:              	POlight = LOW;
  035B    1285    CLRB	0x5,5
102:              	POairPump = LOW;
  035C    1105    CLRB	0x5,2
103:              	POmainValue = HIGH;
  035D    1605    SETB	0x5,4
104:              	POdirectValue = HIGH;
  035E    1485    SETB	0x5,1
  035F    0008    RET
105:              }
106:              
107:              void FCTjudge(void)
108:              {
109:                  if(FfctTest == 1)
  032A    1C51    SNZB	0x51,0
  032B    2B43    JP	0x343
110:                  {
111:              		if(++flag_time == 1500)
  032C    0AA0    INCR	0x20
  032D    1903    SZB	0x3,2
  032E    0AA1    INCR	0x21
  032F    30DC    LDIA	0xDC
  0330    0620    XORA	0x20
  0331    3005    LDIA	0x5
  0332    1903    SZB	0x3,2
  0333    0621    XORA	0x21
  0334    1D03    SNZB	0x3,2
  0335    2B39    JP	0x339
112:              		{
113:              			FfctTest = 0;
  0336    1051    CLRB	0x51,0
114:              			flag_time = 0;
  0337    01A0    CLR	0x20
  0338    01A1    CLR	0x21
115:              		}
116:              		if(PIsensor == LOW)
  0339    1886    SZB	0x6,1
  033A    2B3C    JP	0x33C
117:              		{
118:              			R_KEY();
  033B    2B51    JP	0x351
119:              		}
120:              		else
121:              		{
122:              			if(PIKey1 == LOW)
  033C    1B05    SZB	0x5,6
  033D    2B3F    JP	0x33F
123:              			{
124:              				key1();
  033E    2B56    JP	0x356
125:              			}
126:              			else
127:              			{
128:              				if(PIKey2 == LOW)
  033F    1806    SZB	0x6,0
  0340    2B42    JP	0x342
129:              				{
130:              					key2();
  0341    2B5B    JP	0x35B
131:              				}
132:              				else
133:              				{
134:              					G_KEY();
  0342    2B4C    JP	0x34C
135:              				}
136:              			}
137:              		}
138:              	}
139:                  else if(FfctTest == 0)
  0343    1851    SZB	0x51,0
  0344    0008    RET
140:                  {
141:              		POlight = LOW;
  0345    1285    CLRB	0x5,5
142:              		POairPump = LOW;
  0346    1105    CLRB	0x5,2
143:              		POmainValue = LOW;
  0347    1205    CLRB	0x5,4
144:              		POdirectValue = LOW;
  0348    1085    CLRB	0x5,1
145:              		flag_time = 0;
  0349    01A0    CLR	0x20
  034A    01A1    CLR	0x21
  034B    0008    RET
146:                  }
147:              }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    3020    LDIA	0x20
  0010    01F9    CLR	0x79
  0011    01FA    CLR	0x7A
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    305A    LDIA	0x5A
  0015    120A    CLRB	0xA,4
  0016    118A    CLRB	0xA,3
  0017    24B2    CALL	0x4B2
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    2C16    JP	0x416
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    120A    CLRB	0xA,4
  001A    118A    CLRB	0xA,3
  001B    2BA7    JP	0x3A7
  0215    1748    SETB	0x48,6
  0216    1105    CLRB	0x5,2
  0217    1605    SETB	0x5,4
  0218    1085    CLRB	0x5,1
  0219    0AB4    INCR	0x34
  021A    1903    SZB	0x3,2
  021B    0AB5    INCR	0x35
  021C    3000    LDIA	0x0
  021D    0235    SUBA	0x35
  021E    3405    RET	0x5
  021F    1748    SETB	0x48,6
  0220    1105    CLRB	0x5,2
  0221    1605    SETB	0x5,4
  0222    1485    SETB	0x5,1
  0223    0AB4    INCR	0x34
  0224    1903    SZB	0x3,2
  0225    0AB5    INCR	0x35
  0226    3000    LDIA	0x0
  0227    0235    SUBA	0x35
  0228    340A    RET	0xA
  0229    1085    CLRB	0x5,1
  022A    0AB4    INCR	0x34
  022B    1903    SZB	0x3,2
  022C    0AB5    INCR	0x35
  022D    3000    LDIA	0x0
  022E    0235    SUBA	0x35
  022F    0008    RET
  031D    0830    LD	A,0x30
  031E    0732    ADDA	0x32
  031F    00AE    LD	0x2E,A
  0320    0831    LD	A,0x31
  0321    1803    SZB	0x3,0
  0322    0A31    INCA	0x31
  0323    0733    ADDA	0x33
  0324    00AF    LD	0x2F,A
  0325    0008    RET
  04B2    0064    CLRWDT
  04B3    0180    CLR	0x0
  04B4    0A84    INCR	0x4
  04B5    0604    XORA	0x4
  04B6    1903    SZB	0x3,2
  04B7    3400    RET	0x0
  04B8    0604    XORA	0x4
  04B9    2CB3    JP	0x4B3
